{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/304.png","path":"images/304.png","modified":1,"renderable":0},{"_id":"source/images/browser.png","path":"images/browser.png","modified":1,"renderable":0},{"_id":"source/images/gutter-padding.png","path":"images/gutter-padding.png","modified":1,"renderable":0},{"_id":"source/images/layout-browser.png","path":"images/layout-browser.png","modified":1,"renderable":0},{"_id":"source/images/mainjs对比.png","path":"images/mainjs对比.png","modified":1,"renderable":0},{"_id":"source/images/powershell.png","path":"images/powershell.png","modified":1,"renderable":0},{"_id":"source/images/ref效果图.png","path":"images/ref效果图.png","modified":1,"renderable":0},{"_id":"source/images/vue-next-code-tree.png","path":"images/vue-next-code-tree.png","modified":1,"renderable":0},{"_id":"source/images/vue升级3.0-beta.png","path":"images/vue升级3.0-beta.png","modified":1,"renderable":0},{"_id":"source/images/事件效果图.png","path":"images/事件效果图.png","modified":1,"renderable":0},{"_id":"source/images/使用serviceWorker缓存.png","path":"images/使用serviceWorker缓存.png","modified":1,"renderable":0},{"_id":"source/images/原型继承例子.png","path":"images/原型继承例子.png","modified":1,"renderable":0},{"_id":"source/images/效果图-1.png","path":"images/效果图-1.png","modified":1,"renderable":0},{"_id":"source/images/注册成功.png","path":"images/注册成功.png","modified":1,"renderable":0},{"_id":"source/images/有趣的题.jpg","path":"images/有趣的题.jpg","modified":1,"renderable":0},{"_id":"source/images/等式成立.png","path":"images/等式成立.png","modified":1,"renderable":0},{"_id":"source/images/缓存成功.png","path":"images/缓存成功.png","modified":1,"renderable":0},{"_id":"source/images/缓存策略.png","path":"images/缓存策略.png","modified":1,"renderable":0},{"_id":"source/images/触发toString.png","path":"images/触发toString.png","modified":1,"renderable":0},{"_id":"source/images/转换规则.png","path":"images/转换规则.png","modified":1,"renderable":0},{"_id":"source/images/钩子效果图.png","path":"images/钩子效果图.png","modified":1,"renderable":0},{"_id":"source/images/高斯模糊.png","path":"images/高斯模糊.png","modified":1,"renderable":0},{"_id":"source/images/3and4.jpg","path":"images/3and4.jpg","modified":1,"renderable":0},{"_id":"source/images/red4route.jpg","path":"images/red4route.jpg","modified":1,"renderable":0},{"_id":"source/images/sina_yyx.jpg","path":"images/sina_yyx.jpg","modified":1,"renderable":0},{"_id":"source/images/tllearnroute.jpg","path":"images/tllearnroute.jpg","modified":1,"renderable":0},{"_id":"source/images/book.jpg","path":"images/book.jpg","modified":1,"renderable":0},{"_id":"source/images/致敬英雄iqiyi.png","path":"images/致敬英雄iqiyi.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/insight.css","path":"css/insight.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/search.css","path":"css/search.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/logo-3.png","path":"images/logo-3.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/og_image.png","path":"images/og_image.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/avatar01.jpg","path":"images/avatar01.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/avatar1.jpg","path":"images/avatar1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-icarus/source/images/avatar2.jpg","path":"images/avatar2.jpg","modified":1,"renderable":1},{"_id":"source/images/致敬英雄bilibili.png","path":"images/致敬英雄bilibili.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/hexo-theme-icarus/.gitignore","hash":"ece1c3037855e866d5816467cdfb2cef4e36e0a7","modified":1569131370287},{"_id":"themes/hexo-theme-icarus/LICENSE","hash":"62e3701684087bc9a66f0b20386036ede9b430b7","modified":1569131370288},{"_id":"themes/hexo-theme-icarus/README.md","hash":"921a87a50b130e1324fc0111e325d949ff74e1df","modified":1569131370289},{"_id":"themes/hexo-theme-icarus/_config.yml","hash":"338b02277b0906e884170c143fc4f45ab1254e52","modified":1600270871926},{"_id":"themes/hexo-theme-icarus/package.json","hash":"6866c0bff4854214cba431d0cbc079102fcba9c8","modified":1569131370451},{"_id":"source/_posts/2020快到了，面对复盘的疾风吧！！！.md","hash":"fdf65b745b2fe5c724ebc41ef72e5e8513de3343","modified":1579577095226},{"_id":"source/_posts/ES6----Proxy.md","hash":"723f73b6dd7db3380d721658505aa6f203cda1b4","modified":1579577039102},{"_id":"source/_posts/JavaScript整理总结(持续更新).md","hash":"075b5dcbb4f92010df55ef861835d901995df8ba","modified":1582675161507},{"_id":"source/_posts/Module.md","hash":"9b73773c5cde3c2f698019983f4a0b8d51eba75d","modified":1580806433604},{"_id":"source/_posts/Vue3.0它来了，带着Pre-Alpha来了.md","hash":"ea5225baf4e3eb94b8adc37dd13833bd754e5129","modified":1570525549163},{"_id":"source/_posts/finished-proposals-ES2020.md","hash":"eb64a74bae012c143412f4b8df63522091ff34cd","modified":1579576987615},{"_id":"source/_posts/vue3.0-beta尝鲜.md","hash":"21da613d3010227cf2b5d5628ba560f6db824298","modified":1588438744746},{"_id":"source/_posts/《程序员修炼之道》--务实的哲学.md","hash":"2613b31e9d4782c891199573d30c4b7e19a42613","modified":1590333470461},{"_id":"source/_posts/《程序员修炼之道》--务实的方法（上）.md","hash":"ee6c0a57b0bf853f526453ea9abc2b8100b51550","modified":1589983864688},{"_id":"source/_posts/《程序员修炼之道》--务实的方法（下）.md","hash":"9fd744916ae55bf27fbdfe10378f44097dabcd4e","modified":1596983719584},{"_id":"source/_posts/《程序员修炼之道》.md","hash":"ef6ac8af834d90d3286272f26844da84ca84280c","modified":1588947320773},{"_id":"source/_posts/分享一道有趣的题.md","hash":"e7e2a7c2b8dbfa985ce013d18d41c10cf5d7765c","modified":1584885648610},{"_id":"source/_posts/前端幸福感是如何炼成的.md","hash":"e2cdd30d6551bfbb7dc6cef4398e956cfd2c01bb","modified":1579577179995},{"_id":"source/_posts/前端幸福感是如何炼成的（下）.md","hash":"cb5566b1ed518f879c8cb53c5680630c8e787e19","modified":1574132508559},{"_id":"source/_posts/响应式原理-2.x版本（上）.md","hash":"7f572d6bf83e492510bbcf3cfd6af3efc7ed18aa","modified":1570861818949},{"_id":"source/_posts/响应式原理-2.x版本（下）.md","hash":"605eea9499333f788908f9bb4402c21d5eca0450","modified":1579577132975},{"_id":"source/_posts/回归初心，重新出发.md","hash":"1991d04c3c55ded595ab778606fcd1c35e1ec415","modified":1569381185285},{"_id":"source/_posts/左手绿皮，右手红宝.md","hash":"be56e92f286d1f7bcc6e4c5dbc71bcc4352cb075","modified":1600590601858},{"_id":"source/_posts/开发一个UI框架-button.md","hash":"25b841fdd0ef6e607aadb0104d6aafd1a875581e","modified":1599920129551},{"_id":"source/_posts/开发一个UI框架-container.md","hash":"2bb3f0882791af466ddbd7fd6f766980632c7694","modified":1600269701073},{"_id":"source/_posts/开发一个UI框架-layout.md","hash":"22f6204da85fc151bebcde5041cdcfe8b745e3a7","modified":1599920095071},{"_id":"source/_posts/开发一个UI框架-前置工作.md","hash":"18326a8f8dadd7259f29c68410c4f158ad7def01","modified":1599920177869},{"_id":"source/_posts/打算开发一个UI框架项目.md","hash":"001d07d23705ec660a90699af2aece5aa57fe001","modified":1599920232037},{"_id":"source/_posts/浅析HTTP缓存.md","hash":"cbf64e48a5e87efb466c934f4308c2d649d8bdf9","modified":1582674890201},{"_id":"source/_posts/浅析浏览器另外三大缓存.md","hash":"cf8d1c8c6896276493687a100e5bffc5380bfa7a","modified":1582178653170},{"_id":"source/_posts/致敬英雄，主流网站置灰的探索.md","hash":"f04bfc2f9c82335c39e0c277d9657dea550af204","modified":1586181171332},{"_id":"source/_posts/风一吹不回来.md","hash":"617c1c9acab45502bf3cc2d1db233cd6ca21a66f","modified":1573056622792},{"_id":"source/about/index.md","hash":"ec3d0951357be3742034a86cc524e5d76107106d","modified":1596985338973},{"_id":"source/images/304.png","hash":"ba777401ed035dd68c4bb37b18c82dd1881a9a9c","modified":1581500462929},{"_id":"source/images/browser.png","hash":"305cc9455f6d47dc90a7f9bf943815da9247e838","modified":1599234900999},{"_id":"source/images/gutter-padding.png","hash":"e2e3e48a60c1b2b946eb8e4beff5b308a53540f2","modified":1599919572166},{"_id":"source/images/layout-browser.png","hash":"023114ff4781d096504a74265f9726b6af5b76de","modified":1599919572167},{"_id":"source/images/mainjs对比.png","hash":"743a64cdc2e7c62451fce712eb5b9dd4b8cb36a1","modified":1588388606433},{"_id":"source/images/powershell.png","hash":"73d4806fe5d78aab30843bf79d16fb2bd1204443","modified":1599234901000},{"_id":"source/images/ref效果图.png","hash":"995567ce907c264438c2d6ad0a15359109c97652","modified":1588424697243},{"_id":"source/images/vue-next-code-tree.png","hash":"b03f41e302bcf8f1bf306e7c1dfb946ead2d96e1","modified":1570461148026},{"_id":"source/images/vue升级3.0-beta.png","hash":"d8c838a5be056b3ac3ad9c9473f1c29fb867eda9","modified":1588387656483},{"_id":"source/images/事件效果图.png","hash":"2673b68073f2402d7424d61fb2930f7beef03826","modified":1588425972103},{"_id":"source/images/使用serviceWorker缓存.png","hash":"7a19bad05afbab72b5240914ad4a1b32dcecfb3c","modified":1582178426549},{"_id":"source/images/原型继承例子.png","hash":"6b2fcf8a4b1f1a4ce4f4bb9dc4bbac93892b7c9a","modified":1582675133601},{"_id":"source/images/效果图-1.png","hash":"d7b0e9a6c19df0ba100fcd8c093c72891e311e4f","modified":1588424633343},{"_id":"source/images/注册成功.png","hash":"3bd38efe86759651c1624fb24f70a36073649123","modified":1582164889753},{"_id":"source/images/有趣的题.jpg","hash":"7aa23adb569bd4f3de11bae41b17099bc3bd8467","modified":1600560342000},{"_id":"source/images/等式成立.png","hash":"09f7b67b4fe5649153b7e728918e7d61d36ab562","modified":1584884544916},{"_id":"source/images/缓存成功.png","hash":"540ad5c27c000751c4ae587841a2258990b345ca","modified":1582165022671},{"_id":"source/images/缓存策略.png","hash":"05d3e769e0df24231905ceb15868be72b68a0892","modified":1582537379127},{"_id":"source/images/触发toString.png","hash":"6e791f1e682589734b4037f18faf19eefa79a551","modified":1584884126070},{"_id":"source/images/转换规则.png","hash":"b47e5f4cd3e6da5b19031dfb62d0abfb3ec81278","modified":1582675054316},{"_id":"source/images/钩子效果图.png","hash":"6e06efeba97acb75a57a97dffe3df653c48714b2","modified":1588436831342},{"_id":"themes/hexo-theme-icarus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1569131370244},{"_id":"themes/hexo-theme-icarus/.git/config","hash":"7b9dd27b1a850e883885c30b03f2abbc794137fd","modified":1569131370260},{"_id":"themes/hexo-theme-icarus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1569131050216},{"_id":"themes/hexo-theme-icarus/.git/index","hash":"ff717cfb6d3824988a27ee1b55c79a2257d98f3a","modified":1569131370481},{"_id":"source/images/高斯模糊.png","hash":"ebb4946f72669d63e1f79b9ce3f41856cf40080a","modified":1600560344000},{"_id":"themes/hexo-theme-icarus/.git/packed-refs","hash":"2f168cddecdebbbd5871eee8126f4dccf27b26b0","modified":1569131370215},{"_id":"themes/hexo-theme-icarus/.github/ISSUE_TEMPLATE.md","hash":"e50411021e3c85860fc4b96f446267ba9871dcde","modified":1569131370286},{"_id":"themes/hexo-theme-icarus/languages/en.yml","hash":"cb16c889ac2ee5b11dd990b786fb1f4768ffd454","modified":1569131370346},{"_id":"themes/hexo-theme-icarus/languages/es.yml","hash":"d7d9e8c43237bcdf3dd0dd9f40ae18a0a2e136d4","modified":1569131370348},{"_id":"themes/hexo-theme-icarus/languages/fr.yml","hash":"b85a2d4fcc790a8b84326235850eb54532f6b75e","modified":1569131370349},{"_id":"themes/hexo-theme-icarus/languages/id.yml","hash":"ee655e6a045eb28ea480a348bbefd10ef115494b","modified":1569131370350},{"_id":"themes/hexo-theme-icarus/languages/ja.yml","hash":"3c921f24b19a797b2ae23cf621a35bb9b043ddf9","modified":1569131370351},{"_id":"themes/hexo-theme-icarus/languages/ko.yml","hash":"2eeedc4efd27d344b4210310ee8ca68f8c826a72","modified":1569131370353},{"_id":"themes/hexo-theme-icarus/languages/pl.yml","hash":"a6dbd568cb18104685b20ab7b5767f455628f61c","modified":1569131370354},{"_id":"themes/hexo-theme-icarus/languages/pt-BR.yml","hash":"28ae713d8d26ab875104684e604592f4c495b638","modified":1569131370355},{"_id":"themes/hexo-theme-icarus/languages/ru.yml","hash":"62451109780acfe2db8630248005697c10a68a61","modified":1569131370357},{"_id":"themes/hexo-theme-icarus/languages/tr.yml","hash":"2e334f0f98756256754f48d8dff3baa045700283","modified":1569131370358},{"_id":"themes/hexo-theme-icarus/languages/vn.yml","hash":"cd2d57a3fe6389bdd76f193c6c662d242960ed02","modified":1569131370359},{"_id":"themes/hexo-theme-icarus/languages/zh-CN.yml","hash":"1ca3f7b92872443c79b5f8026272b3bd21b4dd46","modified":1569131370360},{"_id":"themes/hexo-theme-icarus/languages/zh-TW.yml","hash":"57126abcfd47318e7c04c24034ab27d36a5663ac","modified":1569131370362},{"_id":"themes/hexo-theme-icarus/layout/archive.ejs","hash":"20cf8fbafec35d826a2e363ce1eee8dbf1b3011c","modified":1569131370364},{"_id":"themes/hexo-theme-icarus/layout/categories.ejs","hash":"5df2ae61ec3869d265113d695e2e25aaa60e8e67","modified":1569131370365},{"_id":"themes/hexo-theme-icarus/layout/category.ejs","hash":"d3c97be4f70c7d5a6b8512d94d54110e044b8461","modified":1569131370367},{"_id":"themes/hexo-theme-icarus/layout/index.ejs","hash":"4e088cfb6fa4b50a1cb422a00623aba1975529e1","modified":1569131370399},{"_id":"themes/hexo-theme-icarus/layout/layout.ejs","hash":"fda7fae00a461644099a99d03a2401256fe80a2d","modified":1579570235730},{"_id":"themes/hexo-theme-icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1569131370402},{"_id":"themes/hexo-theme-icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1569131370418},{"_id":"themes/hexo-theme-icarus/layout/tag.ejs","hash":"148453030e534c70cdc68ed5b2a1c7037d662ace","modified":1569131370435},{"_id":"themes/hexo-theme-icarus/layout/tags.ejs","hash":"9b185ad009855aa645e6fb5ccb28c022571852d0","modified":1569131370436},{"_id":"themes/hexo-theme-icarus/scripts/index.js","hash":"57debc1a785487face0b7358ac5c40563d6b6392","modified":1569131370453},{"_id":"source/images/3and4.jpg","hash":"cec4704f310f9a0e1ed8ce984a1f9cdfe033f86e","modified":1600560344000},{"_id":"source/images/red4route.jpg","hash":"52ce87dcdb3cc16cddd46c37c132ce6e5a057318","modified":1600584639898},{"_id":"source/images/sina_yyx.jpg","hash":"df288025c5f3dfc8636bda42e352ad22ea78dca9","modified":1570461122245},{"_id":"source/images/tllearnroute.jpg","hash":"8e6a7c452c42cb537a0f91cccf3dd62fd0d9698f","modified":1600584632371},{"_id":"source/images/book.jpg","hash":"a51645d91def72649bce951d679353424744b7e8","modified":1600560344000},{"_id":"themes/hexo-theme-icarus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1569131050219},{"_id":"themes/hexo-theme-icarus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1569131050220},{"_id":"themes/hexo-theme-icarus/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1569131050222},{"_id":"themes/hexo-theme-icarus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1569131050224},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1569131050225},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1569131050226},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1569131050228},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1569131050230},{"_id":"themes/hexo-theme-icarus/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1569131050231},{"_id":"source/images/致敬英雄iqiyi.png","hash":"0abc4cc7df291f55d3849f824243de4a28371314","modified":1600560342000},{"_id":"themes/hexo-theme-icarus/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1569131050232},{"_id":"themes/hexo-theme-icarus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1569131050234},{"_id":"themes/hexo-theme-icarus/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1569131050236},{"_id":"themes/hexo-theme-icarus/.git/logs/HEAD","hash":"d12bca61a05b11d0782fa0bef0dbfa9edd1ea6e1","modified":1569131370250},{"_id":"themes/hexo-theme-icarus/includes/common/ConfigGenerator.js","hash":"b921f7ab80c3de92291ce2c9081baa4464133787","modified":1569131370292},{"_id":"themes/hexo-theme-icarus/includes/common/ConfigValidator.js","hash":"7c7cec251070d72c33139d5c19bef03dc9a57e15","modified":1569131370294},{"_id":"themes/hexo-theme-icarus/includes/common/utils.js","hash":"4099226113e3d631b58452f529d58cf00758fd24","modified":1569131370296},{"_id":"themes/hexo-theme-icarus/includes/filters/highlight.js","hash":"4c6b4a4062ef836295046b170bdcda8776729c66","modified":1569131370299},{"_id":"themes/hexo-theme-icarus/includes/generators/categories.js","hash":"6aef75f08a11a06e5c72d9b0b768c3aa7462080c","modified":1569131370302},{"_id":"themes/hexo-theme-icarus/includes/generators/category.js","hash":"1f40399fc0d56f89490d669c6399cd40b9465e93","modified":1569131370303},{"_id":"themes/hexo-theme-icarus/includes/generators/insight.js","hash":"8fcac981ab9537fc110ff8a6d00f67bd6f41aeec","modified":1569131370304},{"_id":"themes/hexo-theme-icarus/includes/generators/tags.js","hash":"ee929b68019b4759099d292257971d3267c5abd7","modified":1569131370306},{"_id":"themes/hexo-theme-icarus/includes/helpers/cdn.js","hash":"10ed3f19f2bc317e4c706f74bc8cc27c87c533e4","modified":1569131370308},{"_id":"themes/hexo-theme-icarus/includes/helpers/config.js","hash":"f1becefd247f03bf5b31347ffda23e9480bb4566","modified":1569131370309},{"_id":"themes/hexo-theme-icarus/includes/helpers/layout.js","hash":"f020fad32fd9977a17b19b755bb9e5fd506fc5a9","modified":1569131370311},{"_id":"themes/hexo-theme-icarus/includes/helpers/override.js","hash":"26a5307c5ab99f7c8c96e94bbfc047c7fac5e6cd","modified":1569131370312},{"_id":"themes/hexo-theme-icarus/includes/helpers/page.js","hash":"1486792ec2528fa656ad258d588a6d261bd94467","modified":1569131370314},{"_id":"themes/hexo-theme-icarus/includes/helpers/site.js","hash":"4142e0b3418ff2ef186979d8bb7023f54ca3185d","modified":1569131370315},{"_id":"themes/hexo-theme-icarus/includes/specs/article.spec.js","hash":"7625a4adbaaf4ce80ef4af2c34b4cdae194a0c4b","modified":1569131370317},{"_id":"themes/hexo-theme-icarus/includes/specs/comment.spec.js","hash":"a9e433f905270b6f8c5689bc0f8583b9c42696dc","modified":1569131370319},{"_id":"themes/hexo-theme-icarus/includes/specs/config.spec.js","hash":"e2a6c34d7ac9a5af828670da4ff1ce92ed298e49","modified":1569131370320},{"_id":"themes/hexo-theme-icarus/includes/specs/donate.spec.js","hash":"bc47f29f158b5c61de45c3b7ab7b8932e145bed6","modified":1569131370323},{"_id":"themes/hexo-theme-icarus/includes/specs/footer.spec.js","hash":"6b65be067c332fba3c901e863a5802089a2149a3","modified":1569131370325},{"_id":"themes/hexo-theme-icarus/includes/specs/icon_link.spec.js","hash":"5424cb681dbb475908f3708d8635380cf48a610e","modified":1569131370326},{"_id":"themes/hexo-theme-icarus/includes/specs/meta.spec.js","hash":"850fc6f965089abc9e53e032eae1469994d5fd0c","modified":1569131370328},{"_id":"themes/hexo-theme-icarus/includes/specs/navbar.spec.js","hash":"cb99fedec56fb1b1df72d90769d245fb0dd08a9d","modified":1569131370329},{"_id":"themes/hexo-theme-icarus/includes/specs/plugins.spec.js","hash":"1ef55aafe89be3b3aee110cbea319ff0a7cf0df8","modified":1569131370331},{"_id":"themes/hexo-theme-icarus/includes/specs/providers.spec.js","hash":"cde56bce96c74ea40d8ebe5824e0b6b0b46c051a","modified":1569131370333},{"_id":"themes/hexo-theme-icarus/includes/specs/search.spec.js","hash":"222a535e4fe9517ca4b6089a704fd38d6bec1a8a","modified":1569131370334},{"_id":"themes/hexo-theme-icarus/includes/specs/share.spec.js","hash":"cf52737b5be1d3e8a71af89ec617cb12ea39393f","modified":1569131370336},{"_id":"themes/hexo-theme-icarus/includes/specs/sidebar.spec.js","hash":"b36aa88d2fc573eaa97df93ce5e00ad8610f6f16","modified":1569131370337},{"_id":"themes/hexo-theme-icarus/includes/specs/widgets.spec.js","hash":"ce25f7c241a632f75da109895cc0f08d894369cd","modified":1569131370339},{"_id":"themes/hexo-theme-icarus/includes/tasks/check_config.js","hash":"a69b003cd482c2fe4495705c5e075d73e7e54ceb","modified":1569131370341},{"_id":"themes/hexo-theme-icarus/includes/tasks/check_deps.js","hash":"79029c355e1c2dba598e901efe7c5f1ada488cdb","modified":1569131370343},{"_id":"themes/hexo-theme-icarus/includes/tasks/welcome.js","hash":"73d0ff7bc3e40d7178fb5627fec2a41c15c585e6","modified":1569131370344},{"_id":"themes/hexo-theme-icarus/layout/comment/changyan.ejs","hash":"e0a2716e7a6c7da26182135fce4776596761a699","modified":1569131370369},{"_id":"themes/hexo-theme-icarus/layout/comment/disqus.ejs","hash":"dff3a7b30440cf7d0e318bfa69d7b9036881ae09","modified":1569131370370},{"_id":"themes/hexo-theme-icarus/layout/comment/facebook.ejs","hash":"e85147af863387b27ea2417581f7268708a4d863","modified":1569131370372},{"_id":"themes/hexo-theme-icarus/layout/comment/gitalk.ejs","hash":"70250fc35364da499bcd4b3d902729f180f071cc","modified":1569131370373},{"_id":"themes/hexo-theme-icarus/layout/comment/gitment.ejs","hash":"886026a36495f3c57cdef46bc9e9a94a0e390eb0","modified":1569131370374},{"_id":"themes/hexo-theme-icarus/layout/comment/isso.ejs","hash":"55bfe636859f118b40750bd36e2c3ef1a2ec4c0e","modified":1569131370376},{"_id":"themes/hexo-theme-icarus/layout/comment/livere.ejs","hash":"792a1e44b71ed8048903ea898aeaf74a6c109037","modified":1569131370378},{"_id":"themes/hexo-theme-icarus/layout/comment/valine.ejs","hash":"a29cf2e69f66a37ddcec8343c60af1e676dcb77d","modified":1569131370380},{"_id":"themes/hexo-theme-icarus/layout/common/article.ejs","hash":"a53befbaecc5a2767af840393a4508dccf2145cf","modified":1569131370382},{"_id":"themes/hexo-theme-icarus/layout/common/footer.ejs","hash":"a80c53a9d9203ed7fb32adf08c79166e012d6af8","modified":1569131370384},{"_id":"themes/hexo-theme-icarus/layout/common/head.ejs","hash":"e87cf51834c24dd85b9c3389b48c185b726887a8","modified":1569131370385},{"_id":"themes/hexo-theme-icarus/layout/common/navbar.ejs","hash":"556f2eee649caf431f32e64daf77c297e0937896","modified":1569131370386},{"_id":"themes/hexo-theme-icarus/layout/common/old_widget.ejs","hash":"014af2cf013fae5d6cee74ec1b62692f6d7e07de","modified":1579576041688},{"_id":"themes/hexo-theme-icarus/layout/common/paginator.ejs","hash":"92efd4c3f4a47d8423fe7e09ecdddb2e335553cc","modified":1569131370388},{"_id":"themes/hexo-theme-icarus/layout/common/scripts.ejs","hash":"56d7eba29b1b25e81217a902ca4f417b40752997","modified":1569148589752},{"_id":"themes/hexo-theme-icarus/layout/common/widget.ejs","hash":"fe0f04426afd26fd1a4184a32ff0522fd2075592","modified":1579576489208},{"_id":"themes/hexo-theme-icarus/layout/donate/alipay.ejs","hash":"c3b24c01f6d9ae8aac4dab9af658ba7b6566419f","modified":1569131370394},{"_id":"themes/hexo-theme-icarus/layout/donate/patreon.ejs","hash":"1720c77b63058faabfe76385c1f21442475534f9","modified":1569131370395},{"_id":"themes/hexo-theme-icarus/layout/donate/paypal.ejs","hash":"60d8b1432e123c2bc03d7cb77288661086dcdc3c","modified":1569131370397},{"_id":"themes/hexo-theme-icarus/layout/donate/wechat.ejs","hash":"456b0dcdd005ff04210c1cebbddd2b9fa2a94dca","modified":1569131370398},{"_id":"themes/hexo-theme-icarus/layout/plugin/animejs.ejs","hash":"0454c332b5ecf2c811ed2bc4d7dbebb1b5fcf9cf","modified":1569131370404},{"_id":"themes/hexo-theme-icarus/layout/plugin/back-to-top.ejs","hash":"15da86153379c409b475fd70336fcecafe502539","modified":1569131370406},{"_id":"themes/hexo-theme-icarus/layout/plugin/baidu-analytics.ejs","hash":"97bd00bea4ac13580b107316c041fc850857da19","modified":1569131370407},{"_id":"themes/hexo-theme-icarus/layout/plugin/busuanzi.ejs","hash":"2b10558454554ed47f1cb23d0ce1422d353684b4","modified":1569131370408},{"_id":"themes/hexo-theme-icarus/layout/plugin/gallery.ejs","hash":"e8c4255a76e423ca41289b344b44df1e2283b34f","modified":1569131370410},{"_id":"themes/hexo-theme-icarus/layout/plugin/google-analytics.ejs","hash":"dfab055884e07b2d54dab675fecb22826b6e4759","modified":1569131370412},{"_id":"themes/hexo-theme-icarus/layout/plugin/hotjar.ejs","hash":"5d07ebfabf5c43d32ad6df0ae135634d217f8c55","modified":1569131370413},{"_id":"themes/hexo-theme-icarus/layout/plugin/mathjax.ejs","hash":"10bf4c017afb40810cfa3dfa6616f7acc98ae2da","modified":1569131370414},{"_id":"themes/hexo-theme-icarus/layout/plugin/outdated-browser.ejs","hash":"6f3a7b78e0dd1db5bc901e9b20e0c7c719ace2e8","modified":1569131370416},{"_id":"themes/hexo-theme-icarus/layout/plugin/progressbar.ejs","hash":"ab71a935a9d760eca55ea90842378aa58f1bcdad","modified":1569131370417},{"_id":"themes/hexo-theme-icarus/layout/search/baidu.ejs","hash":"c5a79c1450abf38317e697ef7a819858ff6ae898","modified":1569131370421},{"_id":"themes/hexo-theme-icarus/layout/search/google-cse.ejs","hash":"1a00151869919b230f1c0a0bec10475e24b81c97","modified":1569131370423},{"_id":"themes/hexo-theme-icarus/layout/search/insight.ejs","hash":"b22352d27cd0636898207a840a20b6c85267b23b","modified":1569131370424},{"_id":"themes/hexo-theme-icarus/layout/share/addthis.ejs","hash":"9cc26da261527bbba8b0180e0f73e0c6ae5416b5","modified":1569131370427},{"_id":"themes/hexo-theme-icarus/layout/share/addtoany.ejs","hash":"04930e5dde7d47ddb1375730504edbfb59afaed5","modified":1569131370428},{"_id":"themes/hexo-theme-icarus/layout/share/bdshare.ejs","hash":"90e24e50c1dc18c22fbb9fa24320bf669e8a6283","modified":1569131370430},{"_id":"themes/hexo-theme-icarus/layout/share/sharejs.ejs","hash":"b59c0708480ead768d15ef53ce028b5f1a715960","modified":1569131370431},{"_id":"themes/hexo-theme-icarus/layout/share/sharethis.ejs","hash":"307d905cd39ac4908ef5589829a18777f314428d","modified":1569131370433},{"_id":"themes/hexo-theme-icarus/layout/widget/archive.ejs","hash":"96950a7e27b7b0b808d5b5a81f192d5e0fec1967","modified":1569131370439},{"_id":"themes/hexo-theme-icarus/layout/widget/category.ejs","hash":"c2a9f2211a21a168c54b0563cdfd58bd25fa39fe","modified":1569131370440},{"_id":"themes/hexo-theme-icarus/layout/widget/links.ejs","hash":"0c3896328be3ac7103232280e02f661ff77146dd","modified":1569131370441},{"_id":"themes/hexo-theme-icarus/layout/widget/profile.ejs","hash":"49affccb85745914dba450d94d402618e9f33f3f","modified":1569131370443},{"_id":"themes/hexo-theme-icarus/layout/widget/recent_posts.ejs","hash":"fc37971b9de01ba4cab5941bd85212609ca7813c","modified":1569131370444},{"_id":"themes/hexo-theme-icarus/layout/widget/tag.ejs","hash":"8c5b8020ca776cc3ebbc7b723915f3173efc28d4","modified":1569131370446},{"_id":"themes/hexo-theme-icarus/layout/widget/tagcloud.ejs","hash":"4a9d37e625762317a12b81b7f2b6bb530fda1c0b","modified":1569131370448},{"_id":"themes/hexo-theme-icarus/layout/widget/toc.ejs","hash":"b15bf481b8e9aea8d1907126004b6a181d8c1935","modified":1569131370450},{"_id":"themes/hexo-theme-icarus/source/css/back-to-top.css","hash":"ab0304e684db5e2f45520a511df5aa36a04d2f2a","modified":1569131370457},{"_id":"themes/hexo-theme-icarus/source/css/insight.css","hash":"10aedd26a4930166b826d72b25cdbd509609b84b","modified":1569131370459},{"_id":"themes/hexo-theme-icarus/source/css/progressbar.css","hash":"a3ef2b1ee0ee0889a82c3c693e53139fd4c0d143","modified":1569131370460},{"_id":"themes/hexo-theme-icarus/source/css/search.css","hash":"b2fb780ce22684998a47b282a57f603511b040b2","modified":1569131370461},{"_id":"themes/hexo-theme-icarus/source/css/style.styl","hash":"2bb14fbf435fb5f8e5b1d23b825890a59c6d1f27","modified":1569131370463},{"_id":"themes/hexo-theme-icarus/source/images/avatar.jpg","hash":"661b052169bff3a2de0aed6a3d57ef7c4a658d4e","modified":1564495784285},{"_id":"themes/hexo-theme-icarus/source/images/favicon.ico","hash":"b3679fe90142172ec94bfab8c5919d5c5204091b","modified":1569380052996},{"_id":"themes/hexo-theme-icarus/source/images/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1569131370467},{"_id":"themes/hexo-theme-icarus/source/images/logo-3.png","hash":"5c8b139bcf2ff2df8f5a2232129ca861822d5b52","modified":1569159588794},{"_id":"themes/hexo-theme-icarus/source/images/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1569131370469},{"_id":"themes/hexo-theme-icarus/source/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1569131370470},{"_id":"themes/hexo-theme-icarus/source/images/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1569131370472},{"_id":"themes/hexo-theme-icarus/source/js/animation.js","hash":"eabfccd284ca67920dd7977aa664d8b32b1911f7","modified":1569131370474},{"_id":"themes/hexo-theme-icarus/source/js/back-to-top.js","hash":"0c59b27d77fbf53fe9197d0856f87114b2bb33aa","modified":1569131370475},{"_id":"themes/hexo-theme-icarus/source/js/gallery.js","hash":"c161252f214d787a9fd895c4c5124579169445d1","modified":1569131370477},{"_id":"themes/hexo-theme-icarus/source/js/insight.js","hash":"c8669315f46c197efe9e9cd448d5b983049f348d","modified":1569131370478},{"_id":"themes/hexo-theme-icarus/source/js/main.js","hash":"4ce6070fa94d7f6d19acc15510db666de54c7132","modified":1569131370480},{"_id":"themes/hexo-theme-icarus/source/images/avatar01.jpg","hash":"b052bff60044042b057187b34b21d47d89459c09","modified":1600270469271},{"_id":"themes/hexo-theme-icarus/source/images/avatar1.jpg","hash":"496acc6b9f27a0f6d16b3192c44a27a6a287170b","modified":1596955592000},{"_id":"themes/hexo-theme-icarus/source/images/avatar2.jpg","hash":"34bbf9766231777978955e41a61ced082e64407b","modified":1596955594000},{"_id":"source/images/致敬英雄bilibili.png","hash":"6de179027db1a51a2551c7385f3c5e3b139de24c","modified":1600560342000},{"_id":"themes/hexo-theme-icarus/.git/refs/heads/master","hash":"30425e96c16f4da8edaec7ac0934a5262aab7568","modified":1569131370249},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-9193c95b95d15176717b38fc1e5238e8f8792a96.idx","hash":"333cfe76c1c6aa314741b0e907bb3df19c65fbb4","modified":1569131370137},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/heads/master","hash":"d12bca61a05b11d0782fa0bef0dbfa9edd1ea6e1","modified":1569131370254},{"_id":"themes/hexo-theme-icarus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1569131370241},{"_id":"themes/hexo-theme-icarus/.git/logs/refs/remotes/origin/HEAD","hash":"d12bca61a05b11d0782fa0bef0dbfa9edd1ea6e1","modified":1569131370241},{"_id":"themes/hexo-theme-icarus/.git/objects/pack/pack-9193c95b95d15176717b38fc1e5238e8f8792a96.pack","hash":"7a07d2ba34f1a74410d0c52cdd658e1cbc189e0e","modified":1569131370133},{"_id":"public/content.json","hash":"108b0b4d3f56ac3df2c2afdbf9bfec806e5d6065","modified":1600590634206},{"_id":"public/about/index.html","hash":"7817960a669a40454909d8150d69ab32ddffa949","modified":1600590635471},{"_id":"public/2020/09/20/左手绿皮，右手红宝/index.html","hash":"56651b05c7edd07cc6400de2e1df23fb34e399a8","modified":1600590635471},{"_id":"public/2020/09/16/开发一个UI框架-container/index.html","hash":"f2226f5fc28872e5598c17b9e7f4be3d76103ec5","modified":1600590635471},{"_id":"public/2020/09/12/开发一个UI框架-layout/index.html","hash":"96b0062d9690d1b007ce6d807ecb6faa63b4c39f","modified":1600590635472},{"_id":"public/2020/09/04/开发一个UI框架-button/index.html","hash":"38ecdba71f0d94a3d54d72df76b66242a3f825f6","modified":1600590635472},{"_id":"public/2020/08/31/开发一个UI框架-前置工作/index.html","hash":"e8df699dbcc8dfbda30578d4eae797e361c32fd7","modified":1600590635472},{"_id":"public/2020/08/30/打算开发一个UI框架项目/index.html","hash":"dfb7e519cd4f5276724086d92a5bb072409a974b","modified":1600590635472},{"_id":"public/2020/08/04/《程序员修炼之道》--务实的方法（下）/index.html","hash":"a1033fb789c5214a3e18f3a945eecda7130a440c","modified":1600590635472},{"_id":"public/2020/05/15/《程序员修炼之道》--务实的方法（上）/index.html","hash":"98f371330028a4a3472344b3aa8d9e116952c9e4","modified":1600590635472},{"_id":"public/2020/05/09/《程序员修炼之道》--务实的哲学/index.html","hash":"71e5ce0c7c88b0b8a1ac0723c5c363e878adc35a","modified":1600590635472},{"_id":"public/2020/05/07/《程序员修炼之道》/index.html","hash":"14e3f72b76fe5c978e6c46de579151722799836e","modified":1600590635473},{"_id":"public/2020/05/02/vue3.0-beta尝鲜/index.html","hash":"dd82473c9fdd4b42b5e5d51fd1bdb1de66eeb7f0","modified":1600590635473},{"_id":"public/2020/04/05/致敬英雄，主流网站置灰的探索/index.html","hash":"de316c1ebb08d10b02a94751bcb48d5c7b20806f","modified":1600590635473},{"_id":"public/2020/03/22/分享一道有趣的题/index.html","hash":"230d3e9d589ba365a0529f9a04fc39091a7062e0","modified":1600590635473},{"_id":"public/2020/02/18/浅析浏览器另外三大缓存/index.html","hash":"5b97ab4b576fc8fc538cbf5c4594648562314a4a","modified":1600590635473},{"_id":"public/2020/02/13/浅析HTTP缓存/index.html","hash":"cc69e46b8879c2cf2cf48b0b688ee1610956bd03","modified":1600590635473},{"_id":"public/2020/01/20/Module/index.html","hash":"d9f4817c27e7dfc0074a951e6a66dc418014c5b0","modified":1600590635474},{"_id":"public/2020/01/13/finished-proposals-ES2020/index.html","hash":"25998cf4397e017e4c37719b339066acaf70527d","modified":1600590635474},{"_id":"public/2020/01/01/ES6----Proxy/index.html","hash":"a3e926db1585936216ecb6a0f450681822314b31","modified":1600590635474},{"_id":"public/2019/12/14/JavaScript整理总结(持续更新)/index.html","hash":"95a64df82cf17776989e0800716b4689ba1f5d0d","modified":1600590635474},{"_id":"public/2019/12/09/2020快到了，面对复盘的疾风吧！！！/index.html","hash":"901f3a51e1a4e694bef2427e73053de38f21d211","modified":1600590635474},{"_id":"public/2019/11/17/前端幸福感是如何炼成的（下）/index.html","hash":"05f4a0abf3e8f0b77fb1470ef295d90f563ed5df","modified":1600590635474},{"_id":"public/2019/11/07/风一吹不回来/index.html","hash":"af062fcdff0384c84278e52256059795ca729241","modified":1600590635474},{"_id":"public/2019/10/14/响应式原理-2.x版本（下）/index.html","hash":"821d3aecc2d2a858bd49909a27386bdb42bd0777","modified":1600590635474},{"_id":"public/2019/10/11/响应式原理-2.x版本（上）/index.html","hash":"e57bf1ef9c039904f83e9a318b92beee94fe52ce","modified":1600590635475},{"_id":"public/2019/10/07/Vue3.0它来了，带着Pre-Alpha来了/index.html","hash":"06a2aa646bf9998ae961f11049a5adfa522af523","modified":1600590635475},{"_id":"public/2019/10/04/前端幸福感是如何炼成的/index.html","hash":"68f5c4cd1e125c76d87335c65b096b1bdd408883","modified":1600590635475},{"_id":"public/2019/09/24/回归初心，重新出发/index.html","hash":"0c5584b98d8c9e85ccdd431e1a17d4936a5b3a88","modified":1600590635475},{"_id":"public/archives/index.html","hash":"acf60b73a7970a08548cd90d7c5eca2d64747d17","modified":1600590635475},{"_id":"public/archives/page/2/index.html","hash":"e2df3274cfd8dda837e5f379b0d56aea1bcef880","modified":1600590635475},{"_id":"public/archives/page/3/index.html","hash":"fc45e39f00b62c11beeaf9219403e4d5c6010663","modified":1600590635475},{"_id":"public/archives/2019/index.html","hash":"be8a7b0e5ea06facfbbed47ce05baecd2368056b","modified":1600590635476},{"_id":"public/archives/2019/09/index.html","hash":"8f30a9f53ab229ec2a03073056d3897466285435","modified":1600590635476},{"_id":"public/archives/2019/10/index.html","hash":"7e57b58687082a2fb397bf0174d8d92782b1c07a","modified":1600590635476},{"_id":"public/archives/2019/11/index.html","hash":"9bbd6fd3429ca8e55accd65363ae8dd3acde7ca1","modified":1600590635476},{"_id":"public/archives/2019/12/index.html","hash":"786b54223d89647af20fe170ca088c8d7347786f","modified":1600590635476},{"_id":"public/archives/2020/index.html","hash":"d1c809599d82a82a53b19ecc7e34bc56b1708a33","modified":1600590635476},{"_id":"public/archives/2020/page/2/index.html","hash":"2f657b18c0a480013c09f2a92316df0ebc329a9f","modified":1600590635476},{"_id":"public/archives/2020/01/index.html","hash":"4c9b55c8ba9fdedfe6d48f6c6e3e266f9c5b3312","modified":1600590635476},{"_id":"public/archives/2020/02/index.html","hash":"6f22469194af2f41235e89779a8eda3e34f546ea","modified":1600590635476},{"_id":"public/archives/2020/03/index.html","hash":"522022c69d6a841d0b49ce3647ad58146858b133","modified":1600590635477},{"_id":"public/archives/2020/04/index.html","hash":"14e19031b59fef5d1dbd999de68a5e778bbe91d8","modified":1600590635477},{"_id":"public/archives/2020/05/index.html","hash":"e6c6ce3ba5e266d1b7e58bf40873ab62d95ed474","modified":1600590635477},{"_id":"public/archives/2020/08/index.html","hash":"44ffb67e12d9408dc827ae3726706b5db93246bd","modified":1600590635477},{"_id":"public/archives/2020/09/index.html","hash":"8e61e921fd864d9ba081f534fa9d77bbaca25bbe","modified":1600590635477},{"_id":"public/categories/前端/index.html","hash":"fc2ff733b24d5aa89a06ed2ca043ceceb1a08dea","modified":1600590635477},{"_id":"public/categories/前端/page/2/index.html","hash":"abdfbce1f46333e5a2ef9b797d71e163784f4ed3","modified":1600590635477},{"_id":"public/categories/代码人生/index.html","hash":"55e0f9954ac1dfac1faa6844e1f7d6118210da62","modified":1600590635478},{"_id":"public/categories/生活/index.html","hash":"dc58a714bb1e600af85daae373cb4b7b6c347f45","modified":1600590635478},{"_id":"public/categories/书籍/index.html","hash":"f79c04f2b1b8d72c31e679d31d8e00d21a6665e8","modified":1600590635478},{"_id":"public/categories/网络/index.html","hash":"b5e1043f7f180f96f07aaf9deba5b8377643885b","modified":1600590635478},{"_id":"public/index.html","hash":"7ddcfcdf93be7ddeb42e0142d2fdc197e11efd52","modified":1600590635478},{"_id":"public/page/2/index.html","hash":"e7e63d8b4666300ff2f467cb7d3fecc0198b8d6f","modified":1600590635478},{"_id":"public/page/3/index.html","hash":"c405b8317c1fa08d8d04c370eb6ef19de90b7bd6","modified":1600590635478},{"_id":"public/tags/总结/index.html","hash":"4f5292790d5a46452bbedfc8f7bc166bfa593262","modified":1600590635478},{"_id":"public/tags/JS/index.html","hash":"6ec2839456d4c981e629a6484b62d0c0d3ac2a08","modified":1600590635479},{"_id":"public/tags/源码/index.html","hash":"bb20465564a9e2d4a245e8418a1265186ada859e","modified":1600590635479},{"_id":"public/tags/vue/index.html","hash":"fd87f2ee3b2f7a0d2710b6264f444587a79561cf","modified":1600590635479},{"_id":"public/tags/务实/index.html","hash":"e8b6db68fbe7bc7e9d2ad63ac07e55b59d9ed724","modified":1600590635479},{"_id":"public/tags/感想/index.html","hash":"226c77bae97ac33f29d8bb92b93ac06c59d2f4ee","modified":1600590635479},{"_id":"public/tags/HTTP/index.html","hash":"df899255639062f55f522dc5725c135bf6fc7656","modified":1600590635479},{"_id":"public/tags/缓存/index.html","hash":"eb9ddda3258e2f6a3857cc3263226ecd5112b413","modified":1600590635479},{"_id":"public/tags/CSS/index.html","hash":"ef541245243326a35ab81c0063cfe95048650e31","modified":1600590635479},{"_id":"public/categories/index.html","hash":"ab1d577d577f4d9533c3547efff7ac23c8b751cf","modified":1600590635480},{"_id":"public/tags/index.html","hash":"8a0be209c3a099ce8ab4b35281d5f426372736f0","modified":1600590635480},{"_id":"public/images/304.png","hash":"ba777401ed035dd68c4bb37b18c82dd1881a9a9c","modified":1600590635518},{"_id":"public/images/browser.png","hash":"305cc9455f6d47dc90a7f9bf943815da9247e838","modified":1600590635518},{"_id":"public/images/gutter-padding.png","hash":"e2e3e48a60c1b2b946eb8e4beff5b308a53540f2","modified":1600590635518},{"_id":"public/images/layout-browser.png","hash":"023114ff4781d096504a74265f9726b6af5b76de","modified":1600590635518},{"_id":"public/images/mainjs对比.png","hash":"743a64cdc2e7c62451fce712eb5b9dd4b8cb36a1","modified":1600590635518},{"_id":"public/images/powershell.png","hash":"73d4806fe5d78aab30843bf79d16fb2bd1204443","modified":1600590635519},{"_id":"public/images/ref效果图.png","hash":"995567ce907c264438c2d6ad0a15359109c97652","modified":1600590635519},{"_id":"public/images/vue-next-code-tree.png","hash":"b03f41e302bcf8f1bf306e7c1dfb946ead2d96e1","modified":1600590635519},{"_id":"public/images/vue升级3.0-beta.png","hash":"d8c838a5be056b3ac3ad9c9473f1c29fb867eda9","modified":1600590635519},{"_id":"public/images/事件效果图.png","hash":"2673b68073f2402d7424d61fb2930f7beef03826","modified":1600590635519},{"_id":"public/images/使用serviceWorker缓存.png","hash":"7a19bad05afbab72b5240914ad4a1b32dcecfb3c","modified":1600590635519},{"_id":"public/images/原型继承例子.png","hash":"6b2fcf8a4b1f1a4ce4f4bb9dc4bbac93892b7c9a","modified":1600590635519},{"_id":"public/images/注册成功.png","hash":"3bd38efe86759651c1624fb24f70a36073649123","modified":1600590635519},{"_id":"public/images/效果图-1.png","hash":"d7b0e9a6c19df0ba100fcd8c093c72891e311e4f","modified":1600590635520},{"_id":"public/images/等式成立.png","hash":"09f7b67b4fe5649153b7e728918e7d61d36ab562","modified":1600590635520},{"_id":"public/images/缓存策略.png","hash":"05d3e769e0df24231905ceb15868be72b68a0892","modified":1600590635520},{"_id":"public/images/触发toString.png","hash":"6e791f1e682589734b4037f18faf19eefa79a551","modified":1600590635520},{"_id":"public/images/缓存成功.png","hash":"540ad5c27c000751c4ae587841a2258990b345ca","modified":1600590635520},{"_id":"public/images/转换规则.png","hash":"b47e5f4cd3e6da5b19031dfb62d0abfb3ec81278","modified":1600590635520},{"_id":"public/images/钩子效果图.png","hash":"6e06efeba97acb75a57a97dffe3df653c48714b2","modified":1600590635520},{"_id":"public/images/高斯模糊.png","hash":"ebb4946f72669d63e1f79b9ce3f41856cf40080a","modified":1600590635520},{"_id":"public/images/avatar.jpg","hash":"661b052169bff3a2de0aed6a3d57ef7c4a658d4e","modified":1600590635520},{"_id":"public/images/favicon.ico","hash":"b3679fe90142172ec94bfab8c5919d5c5204091b","modified":1600590635521},{"_id":"public/images/favicon.svg","hash":"50322629b1947588ff7a6e59fb07cb1b5bfb9f8c","modified":1600590635521},{"_id":"public/images/logo-3.png","hash":"5c8b139bcf2ff2df8f5a2232129ca861822d5b52","modified":1600590635521},{"_id":"public/images/logo.svg","hash":"f4a9aa50f9a732981ae79e3711a997fc7325a7db","modified":1600590635521},{"_id":"public/images/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1600590635521},{"_id":"public/images/thumbnail.svg","hash":"38801ce6b2f60c660e1b8868da902c9ab553c82f","modified":1600590635521},{"_id":"public/images/有趣的题.jpg","hash":"7aa23adb569bd4f3de11bae41b17099bc3bd8467","modified":1600590635521},{"_id":"public/images/3and4.jpg","hash":"cec4704f310f9a0e1ed8ce984a1f9cdfe033f86e","modified":1600590635537},{"_id":"public/images/red4route.jpg","hash":"52ce87dcdb3cc16cddd46c37c132ce6e5a057318","modified":1600590635537},{"_id":"public/images/sina_yyx.jpg","hash":"df288025c5f3dfc8636bda42e352ad22ea78dca9","modified":1600590635538},{"_id":"public/images/tllearnroute.jpg","hash":"8e6a7c452c42cb537a0f91cccf3dd62fd0d9698f","modified":1600590635539},{"_id":"public/images/book.jpg","hash":"a51645d91def72649bce951d679353424744b7e8","modified":1600590635539},{"_id":"public/images/avatar01.jpg","hash":"b052bff60044042b057187b34b21d47d89459c09","modified":1600590635539},{"_id":"public/images/avatar1.jpg","hash":"496acc6b9f27a0f6d16b3192c44a27a6a287170b","modified":1600590635540},{"_id":"public/images/avatar2.jpg","hash":"34bbf9766231777978955e41a61ced082e64407b","modified":1600590635540},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1600590635941},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1600590635942},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1600590635942},{"_id":"public/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1600590635942},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1600590635942},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1600590635942},{"_id":"public/js/gallery.js","hash":"bb74e694457dc23b83ac80cf5aadcd26b60469fd","modified":1600590635942},{"_id":"public/js/main.js","hash":"faee41896e7bb3373ba5032b82d0b21a0321cea5","modified":1600590635942},{"_id":"public/images/致敬英雄iqiyi.png","hash":"0abc4cc7df291f55d3849f824243de4a28371314","modified":1600590635942},{"_id":"public/css/style.css","hash":"6f904182ac1242145ecb78bc367487377906661b","modified":1600590635952},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1600590635952},{"_id":"public/images/致敬英雄bilibili.png","hash":"6de179027db1a51a2551c7385f3c5e3b139de24c","modified":1600590635959}],"Category":[{"name":"前端","_id":"ckfauc4kg0003hsuhk457ze6b"},{"name":"代码人生","_id":"ckfauc4lb000lhsuhn1uvrnqv"},{"name":"生活","_id":"ckfauc4lu0017hsuhn35594ui"},{"name":"书籍","_id":"ckfauc4m5001fhsuhgad8vadx"},{"name":"网络","_id":"ckfauc4mf001uhsuh7gelsrex"}],"Data":[],"Page":[{"title":"关于我","date":"2019-09-27T06:00:00.000Z","_content":"\n95年的骚年一枚，地地道道的超爱喝茶的潮汕小伙子，一天能喝三四泡茶，特喜欢家乡的凤凰茶！那种独属家乡的味道，让在外打拼的我，一杯就能融进生活，趟进心里~\n\n有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门。\n\n喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前安静，用Eason的歌词来形容，大概就是外向的孤独患者？\n\n最后最后，除了coding，还喜欢练钢笔字和听歌，甚至喜欢边听边抄歌词，哈哈哈~","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2019-09-27 14:00:00\n---\n\n95年的骚年一枚，地地道道的超爱喝茶的潮汕小伙子，一天能喝三四泡茶，特喜欢家乡的凤凰茶！那种独属家乡的味道，让在外打拼的我，一杯就能融进生活，趟进心里~\n\n有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门。\n\n喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前安静，用Eason的歌词来形容，大概就是外向的孤独患者？\n\n最后最后，除了coding，还喜欢练钢笔字和听歌，甚至喜欢边听边抄歌词，哈哈哈~","updated":"2020-08-09T15:02:18.973Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckfauc4kc0001hsuh0xknvwj5","content":"<p>95年的骚年一枚，地地道道的超爱喝茶的潮汕小伙子，一天能喝三四泡茶，特喜欢家乡的凤凰茶！那种独属家乡的味道，让在外打拼的我，一杯就能融进生活，趟进心里~</p>\n<p>有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门。</p>\n<p>喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前安静，用Eason的歌词来形容，大概就是外向的孤独患者？</p>\n<p>最后最后，除了coding，还喜欢练钢笔字和听歌，甚至喜欢边听边抄歌词，哈哈哈~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>95年的骚年一枚，地地道道的超爱喝茶的潮汕小伙子，一天能喝三四泡茶，特喜欢家乡的凤凰茶！那种独属家乡的味道，让在外打拼的我，一杯就能融进生活，趟进心里~</p>\n<p>有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门。</p>\n<p>喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前安静，用Eason的歌词来形容，大概就是外向的孤独患者？</p>\n<p>最后最后，除了coding，还喜欢练钢笔字和听歌，甚至喜欢边听边抄歌词，哈哈哈~</p>\n"}],"Post":[{"title":"2020快到了，面对复盘的疾风吧！！！","_content":"\n还有20来天就是2020年了，今年的你技术有提升吗？体重下降了多少？19年末的你是不是19年初想象中的你呢？\n\n对于我来说，“每逢佳节倍思亲，每到年底必操心”，最近本来想趁着年底，做一波基础技术复盘，优先选了js进行复盘，结果越复知识点越多，想整理成一篇博文篇幅又太长，想整成什么js知识点复盘上中下又太繁琐麻烦的样子，太难了，难于上青天啊~\n\n但是青天可以不上，复盘清单还是要列的，做一些知识点的复盘总结，计划尽量月底完成（maybe吧，哈哈哈~）\n\n<!-- more -->\n\n第一个要复盘的，肯定是前端三剑客了\n\n1. HTML\n2. CSS\n3. JavaScript\n\n接下来就是工作中的技术栈和部分学习内容了\n\n1. Vue（双向绑定、响应式原理、组件设计、组件通信等）\n2. Vuex+Vue-Router等Vue全家桶\n3. 微信小程序\n4. 计算机网络（TCP、HTTP、HTTP2、HTTP3等）\n5. 数据结构（这一块处于学习阶段，列出来鞭策自己）\n6. NodeJS（这一块处于学习阶段，列出来鞭策自己）\n\nOMG，果然是“每到年底必操心”，大脑随便飘过的东西就已经这么多了，还有部分没有整理出来的比如`webpack`、`typescript`、web安全、性能优化等等，这也反映出，现在的weber需要掌握的知识点多、知识面广，并且广且深也是一个要求趋势了~\n\n最后，暂且就给自己定这样的复盘小目标吧！后面能想到啥重要的，再补充~\n\n\n\n","source":"_posts/2020快到了，面对复盘的疾风吧！！！.md","raw":"---\n\ntitle: 2020快到了，面对复盘的疾风吧！！！\ncategories:\n - 前端\ntags:\n - 总结\n---\n\n还有20来天就是2020年了，今年的你技术有提升吗？体重下降了多少？19年末的你是不是19年初想象中的你呢？\n\n对于我来说，“每逢佳节倍思亲，每到年底必操心”，最近本来想趁着年底，做一波基础技术复盘，优先选了js进行复盘，结果越复知识点越多，想整理成一篇博文篇幅又太长，想整成什么js知识点复盘上中下又太繁琐麻烦的样子，太难了，难于上青天啊~\n\n但是青天可以不上，复盘清单还是要列的，做一些知识点的复盘总结，计划尽量月底完成（maybe吧，哈哈哈~）\n\n<!-- more -->\n\n第一个要复盘的，肯定是前端三剑客了\n\n1. HTML\n2. CSS\n3. JavaScript\n\n接下来就是工作中的技术栈和部分学习内容了\n\n1. Vue（双向绑定、响应式原理、组件设计、组件通信等）\n2. Vuex+Vue-Router等Vue全家桶\n3. 微信小程序\n4. 计算机网络（TCP、HTTP、HTTP2、HTTP3等）\n5. 数据结构（这一块处于学习阶段，列出来鞭策自己）\n6. NodeJS（这一块处于学习阶段，列出来鞭策自己）\n\nOMG，果然是“每到年底必操心”，大脑随便飘过的东西就已经这么多了，还有部分没有整理出来的比如`webpack`、`typescript`、web安全、性能优化等等，这也反映出，现在的weber需要掌握的知识点多、知识面广，并且广且深也是一个要求趋势了~\n\n最后，暂且就给自己定这样的复盘小目标吧！后面能想到啥重要的，再补充~\n\n\n\n","slug":"2020快到了，面对复盘的疾风吧！！！","published":1,"date":"2019-12-09T13:58:09.231Z","updated":"2020-01-21T03:24:55.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4k40000hsuhffloxs3k","content":"<p>还有20来天就是2020年了，今年的你技术有提升吗？体重下降了多少？19年末的你是不是19年初想象中的你呢？</p>\n<p>对于我来说，“每逢佳节倍思亲，每到年底必操心”，最近本来想趁着年底，做一波基础技术复盘，优先选了js进行复盘，结果越复知识点越多，想整理成一篇博文篇幅又太长，想整成什么js知识点复盘上中下又太繁琐麻烦的样子，太难了，难于上青天啊~</p>\n<p>但是青天可以不上，复盘清单还是要列的，做一些知识点的复盘总结，计划尽量月底完成（maybe吧，哈哈哈~）</p>\n<a id=\"more\"></a>\n\n<p>第一个要复盘的，肯定是前端三剑客了</p>\n<ol>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript</li>\n</ol>\n<p>接下来就是工作中的技术栈和部分学习内容了</p>\n<ol>\n<li>Vue（双向绑定、响应式原理、组件设计、组件通信等）</li>\n<li>Vuex+Vue-Router等Vue全家桶</li>\n<li>微信小程序</li>\n<li>计算机网络（TCP、HTTP、HTTP2、HTTP3等）</li>\n<li>数据结构（这一块处于学习阶段，列出来鞭策自己）</li>\n<li>NodeJS（这一块处于学习阶段，列出来鞭策自己）</li>\n</ol>\n<p>OMG，果然是“每到年底必操心”，大脑随便飘过的东西就已经这么多了，还有部分没有整理出来的比如<code>webpack</code>、<code>typescript</code>、web安全、性能优化等等，这也反映出，现在的weber需要掌握的知识点多、知识面广，并且广且深也是一个要求趋势了~</p>\n<p>最后，暂且就给自己定这样的复盘小目标吧！后面能想到啥重要的，再补充~</p>\n","site":{"data":{}},"excerpt":"<p>还有20来天就是2020年了，今年的你技术有提升吗？体重下降了多少？19年末的你是不是19年初想象中的你呢？</p>\n<p>对于我来说，“每逢佳节倍思亲，每到年底必操心”，最近本来想趁着年底，做一波基础技术复盘，优先选了js进行复盘，结果越复知识点越多，想整理成一篇博文篇幅又太长，想整成什么js知识点复盘上中下又太繁琐麻烦的样子，太难了，难于上青天啊~</p>\n<p>但是青天可以不上，复盘清单还是要列的，做一些知识点的复盘总结，计划尽量月底完成（maybe吧，哈哈哈~）</p>","more":"<p>第一个要复盘的，肯定是前端三剑客了</p>\n<ol>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript</li>\n</ol>\n<p>接下来就是工作中的技术栈和部分学习内容了</p>\n<ol>\n<li>Vue（双向绑定、响应式原理、组件设计、组件通信等）</li>\n<li>Vuex+Vue-Router等Vue全家桶</li>\n<li>微信小程序</li>\n<li>计算机网络（TCP、HTTP、HTTP2、HTTP3等）</li>\n<li>数据结构（这一块处于学习阶段，列出来鞭策自己）</li>\n<li>NodeJS（这一块处于学习阶段，列出来鞭策自己）</li>\n</ol>\n<p>OMG，果然是“每到年底必操心”，大脑随便飘过的东西就已经这么多了，还有部分没有整理出来的比如<code>webpack</code>、<code>typescript</code>、web安全、性能优化等等，这也反映出，现在的weber需要掌握的知识点多、知识面广，并且广且深也是一个要求趋势了~</p>\n<p>最后，暂且就给自己定这样的复盘小目标吧！后面能想到啥重要的，再补充~</p>"},{"title":"JavaScript整理总结(持续更新)","_content":"\n### 数据类型、存储方式\n\n- 原始（基本）类型，变量存储的是在栈内存的值`string`、`number`、`boolean`、`undefined`、`null`、`symbol`、（以及提案新增的`BigInt`）\n\n- 引用（复杂）类型，变量存储的是在栈内存中的指针（地址），指向存储的地址，地址所在的堆内存存放着值。引用类型都是`object`\n\n### typeof和instanceof\n\n<!-- more -->\n\n#### typeof\n\n- 原始类型：除了`null`判断为`object`，其它的原始类型可以正确判断\n\n- 对象类型：除了函数判断为`function`，其它的对象类型都为`object`\n\n#### instanceof\n\n判断操作符右边的函数的原型是否存在于左边的对象的原型链上可以准确判断引用类型，无法正确判断原始类型\n\n### 正确判断变量类型的方式\n\n1. `Object.prototype.toString.apply(target)` // `'[object xxx]'`获取索引的第八位到最后一位\n\n2. 先通过`typeof`判断是否为复杂类型，是则使用`instanceof`判断\n\n   ```javascript\n   data && (typeof(data) === 'object' || typeof(data) === 'function')\n   \n   class PrimitiveUndefined {\n      static [Symbol.hasInstance](data) {\n          return typeof data === 'undefined';\n      }\n   }\n   \n   data instanceof PrimitiveUndefined\n   // 其它基本类型...\n   ```\n\n### ==、===\n\n- `==`符号只判断两个变量的值是否相等，`===`判断两个变量的类型和值\n- `==`判断过程中，若两变量的类型不同，则会涉及到变量类型转换\n\n### 类型转换\n\n在JS中，类型转换只有三种情况\n\n1. 转换为布尔值\n\n2. 转换为数字\n\n3. 转换为字符串\n\n下面图为转换规则\n\n![转换规则](/images/转换规则.png)\n\n### var、let、const\n\n- `var`声明的变量会被提升到作用域顶部，声明了全局变量则会挂载在window上面\n\n- `let`跟`const`声明的变量存在暂时性死区，因此在变量声明前调用会报错\n- `const`声明的变量是常量，为基础类型时值不能改变，复杂类型时地址不能改变\n\n### 变量提升\n\n1. 变量还没有被声明，但是可以被使用（值为`undefined`），提升的是声明（`var`声明）\n\n2. 函数也会被提升到作用域顶部，因此函数可以在声明之前调用，且函数提升优先于变量提升\n\n### this指向\n\n1. 指向全局对象window\n\n2. 指向调用方法的对象\n\n3. 指向new操作符赋值后的对象\n\n4. 箭头函数没有this，也无法使用bind，this指向包裹该箭头函数的第一个普通函数\n\n5. 函数绑定多层bind的情况，由第一个bind决定\n\n   ```javascript\n   fn.bind().bind(a)()\n   ```\n\n6. 多个规则下this指向优先级：`new` > `bind` > `obj.fn` > `fn`\n\n### apply、call、bind\n\n#### apply\n\n#### call\n\n#### bind\n\n### 闭包\n\n#### 闭包是什么\n\n> 闭包是函数和声明该函数的词法环境的组合 --MDN\n\n我的理解是，函数+该函数体可以访问的变量总和；函数不一定是在另一个函数里面声明，它也可以在外部声明，在另一个函数内部重新赋值\n\n#### 闭包的作用\n\n闭包的最多用途还是在于隐藏变量，常用于实现私有变量\n\n### 深、浅拷贝\n\n> 深、浅拷贝的区别就是拷贝的值存在引用类型时，浅拷贝会把地址复制，而深拷贝不会\n\n#### 浅拷贝\n\n##### `Object.assign()`\n\n#####  `...`扩展运算符\n\n#### 深拷贝\n\n##### `JSON.parse(JSON.stringify(obj))`\n\n局限性：\n\n1. 不能序列化undefined、函数和symbol，会忽略\n\n2. 存在对象循环引用时，会报错\n\n##### `MessageChannel`\n\n当有内置类型，且不包含函数时使用\n\n```javascript\nfunction MesCalDeepClone (obj) {\n    return new Promise((resolve) => {\n      let {port1, port2} = new MessageChannel()\n      port2.onmessage = (ev) => resolve(ev.data)\n      port1.postMessage(obj)\n    })\n}\n```\n\n### 原型\n\n原型`__proto__`是一个对象，里面预设了一些函数和属性，包括了构造函数`constructor`；而构造函数拥有`prototype`属性，指回了原型对象，通过构造函数生成的实例对象，会自动将构造函数的原型设置为实例对象的原型。\n\n### 原型链\n\n对象拥有原型对象，而原型对象也会拥有自己的原型，依次类推形成一条原型链，直到原型对象为`null`时结束即`Object.prototype.__proto__`\n\n### 继承\n\n> 在新的对象上复用现有对象的属性和方法，有助于避免重复代码和重复数据。\n\n#### 原型继承\n\n将函数A的原型赋值为函数B的实例，函数B的实例具有函数的全部属性以及指向超类的原型，以此实现原型继承。\n\n这里借用《js忍者秘籍》第二版里面的一个例子\n\n```javascript\nfunction Person () {}\nPerson.prototype.dance = function () {}\nfunction Ninja () {}\n// Ninja的原型赋值为Person的实例\nNinja.prototype = new Person()\n```\n\n![img](/images/原型继承例子.png)\n\n这里有一个要注意的地方，当把`Ninja`的原型设置为`Person`的实例对象之后，`Ninja`和它原来的原型失去了联系，现有的原型的构造函数`constructor`也是指向`Person`而不是指向`Ninja`，所以需要做一步操作，重新建立起Ninja实例与Ninja的联系\n\n```javascript\nObject.definedProperty(Ninja.prototype, 'constructor', {\n  enumerable: false, // 不可枚举\n  value: Ninja, // 值为Ninja\n  writable: true\n})\n```\n\n#### class\n\nclass的出现是为了解决什么问题？为了让其它面向对象语言开发者适应和熟悉，ES6增加了关键字class来模拟类，class是语法糖，它的底层实现原理还是**原型继承**，使用`extends`也可以更优雅地继承\n\n### new操作符的过程\n\n1. 创建一个空对象\n2. 将该空对象作为上下文`this`传入构造函数\n3. 对该对象进行一系列初始化\n4. 返回该对象或函数指定的其它对象（非对象会忽略）\n\n### 事件循环\n\n事件循环中包含着几个比较重要的概念：\n\n任务：宏任务、微任务\n\n事件队列：宏任务队列、微任务队列\n\n### 用setTimeout延迟执行事件、setInterval间隔执行事件\n\n1. `setTimeout`：延迟设定的时间执行，实际延迟时间大于等于设定的时间\n2. `setInterval`：间隔设定的时间执行，实际执行次数并不等于时间内间隔时间次数；当宏任务队列里面已经存在等待执行的该间隔任务，则不会再将该间隔任务添加进宏任务队列\n\n### 事件捕获、冒泡\n\n1. **捕获**：事件自顶向下传递，从顶部元素到目标元素\n2. **冒泡**：事件自底向上传递，从目标元素到顶部元素若没指定捕获模式，则事件默认为冒泡模式 \n\n### 事件处理器中的this和event.target的区别\n\n1. `this`指向注册事件处理器的元素\n2. `event.target`指向事件发生的元素\n\n### 自定义事件\n\n通过内置的`CustomEvent`构造函数和`dispatchEvent`方法实现自定义事件的**创建**和**分发**；\n\n自定义事件的优势是**代码解耦**，可以编写共享代码，且更易于维护、调试\n\n```html\n<script>\n  /*\n  * @params\n  * target绑定事件的对象名称 eventName事件名称 eventDetail事件参数\n  */\n  function triggerEvent (target, eventName, eventDetail) {\n    let event = new CustomEvent(eventName, {\n      detail: eventDetail\n    })\n    // 向指定元素派发事件\n    target.dispatchEvent(event)\n  }\n  // 给document绑定myEvent事件\n  triggerEvent(document, 'myEvent', {customName: 'my-event'})\n</script>\n```\n\n\n\n\n\n","source":"_posts/JavaScript整理总结(持续更新).md","raw":"---\n\ntitle: JavaScript整理总结(持续更新)\ncategories:\n - 前端\ntags:\n - 总结\n---\n\n### 数据类型、存储方式\n\n- 原始（基本）类型，变量存储的是在栈内存的值`string`、`number`、`boolean`、`undefined`、`null`、`symbol`、（以及提案新增的`BigInt`）\n\n- 引用（复杂）类型，变量存储的是在栈内存中的指针（地址），指向存储的地址，地址所在的堆内存存放着值。引用类型都是`object`\n\n### typeof和instanceof\n\n<!-- more -->\n\n#### typeof\n\n- 原始类型：除了`null`判断为`object`，其它的原始类型可以正确判断\n\n- 对象类型：除了函数判断为`function`，其它的对象类型都为`object`\n\n#### instanceof\n\n判断操作符右边的函数的原型是否存在于左边的对象的原型链上可以准确判断引用类型，无法正确判断原始类型\n\n### 正确判断变量类型的方式\n\n1. `Object.prototype.toString.apply(target)` // `'[object xxx]'`获取索引的第八位到最后一位\n\n2. 先通过`typeof`判断是否为复杂类型，是则使用`instanceof`判断\n\n   ```javascript\n   data && (typeof(data) === 'object' || typeof(data) === 'function')\n   \n   class PrimitiveUndefined {\n      static [Symbol.hasInstance](data) {\n          return typeof data === 'undefined';\n      }\n   }\n   \n   data instanceof PrimitiveUndefined\n   // 其它基本类型...\n   ```\n\n### ==、===\n\n- `==`符号只判断两个变量的值是否相等，`===`判断两个变量的类型和值\n- `==`判断过程中，若两变量的类型不同，则会涉及到变量类型转换\n\n### 类型转换\n\n在JS中，类型转换只有三种情况\n\n1. 转换为布尔值\n\n2. 转换为数字\n\n3. 转换为字符串\n\n下面图为转换规则\n\n![转换规则](/images/转换规则.png)\n\n### var、let、const\n\n- `var`声明的变量会被提升到作用域顶部，声明了全局变量则会挂载在window上面\n\n- `let`跟`const`声明的变量存在暂时性死区，因此在变量声明前调用会报错\n- `const`声明的变量是常量，为基础类型时值不能改变，复杂类型时地址不能改变\n\n### 变量提升\n\n1. 变量还没有被声明，但是可以被使用（值为`undefined`），提升的是声明（`var`声明）\n\n2. 函数也会被提升到作用域顶部，因此函数可以在声明之前调用，且函数提升优先于变量提升\n\n### this指向\n\n1. 指向全局对象window\n\n2. 指向调用方法的对象\n\n3. 指向new操作符赋值后的对象\n\n4. 箭头函数没有this，也无法使用bind，this指向包裹该箭头函数的第一个普通函数\n\n5. 函数绑定多层bind的情况，由第一个bind决定\n\n   ```javascript\n   fn.bind().bind(a)()\n   ```\n\n6. 多个规则下this指向优先级：`new` > `bind` > `obj.fn` > `fn`\n\n### apply、call、bind\n\n#### apply\n\n#### call\n\n#### bind\n\n### 闭包\n\n#### 闭包是什么\n\n> 闭包是函数和声明该函数的词法环境的组合 --MDN\n\n我的理解是，函数+该函数体可以访问的变量总和；函数不一定是在另一个函数里面声明，它也可以在外部声明，在另一个函数内部重新赋值\n\n#### 闭包的作用\n\n闭包的最多用途还是在于隐藏变量，常用于实现私有变量\n\n### 深、浅拷贝\n\n> 深、浅拷贝的区别就是拷贝的值存在引用类型时，浅拷贝会把地址复制，而深拷贝不会\n\n#### 浅拷贝\n\n##### `Object.assign()`\n\n#####  `...`扩展运算符\n\n#### 深拷贝\n\n##### `JSON.parse(JSON.stringify(obj))`\n\n局限性：\n\n1. 不能序列化undefined、函数和symbol，会忽略\n\n2. 存在对象循环引用时，会报错\n\n##### `MessageChannel`\n\n当有内置类型，且不包含函数时使用\n\n```javascript\nfunction MesCalDeepClone (obj) {\n    return new Promise((resolve) => {\n      let {port1, port2} = new MessageChannel()\n      port2.onmessage = (ev) => resolve(ev.data)\n      port1.postMessage(obj)\n    })\n}\n```\n\n### 原型\n\n原型`__proto__`是一个对象，里面预设了一些函数和属性，包括了构造函数`constructor`；而构造函数拥有`prototype`属性，指回了原型对象，通过构造函数生成的实例对象，会自动将构造函数的原型设置为实例对象的原型。\n\n### 原型链\n\n对象拥有原型对象，而原型对象也会拥有自己的原型，依次类推形成一条原型链，直到原型对象为`null`时结束即`Object.prototype.__proto__`\n\n### 继承\n\n> 在新的对象上复用现有对象的属性和方法，有助于避免重复代码和重复数据。\n\n#### 原型继承\n\n将函数A的原型赋值为函数B的实例，函数B的实例具有函数的全部属性以及指向超类的原型，以此实现原型继承。\n\n这里借用《js忍者秘籍》第二版里面的一个例子\n\n```javascript\nfunction Person () {}\nPerson.prototype.dance = function () {}\nfunction Ninja () {}\n// Ninja的原型赋值为Person的实例\nNinja.prototype = new Person()\n```\n\n![img](/images/原型继承例子.png)\n\n这里有一个要注意的地方，当把`Ninja`的原型设置为`Person`的实例对象之后，`Ninja`和它原来的原型失去了联系，现有的原型的构造函数`constructor`也是指向`Person`而不是指向`Ninja`，所以需要做一步操作，重新建立起Ninja实例与Ninja的联系\n\n```javascript\nObject.definedProperty(Ninja.prototype, 'constructor', {\n  enumerable: false, // 不可枚举\n  value: Ninja, // 值为Ninja\n  writable: true\n})\n```\n\n#### class\n\nclass的出现是为了解决什么问题？为了让其它面向对象语言开发者适应和熟悉，ES6增加了关键字class来模拟类，class是语法糖，它的底层实现原理还是**原型继承**，使用`extends`也可以更优雅地继承\n\n### new操作符的过程\n\n1. 创建一个空对象\n2. 将该空对象作为上下文`this`传入构造函数\n3. 对该对象进行一系列初始化\n4. 返回该对象或函数指定的其它对象（非对象会忽略）\n\n### 事件循环\n\n事件循环中包含着几个比较重要的概念：\n\n任务：宏任务、微任务\n\n事件队列：宏任务队列、微任务队列\n\n### 用setTimeout延迟执行事件、setInterval间隔执行事件\n\n1. `setTimeout`：延迟设定的时间执行，实际延迟时间大于等于设定的时间\n2. `setInterval`：间隔设定的时间执行，实际执行次数并不等于时间内间隔时间次数；当宏任务队列里面已经存在等待执行的该间隔任务，则不会再将该间隔任务添加进宏任务队列\n\n### 事件捕获、冒泡\n\n1. **捕获**：事件自顶向下传递，从顶部元素到目标元素\n2. **冒泡**：事件自底向上传递，从目标元素到顶部元素若没指定捕获模式，则事件默认为冒泡模式 \n\n### 事件处理器中的this和event.target的区别\n\n1. `this`指向注册事件处理器的元素\n2. `event.target`指向事件发生的元素\n\n### 自定义事件\n\n通过内置的`CustomEvent`构造函数和`dispatchEvent`方法实现自定义事件的**创建**和**分发**；\n\n自定义事件的优势是**代码解耦**，可以编写共享代码，且更易于维护、调试\n\n```html\n<script>\n  /*\n  * @params\n  * target绑定事件的对象名称 eventName事件名称 eventDetail事件参数\n  */\n  function triggerEvent (target, eventName, eventDetail) {\n    let event = new CustomEvent(eventName, {\n      detail: eventDetail\n    })\n    // 向指定元素派发事件\n    target.dispatchEvent(event)\n  }\n  // 给document绑定myEvent事件\n  triggerEvent(document, 'myEvent', {customName: 'my-event'})\n</script>\n```\n\n\n\n\n\n","slug":"JavaScript整理总结(持续更新)","published":1,"date":"2019-12-14T15:15:30.858Z","updated":"2020-02-25T23:59:21.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4kd0002hsuhfhc5g12a","content":"<h3 id=\"数据类型、存储方式\"><a href=\"#数据类型、存储方式\" class=\"headerlink\" title=\"数据类型、存储方式\"></a>数据类型、存储方式</h3><ul>\n<li><p>原始（基本）类型，变量存储的是在栈内存的值<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>、（以及提案新增的<code>BigInt</code>）</p>\n</li>\n<li><p>引用（复杂）类型，变量存储的是在栈内存中的指针（地址），指向存储的地址，地址所在的堆内存存放着值。引用类型都是<code>object</code></p>\n</li>\n</ul>\n<h3 id=\"typeof和instanceof\"><a href=\"#typeof和instanceof\" class=\"headerlink\" title=\"typeof和instanceof\"></a>typeof和instanceof</h3><a id=\"more\"></a>\n\n<h4 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h4><ul>\n<li><p>原始类型：除了<code>null</code>判断为<code>object</code>，其它的原始类型可以正确判断</p>\n</li>\n<li><p>对象类型：除了函数判断为<code>function</code>，其它的对象类型都为<code>object</code></p>\n</li>\n</ul>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><p>判断操作符右边的函数的原型是否存在于左边的对象的原型链上可以准确判断引用类型，无法正确判断原始类型</p>\n<h3 id=\"正确判断变量类型的方式\"><a href=\"#正确判断变量类型的方式\" class=\"headerlink\" title=\"正确判断变量类型的方式\"></a>正确判断变量类型的方式</h3><ol>\n<li><p><code>Object.prototype.toString.apply(target)</code> // <code>&#39;[object xxx]&#39;</code>获取索引的第八位到最后一位</p>\n</li>\n<li><p>先通过<code>typeof</code>判断是否为复杂类型，是则使用<code>instanceof</code>判断</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data &amp;&amp; (<span class=\"hljs-keyword\">typeof</span>(data) === <span class=\"hljs-string\">'object'</span> || <span class=\"hljs-keyword\">typeof</span>(data) === <span class=\"hljs-string\">'function'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrimitiveUndefined</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"hljs-keyword\">static</span> [<span class=\"hljs-built_in\">Symbol</span>.hasInstance](data) &#123;</span><br><span class=\"line\">       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> data === <span class=\"hljs-string\">'undefined'</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data <span class=\"hljs-keyword\">instanceof</span> PrimitiveUndefined</span><br><span class=\"line\"><span class=\"hljs-comment\">// 其它基本类型...</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"、\"><a href=\"#、\" class=\"headerlink\" title=\"==、===\"></a>==、===</h3><ul>\n<li><code>==</code>符号只判断两个变量的值是否相等，<code>===</code>判断两个变量的类型和值</li>\n<li><code>==</code>判断过程中，若两变量的类型不同，则会涉及到变量类型转换</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>在JS中，类型转换只有三种情况</p>\n<ol>\n<li><p>转换为布尔值</p>\n</li>\n<li><p>转换为数字</p>\n</li>\n<li><p>转换为字符串</p>\n</li>\n</ol>\n<p>下面图为转换规则</p>\n<p><img src=\"/images/%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99.png\" alt=\"转换规则\"></p>\n<h3 id=\"var、let、const\"><a href=\"#var、let、const\" class=\"headerlink\" title=\"var、let、const\"></a>var、let、const</h3><ul>\n<li><p><code>var</code>声明的变量会被提升到作用域顶部，声明了全局变量则会挂载在window上面</p>\n</li>\n<li><p><code>let</code>跟<code>const</code>声明的变量存在暂时性死区，因此在变量声明前调用会报错</p>\n</li>\n<li><p><code>const</code>声明的变量是常量，为基础类型时值不能改变，复杂类型时地址不能改变</p>\n</li>\n</ul>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><ol>\n<li><p>变量还没有被声明，但是可以被使用（值为<code>undefined</code>），提升的是声明（<code>var</code>声明）</p>\n</li>\n<li><p>函数也会被提升到作用域顶部，因此函数可以在声明之前调用，且函数提升优先于变量提升</p>\n</li>\n</ol>\n<h3 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h3><ol>\n<li><p>指向全局对象window</p>\n</li>\n<li><p>指向调用方法的对象</p>\n</li>\n<li><p>指向new操作符赋值后的对象</p>\n</li>\n<li><p>箭头函数没有this，也无法使用bind，this指向包裹该箭头函数的第一个普通函数</p>\n</li>\n<li><p>函数绑定多层bind的情况，由第一个bind决定</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.bind().bind(a)()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多个规则下this指向优先级：<code>new</code> &gt; <code>bind</code> &gt; <code>obj.fn</code> &gt; <code>fn</code></p>\n</li>\n</ol>\n<h3 id=\"apply、call、bind\"><a href=\"#apply、call、bind\" class=\"headerlink\" title=\"apply、call、bind\"></a>apply、call、bind</h3><h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h4><h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h4><h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><h4 id=\"闭包是什么\"><a href=\"#闭包是什么\" class=\"headerlink\" title=\"闭包是什么\"></a>闭包是什么</h4><blockquote>\n<p>闭包是函数和声明该函数的词法环境的组合 –MDN</p>\n</blockquote>\n<p>我的理解是，函数+该函数体可以访问的变量总和；函数不一定是在另一个函数里面声明，它也可以在外部声明，在另一个函数内部重新赋值</p>\n<h4 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h4><p>闭包的最多用途还是在于隐藏变量，常用于实现私有变量</p>\n<h3 id=\"深、浅拷贝\"><a href=\"#深、浅拷贝\" class=\"headerlink\" title=\"深、浅拷贝\"></a>深、浅拷贝</h3><blockquote>\n<p>深、浅拷贝的区别就是拷贝的值存在引用类型时，浅拷贝会把地址复制，而深拷贝不会</p>\n</blockquote>\n<h4 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h4><h5 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a><code>Object.assign()</code></h5><h5 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"...扩展运算符\"></a><code>...</code>扩展运算符</h5><h4 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h4><h5 id=\"JSON-parse-JSON-stringify-obj\"><a href=\"#JSON-parse-JSON-stringify-obj\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify(obj))\"></a><code>JSON.parse(JSON.stringify(obj))</code></h5><p>局限性：</p>\n<ol>\n<li><p>不能序列化undefined、函数和symbol，会忽略</p>\n</li>\n<li><p>存在对象循环引用时，会报错</p>\n</li>\n</ol>\n<h5 id=\"MessageChannel\"><a href=\"#MessageChannel\" class=\"headerlink\" title=\"MessageChannel\"></a><code>MessageChannel</code></h5><p>当有内置类型，且不包含函数时使用</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MesCalDeepClone</span> (<span class=\"hljs-params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">let</span> &#123;port1, port2&#125; = <span class=\"hljs-keyword\">new</span> MessageChannel()</span><br><span class=\"line\">      port2.onmessage = <span class=\"hljs-function\">(<span class=\"hljs-params\">ev</span>) =&gt;</span> resolve(ev.data)</span><br><span class=\"line\">      port1.postMessage(obj)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>原型<code>__proto__</code>是一个对象，里面预设了一些函数和属性，包括了构造函数<code>constructor</code>；而构造函数拥有<code>prototype</code>属性，指回了原型对象，通过构造函数生成的实例对象，会自动将构造函数的原型设置为实例对象的原型。</p>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>对象拥有原型对象，而原型对象也会拥有自己的原型，依次类推形成一条原型链，直到原型对象为<code>null</code>时结束即<code>Object.prototype.__proto__</code></p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><blockquote>\n<p>在新的对象上复用现有对象的属性和方法，有助于避免重复代码和重复数据。</p>\n</blockquote>\n<h4 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h4><p>将函数A的原型赋值为函数B的实例，函数B的实例具有函数的全部属性以及指向超类的原型，以此实现原型继承。</p>\n<p>这里借用《js忍者秘籍》第二版里面的一个例子</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.dance = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Ninja</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// Ninja的原型赋值为Person的实例</span></span><br><span class=\"line\">Ninja.prototype = <span class=\"hljs-keyword\">new</span> Person()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BE%8B%E5%AD%90.png\" alt=\"img\"></p>\n<p>这里有一个要注意的地方，当把<code>Ninja</code>的原型设置为<code>Person</code>的实例对象之后，<code>Ninja</code>和它原来的原型失去了联系，现有的原型的构造函数<code>constructor</code>也是指向<code>Person</code>而不是指向<code>Ninja</code>，所以需要做一步操作，重新建立起Ninja实例与Ninja的联系</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">Object</span>.definedProperty(Ninja.prototype, <span class=\"hljs-string\">'constructor'</span>, &#123;</span><br><span class=\"line\">  enumerable: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-comment\">// 不可枚举</span></span><br><span class=\"line\">  value: Ninja, <span class=\"hljs-comment\">// 值为Ninja</span></span><br><span class=\"line\">  writable: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h4><p>class的出现是为了解决什么问题？为了让其它面向对象语言开发者适应和熟悉，ES6增加了关键字class来模拟类，class是语法糖，它的底层实现原理还是<strong>原型继承</strong>，使用<code>extends</code>也可以更优雅地继承</p>\n<h3 id=\"new操作符的过程\"><a href=\"#new操作符的过程\" class=\"headerlink\" title=\"new操作符的过程\"></a>new操作符的过程</h3><ol>\n<li>创建一个空对象</li>\n<li>将该空对象作为上下文<code>this</code>传入构造函数</li>\n<li>对该对象进行一系列初始化</li>\n<li>返回该对象或函数指定的其它对象（非对象会忽略）</li>\n</ol>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>事件循环中包含着几个比较重要的概念：</p>\n<p>任务：宏任务、微任务</p>\n<p>事件队列：宏任务队列、微任务队列</p>\n<h3 id=\"用setTimeout延迟执行事件、setInterval间隔执行事件\"><a href=\"#用setTimeout延迟执行事件、setInterval间隔执行事件\" class=\"headerlink\" title=\"用setTimeout延迟执行事件、setInterval间隔执行事件\"></a>用setTimeout延迟执行事件、setInterval间隔执行事件</h3><ol>\n<li><code>setTimeout</code>：延迟设定的时间执行，实际延迟时间大于等于设定的时间</li>\n<li><code>setInterval</code>：间隔设定的时间执行，实际执行次数并不等于时间内间隔时间次数；当宏任务队列里面已经存在等待执行的该间隔任务，则不会再将该间隔任务添加进宏任务队列</li>\n</ol>\n<h3 id=\"事件捕获、冒泡\"><a href=\"#事件捕获、冒泡\" class=\"headerlink\" title=\"事件捕获、冒泡\"></a>事件捕获、冒泡</h3><ol>\n<li><strong>捕获</strong>：事件自顶向下传递，从顶部元素到目标元素</li>\n<li><strong>冒泡</strong>：事件自底向上传递，从目标元素到顶部元素若没指定捕获模式，则事件默认为冒泡模式 </li>\n</ol>\n<h3 id=\"事件处理器中的this和event-target的区别\"><a href=\"#事件处理器中的this和event-target的区别\" class=\"headerlink\" title=\"事件处理器中的this和event.target的区别\"></a>事件处理器中的this和event.target的区别</h3><ol>\n<li><code>this</code>指向注册事件处理器的元素</li>\n<li><code>event.target</code>指向事件发生的元素</li>\n</ol>\n<h3 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h3><p>通过内置的<code>CustomEvent</code>构造函数和<code>dispatchEvent</code>方法实现自定义事件的<strong>创建</strong>和<strong>分发</strong>；</p>\n<p>自定义事件的优势是<strong>代码解耦</strong>，可以编写共享代码，且更易于维护、调试</p>\n<figure class=\"highlight html hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span></span><br><span class=\"line\">  /*</span><br><span class=\"line\">  * @params</span><br><span class=\"line\">  * target绑定事件的对象名称 eventName事件名称 eventDetail事件参数</span><br><span class=\"line\">  */</span><br><span class=\"line\"><span class=\"hljs-javascript\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">triggerEvent</span> (<span class=\"hljs-params\">target, eventName, eventDetail</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"hljs-javascript\">    <span class=\"hljs-keyword\">let</span> event = <span class=\"hljs-keyword\">new</span> CustomEvent(eventName, &#123;</span></span><br><span class=\"line\">      detail: eventDetail</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"hljs-javascript\">    <span class=\"hljs-comment\">// 向指定元素派发事件</span></span></span><br><span class=\"line\">    target.dispatchEvent(event)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"hljs-javascript\">  <span class=\"hljs-comment\">// 给document绑定myEvent事件</span></span></span><br><span class=\"line\"><span class=\"hljs-javascript\">  triggerEvent(<span class=\"hljs-built_in\">document</span>, <span class=\"hljs-string\">'myEvent'</span>, &#123;<span class=\"hljs-attr\">customName</span>: <span class=\"hljs-string\">'my-event'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"数据类型、存储方式\"><a href=\"#数据类型、存储方式\" class=\"headerlink\" title=\"数据类型、存储方式\"></a>数据类型、存储方式</h3><ul>\n<li><p>原始（基本）类型，变量存储的是在栈内存的值<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>、（以及提案新增的<code>BigInt</code>）</p>\n</li>\n<li><p>引用（复杂）类型，变量存储的是在栈内存中的指针（地址），指向存储的地址，地址所在的堆内存存放着值。引用类型都是<code>object</code></p>\n</li>\n</ul>\n<h3 id=\"typeof和instanceof\"><a href=\"#typeof和instanceof\" class=\"headerlink\" title=\"typeof和instanceof\"></a>typeof和instanceof</h3>","more":"<h4 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h4><ul>\n<li><p>原始类型：除了<code>null</code>判断为<code>object</code>，其它的原始类型可以正确判断</p>\n</li>\n<li><p>对象类型：除了函数判断为<code>function</code>，其它的对象类型都为<code>object</code></p>\n</li>\n</ul>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><p>判断操作符右边的函数的原型是否存在于左边的对象的原型链上可以准确判断引用类型，无法正确判断原始类型</p>\n<h3 id=\"正确判断变量类型的方式\"><a href=\"#正确判断变量类型的方式\" class=\"headerlink\" title=\"正确判断变量类型的方式\"></a>正确判断变量类型的方式</h3><ol>\n<li><p><code>Object.prototype.toString.apply(target)</code> // <code>&#39;[object xxx]&#39;</code>获取索引的第八位到最后一位</p>\n</li>\n<li><p>先通过<code>typeof</code>判断是否为复杂类型，是则使用<code>instanceof</code>判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data &amp;&amp; (<span class=\"keyword\">typeof</span>(data) === <span class=\"string\">'object'</span> || <span class=\"keyword\">typeof</span>(data) === <span class=\"string\">'function'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrimitiveUndefined</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">static</span> [<span class=\"built_in\">Symbol</span>.hasInstance](data) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> data === <span class=\"string\">'undefined'</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data <span class=\"keyword\">instanceof</span> PrimitiveUndefined</span><br><span class=\"line\"><span class=\"comment\">// 其它基本类型...</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"、\"><a href=\"#、\" class=\"headerlink\" title=\"==、===\"></a>==、===</h3><ul>\n<li><code>==</code>符号只判断两个变量的值是否相等，<code>===</code>判断两个变量的类型和值</li>\n<li><code>==</code>判断过程中，若两变量的类型不同，则会涉及到变量类型转换</li>\n</ul>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>在JS中，类型转换只有三种情况</p>\n<ol>\n<li><p>转换为布尔值</p>\n</li>\n<li><p>转换为数字</p>\n</li>\n<li><p>转换为字符串</p>\n</li>\n</ol>\n<p>下面图为转换规则</p>\n<p><img src=\"/images/%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99.png\" alt=\"转换规则\"></p>\n<h3 id=\"var、let、const\"><a href=\"#var、let、const\" class=\"headerlink\" title=\"var、let、const\"></a>var、let、const</h3><ul>\n<li><p><code>var</code>声明的变量会被提升到作用域顶部，声明了全局变量则会挂载在window上面</p>\n</li>\n<li><p><code>let</code>跟<code>const</code>声明的变量存在暂时性死区，因此在变量声明前调用会报错</p>\n</li>\n<li><p><code>const</code>声明的变量是常量，为基础类型时值不能改变，复杂类型时地址不能改变</p>\n</li>\n</ul>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><ol>\n<li><p>变量还没有被声明，但是可以被使用（值为<code>undefined</code>），提升的是声明（<code>var</code>声明）</p>\n</li>\n<li><p>函数也会被提升到作用域顶部，因此函数可以在声明之前调用，且函数提升优先于变量提升</p>\n</li>\n</ol>\n<h3 id=\"this指向\"><a href=\"#this指向\" class=\"headerlink\" title=\"this指向\"></a>this指向</h3><ol>\n<li><p>指向全局对象window</p>\n</li>\n<li><p>指向调用方法的对象</p>\n</li>\n<li><p>指向new操作符赋值后的对象</p>\n</li>\n<li><p>箭头函数没有this，也无法使用bind，this指向包裹该箭头函数的第一个普通函数</p>\n</li>\n<li><p>函数绑定多层bind的情况，由第一个bind决定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn.bind().bind(a)()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>多个规则下this指向优先级：<code>new</code> &gt; <code>bind</code> &gt; <code>obj.fn</code> &gt; <code>fn</code></p>\n</li>\n</ol>\n<h3 id=\"apply、call、bind\"><a href=\"#apply、call、bind\" class=\"headerlink\" title=\"apply、call、bind\"></a>apply、call、bind</h3><h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h4><h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h4><h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h4><h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><h4 id=\"闭包是什么\"><a href=\"#闭包是什么\" class=\"headerlink\" title=\"闭包是什么\"></a>闭包是什么</h4><blockquote>\n<p>闭包是函数和声明该函数的词法环境的组合 –MDN</p>\n</blockquote>\n<p>我的理解是，函数+该函数体可以访问的变量总和；函数不一定是在另一个函数里面声明，它也可以在外部声明，在另一个函数内部重新赋值</p>\n<h4 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h4><p>闭包的最多用途还是在于隐藏变量，常用于实现私有变量</p>\n<h3 id=\"深、浅拷贝\"><a href=\"#深、浅拷贝\" class=\"headerlink\" title=\"深、浅拷贝\"></a>深、浅拷贝</h3><blockquote>\n<p>深、浅拷贝的区别就是拷贝的值存在引用类型时，浅拷贝会把地址复制，而深拷贝不会</p>\n</blockquote>\n<h4 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h4><h5 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a><code>Object.assign()</code></h5><h5 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"...扩展运算符\"></a><code>...</code>扩展运算符</h5><h4 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h4><h5 id=\"JSON-parse-JSON-stringify-obj\"><a href=\"#JSON-parse-JSON-stringify-obj\" class=\"headerlink\" title=\"JSON.parse(JSON.stringify(obj))\"></a><code>JSON.parse(JSON.stringify(obj))</code></h5><p>局限性：</p>\n<ol>\n<li><p>不能序列化undefined、函数和symbol，会忽略</p>\n</li>\n<li><p>存在对象循环引用时，会报错</p>\n</li>\n</ol>\n<h5 id=\"MessageChannel\"><a href=\"#MessageChannel\" class=\"headerlink\" title=\"MessageChannel\"></a><code>MessageChannel</code></h5><p>当有内置类型，且不包含函数时使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MesCalDeepClone</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> &#123;port1, port2&#125; = <span class=\"keyword\">new</span> MessageChannel()</span><br><span class=\"line\">      port2.onmessage = <span class=\"function\">(<span class=\"params\">ev</span>) =&gt;</span> resolve(ev.data)</span><br><span class=\"line\">      port1.postMessage(obj)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>原型<code>__proto__</code>是一个对象，里面预设了一些函数和属性，包括了构造函数<code>constructor</code>；而构造函数拥有<code>prototype</code>属性，指回了原型对象，通过构造函数生成的实例对象，会自动将构造函数的原型设置为实例对象的原型。</p>\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><p>对象拥有原型对象，而原型对象也会拥有自己的原型，依次类推形成一条原型链，直到原型对象为<code>null</code>时结束即<code>Object.prototype.__proto__</code></p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><blockquote>\n<p>在新的对象上复用现有对象的属性和方法，有助于避免重复代码和重复数据。</p>\n</blockquote>\n<h4 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h4><p>将函数A的原型赋值为函数B的实例，函数B的实例具有函数的全部属性以及指向超类的原型，以此实现原型继承。</p>\n<p>这里借用《js忍者秘籍》第二版里面的一个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.dance = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Ninja</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// Ninja的原型赋值为Person的实例</span></span><br><span class=\"line\">Ninja.prototype = <span class=\"keyword\">new</span> Person()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BE%8B%E5%AD%90.png\" alt=\"img\"></p>\n<p>这里有一个要注意的地方，当把<code>Ninja</code>的原型设置为<code>Person</code>的实例对象之后，<code>Ninja</code>和它原来的原型失去了联系，现有的原型的构造函数<code>constructor</code>也是指向<code>Person</code>而不是指向<code>Ninja</code>，所以需要做一步操作，重新建立起Ninja实例与Ninja的联系</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.definedProperty(Ninja.prototype, <span class=\"string\">'constructor'</span>, &#123;</span><br><span class=\"line\">  enumerable: <span class=\"literal\">false</span>, <span class=\"comment\">// 不可枚举</span></span><br><span class=\"line\">  value: Ninja, <span class=\"comment\">// 值为Ninja</span></span><br><span class=\"line\">  writable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h4><p>class的出现是为了解决什么问题？为了让其它面向对象语言开发者适应和熟悉，ES6增加了关键字class来模拟类，class是语法糖，它的底层实现原理还是<strong>原型继承</strong>，使用<code>extends</code>也可以更优雅地继承</p>\n<h3 id=\"new操作符的过程\"><a href=\"#new操作符的过程\" class=\"headerlink\" title=\"new操作符的过程\"></a>new操作符的过程</h3><ol>\n<li>创建一个空对象</li>\n<li>将该空对象作为上下文<code>this</code>传入构造函数</li>\n<li>对该对象进行一系列初始化</li>\n<li>返回该对象或函数指定的其它对象（非对象会忽略）</li>\n</ol>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><p>事件循环中包含着几个比较重要的概念：</p>\n<p>任务：宏任务、微任务</p>\n<p>事件队列：宏任务队列、微任务队列</p>\n<h3 id=\"用setTimeout延迟执行事件、setInterval间隔执行事件\"><a href=\"#用setTimeout延迟执行事件、setInterval间隔执行事件\" class=\"headerlink\" title=\"用setTimeout延迟执行事件、setInterval间隔执行事件\"></a>用setTimeout延迟执行事件、setInterval间隔执行事件</h3><ol>\n<li><code>setTimeout</code>：延迟设定的时间执行，实际延迟时间大于等于设定的时间</li>\n<li><code>setInterval</code>：间隔设定的时间执行，实际执行次数并不等于时间内间隔时间次数；当宏任务队列里面已经存在等待执行的该间隔任务，则不会再将该间隔任务添加进宏任务队列</li>\n</ol>\n<h3 id=\"事件捕获、冒泡\"><a href=\"#事件捕获、冒泡\" class=\"headerlink\" title=\"事件捕获、冒泡\"></a>事件捕获、冒泡</h3><ol>\n<li><strong>捕获</strong>：事件自顶向下传递，从顶部元素到目标元素</li>\n<li><strong>冒泡</strong>：事件自底向上传递，从目标元素到顶部元素若没指定捕获模式，则事件默认为冒泡模式 </li>\n</ol>\n<h3 id=\"事件处理器中的this和event-target的区别\"><a href=\"#事件处理器中的this和event-target的区别\" class=\"headerlink\" title=\"事件处理器中的this和event.target的区别\"></a>事件处理器中的this和event.target的区别</h3><ol>\n<li><code>this</code>指向注册事件处理器的元素</li>\n<li><code>event.target</code>指向事件发生的元素</li>\n</ol>\n<h3 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h3><p>通过内置的<code>CustomEvent</code>构造函数和<code>dispatchEvent</code>方法实现自定义事件的<strong>创建</strong>和<strong>分发</strong>；</p>\n<p>自定义事件的优势是<strong>代码解耦</strong>，可以编写共享代码，且更易于维护、调试</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  /*</span><br><span class=\"line\">  * @params</span><br><span class=\"line\">  * target绑定事件的对象名称 eventName事件名称 eventDetail事件参数</span><br><span class=\"line\">  */</span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">triggerEvent</span> (<span class=\"params\">target, eventName, eventDetail</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> event = <span class=\"keyword\">new</span> CustomEvent(eventName, &#123;</span></span><br><span class=\"line\">      detail: eventDetail</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 向指定元素派发事件</span></span></span><br><span class=\"line\">    target.dispatchEvent(event)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// 给document绑定myEvent事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">  triggerEvent(<span class=\"built_in\">document</span>, <span class=\"string\">'myEvent'</span>, &#123;<span class=\"attr\">customName</span>: <span class=\"string\">'my-event'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"ES6 -- Module","_content":"\n### 前言\n\n讲到模块化，大家可能对CommonJs、AMD、CMD等规范都比较熟悉，ES6也有Module的规范。本文是对Module理解的整理。那依然先是问题三连：ES6的Module是什么？用来解决什么问题？优点是什么？\n\n<!-- more -->\n\n### 是什么？\n\n使用不同方式加载的JS文件，与原先脚本（script）加载方式相对。模块的真正力量在于按需导出和导入，而不在于将所有内容放在同一个文件\n\n### 解决什么问题（切入点）\n\n1. 命名冲突（作用域）\n2. 让JS应用变得更加有条理\n3. 安全问题\n\n### 优点是什么\n\n1. 自动运行在严格模式下，且无法跳出严格模式；\n2. 在模块的顶级作用域创建的变量，不会自动添加到共享的全局作用域，只存在于模块顶级作用域的内部；\n3. 模块顶级作用域的`this`为`undefined`；\n4. 模块中不允许`HTML`风格的注释，该问题是早期浏览器历史遗留特性；\n5. 要提供给外部访问的代码，模块必须导出它们；\n6. 模块可以由别的模块导入绑定。\n\n### 基本导出\n\n#### export\n\n我们可以在任意变量、函数、类声明之前加上`export`导出它们，没有被显式导出的将会在模块中保持私有\n\n```javascript\n// module.js\nexport let name = 'Ysom'\nexport function sum (num1, num2) {\n    return num1 + num2\n}\nexport class Person {\n    constrcutor (name, sex) {\n        this.name = name\n        this.sex = sex\n    }\n}\n\nfunction sayHello () {\n    console.log('hello world')\n}\n// 导出引用\nexport { sayHello }\n```\n\n### 基本导入\n\n#### import\n\n可以通过`import`来导入被导出的模块，`import`语句由两部分组成，被导入的**标识符**和导入标识符的**来源**：`import { identifier1, identifier2 } from './module1.js'`\n\n```javascript\n// 导入单个绑定\nimport { sum } from './module.js'\n// 导入多个绑定\nimport { sum, sayHello } from './module.js'\n// 完全导入一个模块 module所有的导出绑定在example 属于命名空间导入(namespace import)\nimport * as example from './module.js'\n```\n\n需要注意的一点：无论使用多少次`import`引入模块，该模块只会执行一次。在导出的模块执行之后，已被实例化的模块会保留在内存中，随时可被其它`import`使用。同应用的其它模块，如使用`import`引入该模块，使用的也是同一个实例模块\n\n```javascript\nimport { sum } from './module.js'\nimport { sayHello } from './module.js'\n// 在这里modules.js只会执行一次，之后保留在内存中\n```\n\nimport和export有一个限制：无法在其它语句或表达式的内部使用，即必须在顶部作用域\n\n```javascript\nif (true) {\n    // error\n    import xx from './xxx'\n}\nif (true) {\n    // error\n    export xx\n}\n```\n\n> 题外话：在已完成的ES2020的提案中，有了新特性动态导入[dynamic-import](https://github.com/tc39/proposal-dynamic-import)，可根据条件判断支持按需导入\n\n### 默认导入-模块的默认值\n\n我们可以通过`default`为每一个模块设置一个且只能一个默认值\n\n```javascript\n// 普通导出\nexport let name = 'export'\n// 1 默认导出可以不用给声明加上名称 因为代表整个模块导出\nexport default function (num1, num2) {}\n// 2 也可先声明 再导出\nfunction sum (num1, num2) {}\nexport default sum\n```\n\n```javascript\n// 导入模块默认值 默认值无需加上花括号{}\nimport sum from './module.js'\nsum(1, 11)\n// 导入默认值及其它导出功能 默认名称需在位于非默认名称之前\nimport sum, { name } from './module.js'\nconsole.log(name) // export\nsum(1, 11)\n// 重命名\nimport { default as sum, name } from './module.js'\n```\n\n### 绑定导入，再导出\n\n有时候我们会需要将导入的部分功能，再导出去作为另一个模块，比如作为库，这时候可以这样操作\n\n```javascript\n// new-module.js\n// 1 先导入 再导出\nimport { identifier1, identifier2 } from './m1.js'\nexport { identifier1, identifier2 }\n// 2 会进入模块查看sum, sayHello的定义，并导出\nexport { sum, sayHello } from './module.js'\n// 3 完全导出\nexport * from './module.js'\n```\n\n完全导出需要注意一个问题，如果目标模块`module`包含了默认值，那么就无法在当前模块`new-module`再定义一个默认导出，始终遵守一个模块只能有一个默认导出的原则\n\n### 无绑定的导入\n\n有时候我们会对全局作用域对象进行一些附加操作，虽然模块中的代码不会自动共享到全局，但是我们还是可以在模块中对一些JS内置对象如`Array`、`Object`等进行访问，并且对这些对象的修改，可以反映到其它模块中\n\n```javascript\n// extendArray.js\n// 给数组添加一个pushAll的方法\nArray.prototype.pushAll = function (items) {\n    // 判断items是否为数组\n    if (!Array.isArray(items)) {\n        throw TypeError(`arguments must be an array`)\n    }\n    return this.push(...items)\n}\n```\n\n再通过`import './extendArray.js' `将模块引入，这里虽然没有绑定的导出与导入，但依然是一个有效的模块，在引入该模块的模块中，所有的数组都可以使用`pushAll()`方法\n\n这种无绑定的导入，最有可能创建用于在旧环境运行新语法时做向下兼容的`polyfill`和`shim`\n\n### 加载方式\n\n> ES6定义了模块的语法，但未定义如何加载。\n\n#### 在web浏览器中使用模块\n\n在ES6之前，已经存在多种方式可以在web应用中加载JS\n\n1. 使用`<script>`标签以及`src`属性指定加载的位置，加载JS文件；\n2. 使用`<script>`标签但不使用`src`属性，嵌入内联的JS代码；\n3. 加载JS代码文件并作为`Worker`（例如`Web Worker`或`Service Worker`）来执行\n\n##### 通过script加载模块\n\n在使用script标签时，设置type属性为module，告诉浏览器将引入的代码作为模块。且会自动应用defer属性，将模块文件下载完后，等待网页文档全部解析完，再按照模块引入顺序依次执行。如果需要异步加载模块，则可以手动加上async属性\n\n##### 将模块作为Worker加载\n\n为了支持模块加载，HTML标准的开发者给worker添加了第二个参数，该参数时带有`type`属性的对象，默认值为`script`，可以设置为`module`，以此来加载模块\n\n```javascript\n// 脚本方式\nlet worker = new Worker('script.js')\n\n// 模块方式\nlet worker = new Worker('module.js')\n```\n\n模块方式其中存在两点区别：\n\n1. worker脚本被限制只能从同源网页加载，worker模块不受限制；\n2. worker脚本可以使用`self.importScripts()`方法来将额外脚本引入worker，worker模块上的`self.importScripts()`总是失败，因为应当换用成`import`","source":"_posts/Module.md","raw":"---\ntitle: ES6 -- Module\ncategories:\n - 前端\ntags:\n - JS\n\n---\n\n### 前言\n\n讲到模块化，大家可能对CommonJs、AMD、CMD等规范都比较熟悉，ES6也有Module的规范。本文是对Module理解的整理。那依然先是问题三连：ES6的Module是什么？用来解决什么问题？优点是什么？\n\n<!-- more -->\n\n### 是什么？\n\n使用不同方式加载的JS文件，与原先脚本（script）加载方式相对。模块的真正力量在于按需导出和导入，而不在于将所有内容放在同一个文件\n\n### 解决什么问题（切入点）\n\n1. 命名冲突（作用域）\n2. 让JS应用变得更加有条理\n3. 安全问题\n\n### 优点是什么\n\n1. 自动运行在严格模式下，且无法跳出严格模式；\n2. 在模块的顶级作用域创建的变量，不会自动添加到共享的全局作用域，只存在于模块顶级作用域的内部；\n3. 模块顶级作用域的`this`为`undefined`；\n4. 模块中不允许`HTML`风格的注释，该问题是早期浏览器历史遗留特性；\n5. 要提供给外部访问的代码，模块必须导出它们；\n6. 模块可以由别的模块导入绑定。\n\n### 基本导出\n\n#### export\n\n我们可以在任意变量、函数、类声明之前加上`export`导出它们，没有被显式导出的将会在模块中保持私有\n\n```javascript\n// module.js\nexport let name = 'Ysom'\nexport function sum (num1, num2) {\n    return num1 + num2\n}\nexport class Person {\n    constrcutor (name, sex) {\n        this.name = name\n        this.sex = sex\n    }\n}\n\nfunction sayHello () {\n    console.log('hello world')\n}\n// 导出引用\nexport { sayHello }\n```\n\n### 基本导入\n\n#### import\n\n可以通过`import`来导入被导出的模块，`import`语句由两部分组成，被导入的**标识符**和导入标识符的**来源**：`import { identifier1, identifier2 } from './module1.js'`\n\n```javascript\n// 导入单个绑定\nimport { sum } from './module.js'\n// 导入多个绑定\nimport { sum, sayHello } from './module.js'\n// 完全导入一个模块 module所有的导出绑定在example 属于命名空间导入(namespace import)\nimport * as example from './module.js'\n```\n\n需要注意的一点：无论使用多少次`import`引入模块，该模块只会执行一次。在导出的模块执行之后，已被实例化的模块会保留在内存中，随时可被其它`import`使用。同应用的其它模块，如使用`import`引入该模块，使用的也是同一个实例模块\n\n```javascript\nimport { sum } from './module.js'\nimport { sayHello } from './module.js'\n// 在这里modules.js只会执行一次，之后保留在内存中\n```\n\nimport和export有一个限制：无法在其它语句或表达式的内部使用，即必须在顶部作用域\n\n```javascript\nif (true) {\n    // error\n    import xx from './xxx'\n}\nif (true) {\n    // error\n    export xx\n}\n```\n\n> 题外话：在已完成的ES2020的提案中，有了新特性动态导入[dynamic-import](https://github.com/tc39/proposal-dynamic-import)，可根据条件判断支持按需导入\n\n### 默认导入-模块的默认值\n\n我们可以通过`default`为每一个模块设置一个且只能一个默认值\n\n```javascript\n// 普通导出\nexport let name = 'export'\n// 1 默认导出可以不用给声明加上名称 因为代表整个模块导出\nexport default function (num1, num2) {}\n// 2 也可先声明 再导出\nfunction sum (num1, num2) {}\nexport default sum\n```\n\n```javascript\n// 导入模块默认值 默认值无需加上花括号{}\nimport sum from './module.js'\nsum(1, 11)\n// 导入默认值及其它导出功能 默认名称需在位于非默认名称之前\nimport sum, { name } from './module.js'\nconsole.log(name) // export\nsum(1, 11)\n// 重命名\nimport { default as sum, name } from './module.js'\n```\n\n### 绑定导入，再导出\n\n有时候我们会需要将导入的部分功能，再导出去作为另一个模块，比如作为库，这时候可以这样操作\n\n```javascript\n// new-module.js\n// 1 先导入 再导出\nimport { identifier1, identifier2 } from './m1.js'\nexport { identifier1, identifier2 }\n// 2 会进入模块查看sum, sayHello的定义，并导出\nexport { sum, sayHello } from './module.js'\n// 3 完全导出\nexport * from './module.js'\n```\n\n完全导出需要注意一个问题，如果目标模块`module`包含了默认值，那么就无法在当前模块`new-module`再定义一个默认导出，始终遵守一个模块只能有一个默认导出的原则\n\n### 无绑定的导入\n\n有时候我们会对全局作用域对象进行一些附加操作，虽然模块中的代码不会自动共享到全局，但是我们还是可以在模块中对一些JS内置对象如`Array`、`Object`等进行访问，并且对这些对象的修改，可以反映到其它模块中\n\n```javascript\n// extendArray.js\n// 给数组添加一个pushAll的方法\nArray.prototype.pushAll = function (items) {\n    // 判断items是否为数组\n    if (!Array.isArray(items)) {\n        throw TypeError(`arguments must be an array`)\n    }\n    return this.push(...items)\n}\n```\n\n再通过`import './extendArray.js' `将模块引入，这里虽然没有绑定的导出与导入，但依然是一个有效的模块，在引入该模块的模块中，所有的数组都可以使用`pushAll()`方法\n\n这种无绑定的导入，最有可能创建用于在旧环境运行新语法时做向下兼容的`polyfill`和`shim`\n\n### 加载方式\n\n> ES6定义了模块的语法，但未定义如何加载。\n\n#### 在web浏览器中使用模块\n\n在ES6之前，已经存在多种方式可以在web应用中加载JS\n\n1. 使用`<script>`标签以及`src`属性指定加载的位置，加载JS文件；\n2. 使用`<script>`标签但不使用`src`属性，嵌入内联的JS代码；\n3. 加载JS代码文件并作为`Worker`（例如`Web Worker`或`Service Worker`）来执行\n\n##### 通过script加载模块\n\n在使用script标签时，设置type属性为module，告诉浏览器将引入的代码作为模块。且会自动应用defer属性，将模块文件下载完后，等待网页文档全部解析完，再按照模块引入顺序依次执行。如果需要异步加载模块，则可以手动加上async属性\n\n##### 将模块作为Worker加载\n\n为了支持模块加载，HTML标准的开发者给worker添加了第二个参数，该参数时带有`type`属性的对象，默认值为`script`，可以设置为`module`，以此来加载模块\n\n```javascript\n// 脚本方式\nlet worker = new Worker('script.js')\n\n// 模块方式\nlet worker = new Worker('module.js')\n```\n\n模块方式其中存在两点区别：\n\n1. worker脚本被限制只能从同源网页加载，worker模块不受限制；\n2. worker脚本可以使用`self.importScripts()`方法来将额外脚本引入worker，worker模块上的`self.importScripts()`总是失败，因为应当换用成`import`","slug":"Module","published":1,"date":"2020-01-20T05:55:02.582Z","updated":"2020-02-04T08:53:53.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4kk0005hsuhqkrztps9","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>讲到模块化，大家可能对CommonJs、AMD、CMD等规范都比较熟悉，ES6也有Module的规范。本文是对Module理解的整理。那依然先是问题三连：ES6的Module是什么？用来解决什么问题？优点是什么？</p>\n<a id=\"more\"></a>\n\n<h3 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h3><p>使用不同方式加载的JS文件，与原先脚本（script）加载方式相对。模块的真正力量在于按需导出和导入，而不在于将所有内容放在同一个文件</p>\n<h3 id=\"解决什么问题（切入点）\"><a href=\"#解决什么问题（切入点）\" class=\"headerlink\" title=\"解决什么问题（切入点）\"></a>解决什么问题（切入点）</h3><ol>\n<li>命名冲突（作用域）</li>\n<li>让JS应用变得更加有条理</li>\n<li>安全问题</li>\n</ol>\n<h3 id=\"优点是什么\"><a href=\"#优点是什么\" class=\"headerlink\" title=\"优点是什么\"></a>优点是什么</h3><ol>\n<li>自动运行在严格模式下，且无法跳出严格模式；</li>\n<li>在模块的顶级作用域创建的变量，不会自动添加到共享的全局作用域，只存在于模块顶级作用域的内部；</li>\n<li>模块顶级作用域的<code>this</code>为<code>undefined</code>；</li>\n<li>模块中不允许<code>HTML</code>风格的注释，该问题是早期浏览器历史遗留特性；</li>\n<li>要提供给外部访问的代码，模块必须导出它们；</li>\n<li>模块可以由别的模块导入绑定。</li>\n</ol>\n<h3 id=\"基本导出\"><a href=\"#基本导出\" class=\"headerlink\" title=\"基本导出\"></a>基本导出</h3><h4 id=\"export\"><a href=\"#export\" class=\"headerlink\" title=\"export\"></a>export</h4><p>我们可以在任意变量、函数、类声明之前加上<code>export</code>导出它们，没有被显式导出的将会在模块中保持私有</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// module.js</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">'Ysom'</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span> (<span class=\"hljs-params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> num1 + num2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;</span><br><span class=\"line\">    constrcutor (name, sex) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.name = name</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.sex = sex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHello</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello world'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 导出引用</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> &#123; sayHello &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本导入\"><a href=\"#基本导入\" class=\"headerlink\" title=\"基本导入\"></a>基本导入</h3><h4 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h4><p>可以通过<code>import</code>来导入被导出的模块，<code>import</code>语句由两部分组成，被导入的<strong>标识符</strong>和导入标识符的<strong>来源</strong>：<code>import { identifier1, identifier2 } from &#39;./module1.js&#39;</code></p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 导入单个绑定</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; sum &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 导入多个绑定</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; sum, sayHello &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 完全导入一个模块 module所有的导出绑定在example 属于命名空间导入(namespace import)</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> example <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的一点：无论使用多少次<code>import</code>引入模块，该模块只会执行一次。在导出的模块执行之后，已被实例化的模块会保留在内存中，随时可被其它<code>import</code>使用。同应用的其它模块，如使用<code>import</code>引入该模块，使用的也是同一个实例模块</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; sum &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; sayHello &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 在这里modules.js只会执行一次，之后保留在内存中</span></span><br></pre></td></tr></table></figure>\n\n<p>import和export有一个限制：无法在其它语句或表达式的内部使用，即必须在顶部作用域</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// error</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">import</span> xx <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./xxx'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// error</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">export</span> xx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>题外话：在已完成的ES2020的提案中，有了新特性动态导入<a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">dynamic-import</a>，可根据条件判断支持按需导入</p>\n</blockquote>\n<h3 id=\"默认导入-模块的默认值\"><a href=\"#默认导入-模块的默认值\" class=\"headerlink\" title=\"默认导入-模块的默认值\"></a>默认导入-模块的默认值</h3><p>我们可以通过<code>default</code>为每一个模块设置一个且只能一个默认值</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 普通导出</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">'export'</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 1 默认导出可以不用给声明加上名称 因为代表整个模块导出</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">num1, num2</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 2 也可先声明 再导出</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sum</span> (<span class=\"hljs-params\">num1, num2</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> sum</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 导入模块默认值 默认值无需加上花括号&#123;&#125;</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> sum <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br><span class=\"line\">sum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">11</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">// 导入默认值及其它导出功能 默认名称需在位于非默认名称之前</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> sum, &#123; name &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">console</span>.log(name) <span class=\"hljs-comment\">// export</span></span><br><span class=\"line\">sum(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">11</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">// 重命名</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">as</span> sum, name &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"绑定导入，再导出\"><a href=\"#绑定导入，再导出\" class=\"headerlink\" title=\"绑定导入，再导出\"></a>绑定导入，再导出</h3><p>有时候我们会需要将导入的部分功能，再导出去作为另一个模块，比如作为库，这时候可以这样操作</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// new-module.js</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 1 先导入 再导出</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; identifier1, identifier2 &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./m1.js'</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> &#123; identifier1, identifier2 &#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">// 2 会进入模块查看sum, sayHello的定义，并导出</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> &#123; sum, sayHello &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 3 完全导出</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span></span><br></pre></td></tr></table></figure>\n\n<p>完全导出需要注意一个问题，如果目标模块<code>module</code>包含了默认值，那么就无法在当前模块<code>new-module</code>再定义一个默认导出，始终遵守一个模块只能有一个默认导出的原则</p>\n<h3 id=\"无绑定的导入\"><a href=\"#无绑定的导入\" class=\"headerlink\" title=\"无绑定的导入\"></a>无绑定的导入</h3><p>有时候我们会对全局作用域对象进行一些附加操作，虽然模块中的代码不会自动共享到全局，但是我们还是可以在模块中对一些JS内置对象如<code>Array</code>、<code>Object</code>等进行访问，并且对这些对象的修改，可以反映到其它模块中</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// extendArray.js</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// 给数组添加一个pushAll的方法</span></span><br><span class=\"line\"><span class=\"hljs-built_in\">Array</span>.prototype.pushAll = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">items</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 判断items是否为数组</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">Array</span>.isArray(items)) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">`arguments must be an array`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.push(...items)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再通过<code>import &#39;./extendArray.js&#39;</code>将模块引入，这里虽然没有绑定的导出与导入，但依然是一个有效的模块，在引入该模块的模块中，所有的数组都可以使用<code>pushAll()</code>方法</p>\n<p>这种无绑定的导入，最有可能创建用于在旧环境运行新语法时做向下兼容的<code>polyfill</code>和<code>shim</code></p>\n<h3 id=\"加载方式\"><a href=\"#加载方式\" class=\"headerlink\" title=\"加载方式\"></a>加载方式</h3><blockquote>\n<p>ES6定义了模块的语法，但未定义如何加载。</p>\n</blockquote>\n<h4 id=\"在web浏览器中使用模块\"><a href=\"#在web浏览器中使用模块\" class=\"headerlink\" title=\"在web浏览器中使用模块\"></a>在web浏览器中使用模块</h4><p>在ES6之前，已经存在多种方式可以在web应用中加载JS</p>\n<ol>\n<li>使用<code>&lt;script&gt;</code>标签以及<code>src</code>属性指定加载的位置，加载JS文件；</li>\n<li>使用<code>&lt;script&gt;</code>标签但不使用<code>src</code>属性，嵌入内联的JS代码；</li>\n<li>加载JS代码文件并作为<code>Worker</code>（例如<code>Web Worker</code>或<code>Service Worker</code>）来执行</li>\n</ol>\n<h5 id=\"通过script加载模块\"><a href=\"#通过script加载模块\" class=\"headerlink\" title=\"通过script加载模块\"></a>通过script加载模块</h5><p>在使用script标签时，设置type属性为module，告诉浏览器将引入的代码作为模块。且会自动应用defer属性，将模块文件下载完后，等待网页文档全部解析完，再按照模块引入顺序依次执行。如果需要异步加载模块，则可以手动加上async属性</p>\n<h5 id=\"将模块作为Worker加载\"><a href=\"#将模块作为Worker加载\" class=\"headerlink\" title=\"将模块作为Worker加载\"></a>将模块作为Worker加载</h5><p>为了支持模块加载，HTML标准的开发者给worker添加了第二个参数，该参数时带有<code>type</code>属性的对象，默认值为<code>script</code>，可以设置为<code>module</code>，以此来加载模块</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 脚本方式</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> worker = <span class=\"hljs-keyword\">new</span> Worker(<span class=\"hljs-string\">'script.js'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 模块方式</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> worker = <span class=\"hljs-keyword\">new</span> Worker(<span class=\"hljs-string\">'module.js'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>模块方式其中存在两点区别：</p>\n<ol>\n<li>worker脚本被限制只能从同源网页加载，worker模块不受限制；</li>\n<li>worker脚本可以使用<code>self.importScripts()</code>方法来将额外脚本引入worker，worker模块上的<code>self.importScripts()</code>总是失败，因为应当换用成<code>import</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>讲到模块化，大家可能对CommonJs、AMD、CMD等规范都比较熟悉，ES6也有Module的规范。本文是对Module理解的整理。那依然先是问题三连：ES6的Module是什么？用来解决什么问题？优点是什么？</p>","more":"<h3 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h3><p>使用不同方式加载的JS文件，与原先脚本（script）加载方式相对。模块的真正力量在于按需导出和导入，而不在于将所有内容放在同一个文件</p>\n<h3 id=\"解决什么问题（切入点）\"><a href=\"#解决什么问题（切入点）\" class=\"headerlink\" title=\"解决什么问题（切入点）\"></a>解决什么问题（切入点）</h3><ol>\n<li>命名冲突（作用域）</li>\n<li>让JS应用变得更加有条理</li>\n<li>安全问题</li>\n</ol>\n<h3 id=\"优点是什么\"><a href=\"#优点是什么\" class=\"headerlink\" title=\"优点是什么\"></a>优点是什么</h3><ol>\n<li>自动运行在严格模式下，且无法跳出严格模式；</li>\n<li>在模块的顶级作用域创建的变量，不会自动添加到共享的全局作用域，只存在于模块顶级作用域的内部；</li>\n<li>模块顶级作用域的<code>this</code>为<code>undefined</code>；</li>\n<li>模块中不允许<code>HTML</code>风格的注释，该问题是早期浏览器历史遗留特性；</li>\n<li>要提供给外部访问的代码，模块必须导出它们；</li>\n<li>模块可以由别的模块导入绑定。</li>\n</ol>\n<h3 id=\"基本导出\"><a href=\"#基本导出\" class=\"headerlink\" title=\"基本导出\"></a>基本导出</h3><h4 id=\"export\"><a href=\"#export\" class=\"headerlink\" title=\"export\"></a>export</h4><p>我们可以在任意变量、函数、类声明之前加上<code>export</code>导出它们，没有被显式导出的将会在模块中保持私有</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// module.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> name = <span class=\"string\">'Ysom'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num1 + num2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    constrcutor (name, sex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello world'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 导出引用</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; sayHello &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本导入\"><a href=\"#基本导入\" class=\"headerlink\" title=\"基本导入\"></a>基本导入</h3><h4 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h4><p>可以通过<code>import</code>来导入被导出的模块，<code>import</code>语句由两部分组成，被导入的<strong>标识符</strong>和导入标识符的<strong>来源</strong>：<code>import { identifier1, identifier2 } from &#39;./module1.js&#39;</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导入单个绑定</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; sum &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 导入多个绑定</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; sum, sayHello &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 完全导入一个模块 module所有的导出绑定在example 属于命名空间导入(namespace import)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> example <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的一点：无论使用多少次<code>import</code>引入模块，该模块只会执行一次。在导出的模块执行之后，已被实例化的模块会保留在内存中，随时可被其它<code>import</code>使用。同应用的其它模块，如使用<code>import</code>引入该模块，使用的也是同一个实例模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; sum &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; sayHello &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 在这里modules.js只会执行一次，之后保留在内存中</span></span><br></pre></td></tr></table></figure>\n\n<p>import和export有一个限制：无法在其它语句或表达式的内部使用，即必须在顶部作用域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> xx <span class=\"keyword\">from</span> <span class=\"string\">'./xxx'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error</span></span><br><span class=\"line\">    <span class=\"keyword\">export</span> xx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>题外话：在已完成的ES2020的提案中，有了新特性动态导入<a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">dynamic-import</a>，可根据条件判断支持按需导入</p>\n</blockquote>\n<h3 id=\"默认导入-模块的默认值\"><a href=\"#默认导入-模块的默认值\" class=\"headerlink\" title=\"默认导入-模块的默认值\"></a>默认导入-模块的默认值</h3><p>我们可以通过<code>default</code>为每一个模块设置一个且只能一个默认值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> name = <span class=\"string\">'export'</span></span><br><span class=\"line\"><span class=\"comment\">// 1 默认导出可以不用给声明加上名称 因为代表整个模块导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num1, num2</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 也可先声明 再导出</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">num1, num2</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> sum</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 导入模块默认值 默认值无需加上花括号&#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sum <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"comment\">// 导入默认值及其它导出功能 默认名称需在位于非默认名称之前</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sum, &#123; name &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name) <span class=\"comment\">// export</span></span><br><span class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"comment\">// 重命名</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">default</span> <span class=\"keyword\">as</span> sum, name &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"绑定导入，再导出\"><a href=\"#绑定导入，再导出\" class=\"headerlink\" title=\"绑定导入，再导出\"></a>绑定导入，再导出</h3><p>有时候我们会需要将导入的部分功能，再导出去作为另一个模块，比如作为库，这时候可以这样操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new-module.js</span></span><br><span class=\"line\"><span class=\"comment\">// 1 先导入 再导出</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; identifier1, identifier2 &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./m1.js'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; identifier1, identifier2 &#125;</span><br><span class=\"line\"><span class=\"comment\">// 2 会进入模块查看sum, sayHello的定义，并导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; sum, sayHello &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 3 完全导出</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">'./module.js'</span></span><br></pre></td></tr></table></figure>\n\n<p>完全导出需要注意一个问题，如果目标模块<code>module</code>包含了默认值，那么就无法在当前模块<code>new-module</code>再定义一个默认导出，始终遵守一个模块只能有一个默认导出的原则</p>\n<h3 id=\"无绑定的导入\"><a href=\"#无绑定的导入\" class=\"headerlink\" title=\"无绑定的导入\"></a>无绑定的导入</h3><p>有时候我们会对全局作用域对象进行一些附加操作，虽然模块中的代码不会自动共享到全局，但是我们还是可以在模块中对一些JS内置对象如<code>Array</code>、<code>Object</code>等进行访问，并且对这些对象的修改，可以反映到其它模块中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// extendArray.js</span></span><br><span class=\"line\"><span class=\"comment\">// 给数组添加一个pushAll的方法</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.pushAll = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">items</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断items是否为数组</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(items)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">`arguments must be an array`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.push(...items)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再通过<code>import &#39;./extendArray.js&#39;</code>将模块引入，这里虽然没有绑定的导出与导入，但依然是一个有效的模块，在引入该模块的模块中，所有的数组都可以使用<code>pushAll()</code>方法</p>\n<p>这种无绑定的导入，最有可能创建用于在旧环境运行新语法时做向下兼容的<code>polyfill</code>和<code>shim</code></p>\n<h3 id=\"加载方式\"><a href=\"#加载方式\" class=\"headerlink\" title=\"加载方式\"></a>加载方式</h3><blockquote>\n<p>ES6定义了模块的语法，但未定义如何加载。</p>\n</blockquote>\n<h4 id=\"在web浏览器中使用模块\"><a href=\"#在web浏览器中使用模块\" class=\"headerlink\" title=\"在web浏览器中使用模块\"></a>在web浏览器中使用模块</h4><p>在ES6之前，已经存在多种方式可以在web应用中加载JS</p>\n<ol>\n<li>使用<code>&lt;script&gt;</code>标签以及<code>src</code>属性指定加载的位置，加载JS文件；</li>\n<li>使用<code>&lt;script&gt;</code>标签但不使用<code>src</code>属性，嵌入内联的JS代码；</li>\n<li>加载JS代码文件并作为<code>Worker</code>（例如<code>Web Worker</code>或<code>Service Worker</code>）来执行</li>\n</ol>\n<h5 id=\"通过script加载模块\"><a href=\"#通过script加载模块\" class=\"headerlink\" title=\"通过script加载模块\"></a>通过script加载模块</h5><p>在使用script标签时，设置type属性为module，告诉浏览器将引入的代码作为模块。且会自动应用defer属性，将模块文件下载完后，等待网页文档全部解析完，再按照模块引入顺序依次执行。如果需要异步加载模块，则可以手动加上async属性</p>\n<h5 id=\"将模块作为Worker加载\"><a href=\"#将模块作为Worker加载\" class=\"headerlink\" title=\"将模块作为Worker加载\"></a>将模块作为Worker加载</h5><p>为了支持模块加载，HTML标准的开发者给worker添加了第二个参数，该参数时带有<code>type</code>属性的对象，默认值为<code>script</code>，可以设置为<code>module</code>，以此来加载模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 脚本方式</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'script.js'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模块方式</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'module.js'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>模块方式其中存在两点区别：</p>\n<ol>\n<li>worker脚本被限制只能从同源网页加载，worker模块不受限制；</li>\n<li>worker脚本可以使用<code>self.importScripts()</code>方法来将额外脚本引入worker，worker模块上的<code>self.importScripts()</code>总是失败，因为应当换用成<code>import</code></li>\n</ol>"},{"title":"Vue3.0，它来了","_content":"\n> 10月5号凌晨，尤雨溪大大发布了[vue3.0源码](https://github.com/vuejs/vue-next)\n\n![尤雨溪sina微博](/images/sina_yyx.jpg)\n\n现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西\n\n### 整体状态\n\n- 目前发布的vue3.0是`Pre-Alpha`版本，后续还有`Alpha`、`Beta`版本\n- 打包后的代码是ES2015+，不支持IE11\n- 拥抱TypeScript，98%代码使用了TypeScript编写\n\n\n\n<!-- more -->\n\n\n\n### 代码目录\n\n![目录树结构](/images/vue-next-code-tree.png)\n\n由上图看到（安装了`Octotree`插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个`packages`目录，里面包含了vue3.0主要实现的功能：\n\n- **compiler-core**：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件\n- **compiler-dom**：针对浏览器而写的编译器\n- **reactivity**：数据响应式系统。一个单独的系统，可以与任何框架配合使用\n- **runtime-core**：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API\n- **runtime-dom**： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等\n- **runtime-test**：一个专门为了测试而写的轻量级 runtime\n- **server-renderer**：用于 SSR（还未实现）\n- **shared**：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法\n- **template-explorer**：用于模板编译输出\n- **vue**： 用于构建「完整构建」版本\n\n由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。","source":"_posts/Vue3.0它来了，带着Pre-Alpha来了.md","raw":"---\ntitle: Vue3.0，它来了\ncategories:\n - 前端\ntags:\n - 源码\n - vue\n---\n\n> 10月5号凌晨，尤雨溪大大发布了[vue3.0源码](https://github.com/vuejs/vue-next)\n\n![尤雨溪sina微博](/images/sina_yyx.jpg)\n\n现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西\n\n### 整体状态\n\n- 目前发布的vue3.0是`Pre-Alpha`版本，后续还有`Alpha`、`Beta`版本\n- 打包后的代码是ES2015+，不支持IE11\n- 拥抱TypeScript，98%代码使用了TypeScript编写\n\n\n\n<!-- more -->\n\n\n\n### 代码目录\n\n![目录树结构](/images/vue-next-code-tree.png)\n\n由上图看到（安装了`Octotree`插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个`packages`目录，里面包含了vue3.0主要实现的功能：\n\n- **compiler-core**：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件\n- **compiler-dom**：针对浏览器而写的编译器\n- **reactivity**：数据响应式系统。一个单独的系统，可以与任何框架配合使用\n- **runtime-core**：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API\n- **runtime-dom**： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等\n- **runtime-test**：一个专门为了测试而写的轻量级 runtime\n- **server-renderer**：用于 SSR（还未实现）\n- **shared**：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法\n- **template-explorer**：用于模板编译输出\n- **vue**： 用于构建「完整构建」版本\n\n由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。","slug":"Vue3.0它来了，带着Pre-Alpha来了","published":1,"date":"2019-10-07T14:18:39.581Z","updated":"2019-10-08T09:05:49.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4kn0006hsuh335527ee","content":"<blockquote>\n<p>10月5号凌晨，尤雨溪大大发布了<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">vue3.0源码</a></p>\n</blockquote>\n<p><img src=\"/images/sina_yyx.jpg\" alt=\"尤雨溪sina微博\"></p>\n<p>现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西</p>\n<h3 id=\"整体状态\"><a href=\"#整体状态\" class=\"headerlink\" title=\"整体状态\"></a>整体状态</h3><ul>\n<li>目前发布的vue3.0是<code>Pre-Alpha</code>版本，后续还有<code>Alpha</code>、<code>Beta</code>版本</li>\n<li>打包后的代码是ES2015+，不支持IE11</li>\n<li>拥抱TypeScript，98%代码使用了TypeScript编写</li>\n</ul>\n<a id=\"more\"></a>\n\n\n\n<h3 id=\"代码目录\"><a href=\"#代码目录\" class=\"headerlink\" title=\"代码目录\"></a>代码目录</h3><p><img src=\"/images/vue-next-code-tree.png\" alt=\"目录树结构\"></p>\n<p>由上图看到（安装了<code>Octotree</code>插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个<code>packages</code>目录，里面包含了vue3.0主要实现的功能：</p>\n<ul>\n<li><strong>compiler-core</strong>：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件</li>\n<li><strong>compiler-dom</strong>：针对浏览器而写的编译器</li>\n<li><strong>reactivity</strong>：数据响应式系统。一个单独的系统，可以与任何框架配合使用</li>\n<li><strong>runtime-core</strong>：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API</li>\n<li><strong>runtime-dom</strong>： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等</li>\n<li><strong>runtime-test</strong>：一个专门为了测试而写的轻量级 runtime</li>\n<li><strong>server-renderer</strong>：用于 SSR（还未实现）</li>\n<li><strong>shared</strong>：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法</li>\n<li><strong>template-explorer</strong>：用于模板编译输出</li>\n<li><strong>vue</strong>： 用于构建「完整构建」版本</li>\n</ul>\n<p>由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>10月5号凌晨，尤雨溪大大发布了<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">vue3.0源码</a></p>\n</blockquote>\n<p><img src=\"/images/sina_yyx.jpg\" alt=\"尤雨溪sina微博\"></p>\n<p>现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西</p>\n<h3 id=\"整体状态\"><a href=\"#整体状态\" class=\"headerlink\" title=\"整体状态\"></a>整体状态</h3><ul>\n<li>目前发布的vue3.0是<code>Pre-Alpha</code>版本，后续还有<code>Alpha</code>、<code>Beta</code>版本</li>\n<li>打包后的代码是ES2015+，不支持IE11</li>\n<li>拥抱TypeScript，98%代码使用了TypeScript编写</li>\n</ul>","more":"<h3 id=\"代码目录\"><a href=\"#代码目录\" class=\"headerlink\" title=\"代码目录\"></a>代码目录</h3><p><img src=\"/images/vue-next-code-tree.png\" alt=\"目录树结构\"></p>\n<p>由上图看到（安装了<code>Octotree</code>插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个<code>packages</code>目录，里面包含了vue3.0主要实现的功能：</p>\n<ul>\n<li><strong>compiler-core</strong>：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件</li>\n<li><strong>compiler-dom</strong>：针对浏览器而写的编译器</li>\n<li><strong>reactivity</strong>：数据响应式系统。一个单独的系统，可以与任何框架配合使用</li>\n<li><strong>runtime-core</strong>：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API</li>\n<li><strong>runtime-dom</strong>： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等</li>\n<li><strong>runtime-test</strong>：一个专门为了测试而写的轻量级 runtime</li>\n<li><strong>server-renderer</strong>：用于 SSR（还未实现）</li>\n<li><strong>shared</strong>：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法</li>\n<li><strong>template-explorer</strong>：用于模板编译输出</li>\n<li><strong>vue</strong>： 用于构建「完整构建」版本</li>\n</ul>\n<p>由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。</p>"},{"title":"振奋人心的ES2020新特性！","_content":"\nES2020已完成的[提案](https://github.com/tc39/proposals/blob/master/finished-proposals.md)中，有了比较振奋人心的新特性。下面来看看几个比较有意思的特性\n\n### BigInt\n\n在JS的`Number`类型中，安全值的范围为`Number.MIN_SAFE_INTEGER`-`Number.MAX_SAFE_INTEGER`，即-(2<sup>53</sup>-1)~2<sup>53</sup>-1，超出该范围整数计算或表示将会丢失精度\n\n```javascript\nlet max_num = Number.MAX_SAFE_INTEGER // 9007199254740991\nlet more_num = max_num + 1 // 9007199254740992\nlet more_max_num = max_num + 2 // 9007199254740992\n```\n\n可以看到，当数值超过安全范围时，就不会正确表示，甚至还有以下情况\n\n<!-- more -->\n\n```javascript\n9007199254740992 === 9007199254740993 // true\n```\n\n新规范`BigInt`就是用来解决大数计算问题，同时它也属于原始类型。可以在整数后面加上n或者BigInt函数来实现\n\n```javascript\n// 直接在整数后面加n\nlet bigNum = 9007199254740993n\n\n// 使用BigInt函数\nlet bigNum = BigInt(9007199254740993)\n// or \nlet bigNum = BigInt('9007199254740993')\n\n// 大数运算\nlet superNum = 9007199254740993n + 9007199254740993n \n// 18014398509481986n\ntypeof superNum // 'bigInt'\n```\n\n需要注意的是，使用`BigInt`函数实例化大数时，会将参数进行Number类型的实例化，超出安全范围的数字可能会引起精度丢失\n\n### Promise.allSettled\n\n用过`Promise.all`的都知道，这方法有一个比较明显的缺陷，只要其中一个Promise被`reject`，整个`Promise.all`就会挂掉，剩下的Promise都会停止执行。例如在一个用户模块中，通过并发异步请求多个版块的数据，只要其中一个服务挂了，其它的版块也就不会拿到数据。很明显，这并不是我们想要的，我们希望并发的任务，不管是异常还是正常，都可以返回对应的状态和值，这样就可以最大限度地保证服务的可访问性。新特性`Promise.allSettled`就是来满足这一要求的\n\n```javascript\nPromise.allSettled([\n    Promise.reject({status: 'fail', msg: '服务异常'}),\n    Promise.resolve({status: 'suc', data: {}}),\n    Promise.resolve({status: 'suc', data: {}})\n]).then(result => {\n    /*\n    * 0: {status: 'rejected', reason: {}},\n    * 1: {status: 'fulfilled', value: {}},\n    * 2: {status: 'fulfilled', value: {}}\n    */\n})\n```\n\n当服务异常时，会返回status和reason字段，reason值为reject的值，而当服务正常时，会返回status和value字段。可以通过filter函数来过滤出fulfilled状态的数据，从而实现服务正常的数据渲染\n\n### globalThis \n\n一般我们很难写出可移植的js代码来访问全局对象，因为在不用的环境全局对象也不同。在web中，全局对象为`window`、`self`，在node中，为`global`，甚至很多时候会使用`this`来访问全局对象，但是`this`严重依赖上下文，还会存在各种改变`this`指向的情况，这会导致更加复杂。而现在，通过一个`globalThis`就可以轻松获取到当前环境下的全局对象，是不是很清爽？\n\n### optional Chaining \n\n如果我们要使用到多层级对象中的某个属性，为了避免属性不存在时抛出错误，需要经过一系列前置的繁琐的判断\n\n```javascript\nlet data = {}\nif (data && data.options && data.options.name) {\n    let name = data.options.name\n}\n```\n\n看起来很麻烦。有了**可选链**新特性后，只需简单一句代码\n\n```javascript\nlet name = data?.options?.name\n```\n\n判断`?`前的属性是否存在，存在才会继续查询`.`后面的属性。简化了大量前置校验，且更为安全\n\n### Nullish coalescing Operator\n\n在对某个变量或对象的属性赋值时，我们会经常做以下类似的操作\n\n```javascript\nlet defaultFlag = 'default'\nlet obj = {\n    name: defaultFlag || 'obj',\n    value: 18,\n    level: 0\n}\n```\n\n当`defaultFlag`转换为布尔值是true的时候，就会采用`defaultFlag`代表的值，否则采用值`obj`，但是这会有一些问题，比如值为0的时候，`defaultFlag`的值就为false，这会跳过0直接赋值为后面的值，如果我们允许0的存在，那这里就会出现预想中的误差。再看新特性**空值合并运算符** `??`\n\n```javascript\nlet level = obj.level ?? '暂无等级'\n```\n\n使用空值合并运算符之后，只有当值为`undefined`、`null`的时候，才会跳过，赋值为后面的值","source":"_posts/finished-proposals-ES2020.md","raw":"---\n\ntitle: 振奋人心的ES2020新特性！\ncategories:\n - 前端\ntags:\n - JS\n---\n\nES2020已完成的[提案](https://github.com/tc39/proposals/blob/master/finished-proposals.md)中，有了比较振奋人心的新特性。下面来看看几个比较有意思的特性\n\n### BigInt\n\n在JS的`Number`类型中，安全值的范围为`Number.MIN_SAFE_INTEGER`-`Number.MAX_SAFE_INTEGER`，即-(2<sup>53</sup>-1)~2<sup>53</sup>-1，超出该范围整数计算或表示将会丢失精度\n\n```javascript\nlet max_num = Number.MAX_SAFE_INTEGER // 9007199254740991\nlet more_num = max_num + 1 // 9007199254740992\nlet more_max_num = max_num + 2 // 9007199254740992\n```\n\n可以看到，当数值超过安全范围时，就不会正确表示，甚至还有以下情况\n\n<!-- more -->\n\n```javascript\n9007199254740992 === 9007199254740993 // true\n```\n\n新规范`BigInt`就是用来解决大数计算问题，同时它也属于原始类型。可以在整数后面加上n或者BigInt函数来实现\n\n```javascript\n// 直接在整数后面加n\nlet bigNum = 9007199254740993n\n\n// 使用BigInt函数\nlet bigNum = BigInt(9007199254740993)\n// or \nlet bigNum = BigInt('9007199254740993')\n\n// 大数运算\nlet superNum = 9007199254740993n + 9007199254740993n \n// 18014398509481986n\ntypeof superNum // 'bigInt'\n```\n\n需要注意的是，使用`BigInt`函数实例化大数时，会将参数进行Number类型的实例化，超出安全范围的数字可能会引起精度丢失\n\n### Promise.allSettled\n\n用过`Promise.all`的都知道，这方法有一个比较明显的缺陷，只要其中一个Promise被`reject`，整个`Promise.all`就会挂掉，剩下的Promise都会停止执行。例如在一个用户模块中，通过并发异步请求多个版块的数据，只要其中一个服务挂了，其它的版块也就不会拿到数据。很明显，这并不是我们想要的，我们希望并发的任务，不管是异常还是正常，都可以返回对应的状态和值，这样就可以最大限度地保证服务的可访问性。新特性`Promise.allSettled`就是来满足这一要求的\n\n```javascript\nPromise.allSettled([\n    Promise.reject({status: 'fail', msg: '服务异常'}),\n    Promise.resolve({status: 'suc', data: {}}),\n    Promise.resolve({status: 'suc', data: {}})\n]).then(result => {\n    /*\n    * 0: {status: 'rejected', reason: {}},\n    * 1: {status: 'fulfilled', value: {}},\n    * 2: {status: 'fulfilled', value: {}}\n    */\n})\n```\n\n当服务异常时，会返回status和reason字段，reason值为reject的值，而当服务正常时，会返回status和value字段。可以通过filter函数来过滤出fulfilled状态的数据，从而实现服务正常的数据渲染\n\n### globalThis \n\n一般我们很难写出可移植的js代码来访问全局对象，因为在不用的环境全局对象也不同。在web中，全局对象为`window`、`self`，在node中，为`global`，甚至很多时候会使用`this`来访问全局对象，但是`this`严重依赖上下文，还会存在各种改变`this`指向的情况，这会导致更加复杂。而现在，通过一个`globalThis`就可以轻松获取到当前环境下的全局对象，是不是很清爽？\n\n### optional Chaining \n\n如果我们要使用到多层级对象中的某个属性，为了避免属性不存在时抛出错误，需要经过一系列前置的繁琐的判断\n\n```javascript\nlet data = {}\nif (data && data.options && data.options.name) {\n    let name = data.options.name\n}\n```\n\n看起来很麻烦。有了**可选链**新特性后，只需简单一句代码\n\n```javascript\nlet name = data?.options?.name\n```\n\n判断`?`前的属性是否存在，存在才会继续查询`.`后面的属性。简化了大量前置校验，且更为安全\n\n### Nullish coalescing Operator\n\n在对某个变量或对象的属性赋值时，我们会经常做以下类似的操作\n\n```javascript\nlet defaultFlag = 'default'\nlet obj = {\n    name: defaultFlag || 'obj',\n    value: 18,\n    level: 0\n}\n```\n\n当`defaultFlag`转换为布尔值是true的时候，就会采用`defaultFlag`代表的值，否则采用值`obj`，但是这会有一些问题，比如值为0的时候，`defaultFlag`的值就为false，这会跳过0直接赋值为后面的值，如果我们允许0的存在，那这里就会出现预想中的误差。再看新特性**空值合并运算符** `??`\n\n```javascript\nlet level = obj.level ?? '暂无等级'\n```\n\n使用空值合并运算符之后，只有当值为`undefined`、`null`的时候，才会跳过，赋值为后面的值","slug":"finished-proposals-ES2020","published":1,"date":"2020-01-13T15:05:15.051Z","updated":"2020-01-21T03:23:07.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4kr0007hsuhjr8wd04c","content":"<p>ES2020已完成的<a href=\"https://github.com/tc39/proposals/blob/master/finished-proposals.md\" target=\"_blank\" rel=\"noopener\">提案</a>中，有了比较振奋人心的新特性。下面来看看几个比较有意思的特性</p>\n<h3 id=\"BigInt\"><a href=\"#BigInt\" class=\"headerlink\" title=\"BigInt\"></a>BigInt</h3><p>在JS的<code>Number</code>类型中，安全值的范围为<code>Number.MIN_SAFE_INTEGER</code>-<code>Number.MAX_SAFE_INTEGER</code>，即-(2<sup>53</sup>-1)~2<sup>53</sup>-1，超出该范围整数计算或表示将会丢失精度</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> max_num = <span class=\"hljs-built_in\">Number</span>.MAX_SAFE_INTEGER <span class=\"hljs-comment\">// 9007199254740991</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> more_num = max_num + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 9007199254740992</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> more_max_num = max_num + <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// 9007199254740992</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，当数值超过安全范围时，就不会正确表示，甚至还有以下情况</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-number\">9007199254740992</span> === <span class=\"hljs-number\">9007199254740993</span> <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>新规范<code>BigInt</code>就是用来解决大数计算问题，同时它也属于原始类型。可以在整数后面加上n或者BigInt函数来实现</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 直接在整数后面加n</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> bigNum = <span class=\"hljs-number\">9007199254740993</span>n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 使用BigInt函数</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> bigNum = BigInt(<span class=\"hljs-number\">9007199254740993</span>)</span><br><span class=\"line\"><span class=\"hljs-comment\">// or </span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> bigNum = BigInt(<span class=\"hljs-string\">'9007199254740993'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 大数运算</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> superNum = <span class=\"hljs-number\">9007199254740993</span>n + <span class=\"hljs-number\">9007199254740993</span>n </span><br><span class=\"line\"><span class=\"hljs-comment\">// 18014398509481986n</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">typeof</span> superNum <span class=\"hljs-comment\">// 'bigInt'</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用<code>BigInt</code>函数实例化大数时，会将参数进行Number类型的实例化，超出安全范围的数字可能会引起精度丢失</p>\n<h3 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled\"></a>Promise.allSettled</h3><p>用过<code>Promise.all</code>的都知道，这方法有一个比较明显的缺陷，只要其中一个Promise被<code>reject</code>，整个<code>Promise.all</code>就会挂掉，剩下的Promise都会停止执行。例如在一个用户模块中，通过并发异步请求多个版块的数据，只要其中一个服务挂了，其它的版块也就不会拿到数据。很明显，这并不是我们想要的，我们希望并发的任务，不管是异常还是正常，都可以返回对应的状态和值，这样就可以最大限度地保证服务的可访问性。新特性<code>Promise.allSettled</code>就是来满足这一要求的</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-built_in\">Promise</span>.allSettled([</span><br><span class=\"line\">    <span class=\"hljs-built_in\">Promise</span>.reject(&#123;<span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">'fail'</span>, <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'服务异常'</span>&#125;),</span><br><span class=\"line\">    <span class=\"hljs-built_in\">Promise</span>.resolve(&#123;<span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">'suc'</span>, <span class=\"hljs-attr\">data</span>: &#123;&#125;&#125;),</span><br><span class=\"line\">    <span class=\"hljs-built_in\">Promise</span>.resolve(&#123;<span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">'suc'</span>, <span class=\"hljs-attr\">data</span>: &#123;&#125;&#125;)</span><br><span class=\"line\">]).then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">/*</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    * 0: &#123;status: 'rejected', reason: &#123;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    * 1: &#123;status: 'fulfilled', value: &#123;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    * 2: &#123;status: 'fulfilled', value: &#123;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"hljs-comment\">    */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当服务异常时，会返回status和reason字段，reason值为reject的值，而当服务正常时，会返回status和value字段。可以通过filter函数来过滤出fulfilled状态的数据，从而实现服务正常的数据渲染</p>\n<h3 id=\"globalThis\"><a href=\"#globalThis\" class=\"headerlink\" title=\"globalThis\"></a>globalThis</h3><p>一般我们很难写出可移植的js代码来访问全局对象，因为在不用的环境全局对象也不同。在web中，全局对象为<code>window</code>、<code>self</code>，在node中，为<code>global</code>，甚至很多时候会使用<code>this</code>来访问全局对象，但是<code>this</code>严重依赖上下文，还会存在各种改变<code>this</code>指向的情况，这会导致更加复杂。而现在，通过一个<code>globalThis</code>就可以轻松获取到当前环境下的全局对象，是不是很清爽？</p>\n<h3 id=\"optional-Chaining\"><a href=\"#optional-Chaining\" class=\"headerlink\" title=\"optional Chaining\"></a>optional Chaining</h3><p>如果我们要使用到多层级对象中的某个属性，为了避免属性不存在时抛出错误，需要经过一系列前置的繁琐的判断</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> data = &#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span> (data &amp;&amp; data.options &amp;&amp; data.options.name) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">let</span> name = data.options.name</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很麻烦。有了<strong>可选链</strong>新特性后，只需简单一句代码</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> name = data?.options?.name</span><br></pre></td></tr></table></figure>\n\n<p>判断<code>?</code>前的属性是否存在，存在才会继续查询<code>.</code>后面的属性。简化了大量前置校验，且更为安全</p>\n<h3 id=\"Nullish-coalescing-Operator\"><a href=\"#Nullish-coalescing-Operator\" class=\"headerlink\" title=\"Nullish coalescing Operator\"></a>Nullish coalescing Operator</h3><p>在对某个变量或对象的属性赋值时，我们会经常做以下类似的操作</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> defaultFlag = <span class=\"hljs-string\">'default'</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    name: defaultFlag || <span class=\"hljs-string\">'obj'</span>,</span><br><span class=\"line\">    value: <span class=\"hljs-number\">18</span>,</span><br><span class=\"line\">    level: <span class=\"hljs-number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>defaultFlag</code>转换为布尔值是true的时候，就会采用<code>defaultFlag</code>代表的值，否则采用值<code>obj</code>，但是这会有一些问题，比如值为0的时候，<code>defaultFlag</code>的值就为false，这会跳过0直接赋值为后面的值，如果我们允许0的存在，那这里就会出现预想中的误差。再看新特性<strong>空值合并运算符</strong> <code>??</code></p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> level = obj.level ?? <span class=\"hljs-string\">'暂无等级'</span></span><br></pre></td></tr></table></figure>\n\n<p>使用空值合并运算符之后，只有当值为<code>undefined</code>、<code>null</code>的时候，才会跳过，赋值为后面的值</p>\n","site":{"data":{}},"excerpt":"<p>ES2020已完成的<a href=\"https://github.com/tc39/proposals/blob/master/finished-proposals.md\" target=\"_blank\" rel=\"noopener\">提案</a>中，有了比较振奋人心的新特性。下面来看看几个比较有意思的特性</p>\n<h3 id=\"BigInt\"><a href=\"#BigInt\" class=\"headerlink\" title=\"BigInt\"></a>BigInt</h3><p>在JS的<code>Number</code>类型中，安全值的范围为<code>Number.MIN_SAFE_INTEGER</code>-<code>Number.MAX_SAFE_INTEGER</code>，即-(2<sup>53</sup>-1)~2<sup>53</sup>-1，超出该范围整数计算或表示将会丢失精度</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> max_num = <span class=\"hljs-built_in\">Number</span>.MAX_SAFE_INTEGER <span class=\"hljs-comment\">// 9007199254740991</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> more_num = max_num + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 9007199254740992</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> more_max_num = max_num + <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// 9007199254740992</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，当数值超过安全范围时，就不会正确表示，甚至还有以下情况</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">9007199254740992</span> === <span class=\"number\">9007199254740993</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>新规范<code>BigInt</code>就是用来解决大数计算问题，同时它也属于原始类型。可以在整数后面加上n或者BigInt函数来实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接在整数后面加n</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bigNum = <span class=\"number\">9007199254740993</span>n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用BigInt函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bigNum = BigInt(<span class=\"number\">9007199254740993</span>)</span><br><span class=\"line\"><span class=\"comment\">// or </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bigNum = BigInt(<span class=\"string\">'9007199254740993'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大数运算</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> superNum = <span class=\"number\">9007199254740993</span>n + <span class=\"number\">9007199254740993</span>n </span><br><span class=\"line\"><span class=\"comment\">// 18014398509481986n</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> superNum <span class=\"comment\">// 'bigInt'</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用<code>BigInt</code>函数实例化大数时，会将参数进行Number类型的实例化，超出安全范围的数字可能会引起精度丢失</p>\n<h3 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled\"></a>Promise.allSettled</h3><p>用过<code>Promise.all</code>的都知道，这方法有一个比较明显的缺陷，只要其中一个Promise被<code>reject</code>，整个<code>Promise.all</code>就会挂掉，剩下的Promise都会停止执行。例如在一个用户模块中，通过并发异步请求多个版块的数据，只要其中一个服务挂了，其它的版块也就不会拿到数据。很明显，这并不是我们想要的，我们希望并发的任务，不管是异常还是正常，都可以返回对应的状态和值，这样就可以最大限度地保证服务的可访问性。新特性<code>Promise.allSettled</code>就是来满足这一要求的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.allSettled([</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.reject(&#123;<span class=\"attr\">status</span>: <span class=\"string\">'fail'</span>, <span class=\"attr\">msg</span>: <span class=\"string\">'服务异常'</span>&#125;),</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">status</span>: <span class=\"string\">'suc'</span>, <span class=\"attr\">data</span>: &#123;&#125;&#125;),</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(&#123;<span class=\"attr\">status</span>: <span class=\"string\">'suc'</span>, <span class=\"attr\">data</span>: &#123;&#125;&#125;)</span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 0: &#123;status: 'rejected', reason: &#123;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">    * 1: &#123;status: 'fulfilled', value: &#123;&#125;&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">    * 2: &#123;status: 'fulfilled', value: &#123;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当服务异常时，会返回status和reason字段，reason值为reject的值，而当服务正常时，会返回status和value字段。可以通过filter函数来过滤出fulfilled状态的数据，从而实现服务正常的数据渲染</p>\n<h3 id=\"globalThis\"><a href=\"#globalThis\" class=\"headerlink\" title=\"globalThis\"></a>globalThis</h3><p>一般我们很难写出可移植的js代码来访问全局对象，因为在不用的环境全局对象也不同。在web中，全局对象为<code>window</code>、<code>self</code>，在node中，为<code>global</code>，甚至很多时候会使用<code>this</code>来访问全局对象，但是<code>this</code>严重依赖上下文，还会存在各种改变<code>this</code>指向的情况，这会导致更加复杂。而现在，通过一个<code>globalThis</code>就可以轻松获取到当前环境下的全局对象，是不是很清爽？</p>\n<h3 id=\"optional-Chaining\"><a href=\"#optional-Chaining\" class=\"headerlink\" title=\"optional Chaining\"></a>optional Chaining</h3><p>如果我们要使用到多层级对象中的某个属性，为了避免属性不存在时抛出错误，需要经过一系列前置的繁琐的判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (data &amp;&amp; data.options &amp;&amp; data.options.name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = data.options.name</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很麻烦。有了<strong>可选链</strong>新特性后，只需简单一句代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = data?.options?.name</span><br></pre></td></tr></table></figure>\n\n<p>判断<code>?</code>前的属性是否存在，存在才会继续查询<code>.</code>后面的属性。简化了大量前置校验，且更为安全</p>\n<h3 id=\"Nullish-coalescing-Operator\"><a href=\"#Nullish-coalescing-Operator\" class=\"headerlink\" title=\"Nullish coalescing Operator\"></a>Nullish coalescing Operator</h3><p>在对某个变量或对象的属性赋值时，我们会经常做以下类似的操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaultFlag = <span class=\"string\">'default'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    name: defaultFlag || <span class=\"string\">'obj'</span>,</span><br><span class=\"line\">    value: <span class=\"number\">18</span>,</span><br><span class=\"line\">    level: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>defaultFlag</code>转换为布尔值是true的时候，就会采用<code>defaultFlag</code>代表的值，否则采用值<code>obj</code>，但是这会有一些问题，比如值为0的时候，<code>defaultFlag</code>的值就为false，这会跳过0直接赋值为后面的值，如果我们允许0的存在，那这里就会出现预想中的误差。再看新特性<strong>空值合并运算符</strong> <code>??</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> level = obj.level ?? <span class=\"string\">'暂无等级'</span></span><br></pre></td></tr></table></figure>\n\n<p>使用空值合并运算符之后，只有当值为<code>undefined</code>、<code>null</code>的时候，才会跳过，赋值为后面的值</p>"},{"title":"vue3.0-beta尝鲜","_content":"\n## 前言\n\n尤大大前段时间发布了vue3.0-beta版本，现在趁着五一假期尝尝鲜，记录一下。\n\n## vue3设计更新点\n\n先回顾官方提出的vue3.0设计目标\n\n- 更小\n  - 全局 API 和内置组件\n  - 支持 tree-shaking\n  - 常驻代码大小控制在 10kb gzipped 左右\n- 更快\n  - 基于 Proxy 的变动侦测\n  - Virtual DOM 重构\n  - 编译器架构重构，更多的编译时优化\n- 加强API设计一致性\n- 加强TypeScript支持\n- 提高自身可维护性\n  - 代码采用 monorepo 结构，内部分层更清晰\n  - TypeScript 使得外部贡献者更有信心做改动\n- 开放更多底层功能\n\n<!-- more -->\n\n## 开始\n\n### 创建项目\n\n```js\n// 升级vue-cli到4.0版本\ncnpm install -g @vue/cli\n\n// 创建项目（注意，这里的vue版本还是2.x）\nvue create vue-3.0-beta-test\n\n// 切换到项目目录 通过vue add 命令添加3.0版本\nvue add vue-next\n```\n\n然后打开项目，可以看到vue的版本已经变成`^3.0.0-beta.1`，还有一些插件版本的更新和新增了两个插件\n\n![vue升级3.0-beta](/images/vue升级3.0-beta.png)\n\n### 对比项目结构\n\n再从项目的整体结构来看，对比2.x版本基本没有变化，主要看下变化了的`main.js`文件\n\n![main.js](/images/mainjs对比.png)\n\n通过图片可以看到，这里只解构出一个`createApp`函数，因为vue3.0支持`tree-shaking`，可以把每一个用到的API抽取出来，让vue变得更小\n\n### Composition API\n\n原先是叫`Vue-Function-API`，后面经社区意见收集，更改为`Vue-Composition-API`，这里面有几个变化比较大的：\n\n- 生命周期钩子\n- reactive API\n- ref API\n- watch API\n- computed API\n\n#### 生命周期\n\n在3.0中，生命周期发生了很大变化：\n\n| 2.x  | 3.0  |\n| ---- | ---- |\n|  beforeCreate    |   setup   |\n|  created    |   setup   |\n| beforeMount | onBeforeMount |\n| mounted | onMounted |\n| beforeUpdate | onBeforeUpdate |\n| updated | onUpdated |\n| beforeDestroy | onBeforeUnmount |\n| destroyed | onUnmounted |\n\n#### reactive\n\n> 该API作用是创建响应式对象，类似之前在`data`中声明变量\n\n```vue\n// App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n  </div>\n</template>\n\n<script>\nimport { reactive } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    let info = reactive({\n      msg: `vue3.0-beta尝鲜`\n    });\n    return {\n      info\n    };\n  }\n};\n</script>\n```\n\n效果：\n\n![reactive效果](/images/效果图-1.png)\n\n#### ref\n\n> 创建一个包装式对象，含有一个响应式属性value，通过修改value来修改值\n\n```vue\n// App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>{{ tip }}</h3>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    let info = reactive({\n      msg: `vue3.0-beta尝鲜`\n    });\n    let tip = ref(`value of ref`);\n    // 通过修改value属性来修改值\n    tip.value = `change ref of value`;\n    return {\n      info,\n      tip\n    };\n  }\n};\n</script>\n```\n\n效果：\n\n![ref效果](/images/ref效果图.png)\n\n#### 事件处理\n\n3.0没有`methods`对象，也是写在`setup`里面\n\n```vue\n// App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>tip：{{ tip }}</h3>\n    <input v-model=\"inputValue\" />\n    <button @click=\"handleClick\">click me</button>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    let info = reactive({\n      msg: `vue3.0-beta尝鲜`\n    });\n    let tip = ref(`value of ref`);\n    tip.value = `change ref of value`;\n    let inputValue = ref(\"\");\n    const handleClick = () => {\n      tip.value = inputValue.value;\n    };\n    return {\n      info,\n      tip,\n      inputValue,\n      handleClick\n    };\n  }\n};\n</script>\n```\n\n上面写了一个方法，绑定一个点击事件来改变变量`tip`的值，效果如图：\n\n![绑定事件](/images/事件效果图.png)\n\n#### onMounted钩子\n\n我们在vue项目中用得最多的生命钩子就是`created`和`mounted`，在`created`发送请求，接收、处理参数之类，在`mounted`页面渲染后进行相关的业务处理，在上面有提过，现在`beforeCreate`和`created` 都是`setup`了，现在看下新的`onMounted`怎么用：\n\n```vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>tip：{{ tip }}</h3>\n    <input v-model=\"inputValue\" />\n    <button @click=\"handleClick\">click me</button>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref, onMounted } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    // 省略上面例子的代码\n    // ...  \n    onMounted(() => {\n      console.log(`mounted`);\n      // 页面渲染完 获取所有h3元素  \n      let h3List = document.querySelectorAll(\"h3\");\n      console.log({\n        h3List: h3List\n      });\n    });\n    return {\n        // ...\n    };\n  }\n};\n</script>\n\n```\n\n#### computed\n\n```vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>tip：{{ tip }}</h3>\n    <h3>computed num：{{ num }}</h3>\n    <input v-model=\"inputValue\" />\n    <button @click=\"handleClick\">click me</button>\n    <button @click=\"incrementNum\">increment</button>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref, onMounted, computed } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n\t// ...\n    let initNum = ref(0);\n    const incrementNum = () => {\n      initNum.value++;\n    };\n    // 让num成为计算属性\n    let num = computed(() => {\n      return initNum.value * 2;\n    });\n    return {\n      // ...\n      incrementNum,\n      num\n    };\n  }\n};\n</script>\n\n```\n\n看下效果：\n\n![](/images/钩子效果图.png)\n\n### 总结\n\n从上面的例子可以看到，3.0的语法更加简洁精炼！总的来说，3.0会兼容2.x，我们的学习成本基本就只集中在composition这一块，而更具体、更详细的内容，可访问[composition-api](https://composition-api.vuejs.org/#summary)，上面还有很丰富的内容等着我们探索，包括对`TypeScript`的更好支持等。","source":"_posts/vue3.0-beta尝鲜.md","raw":"---\ntitle: vue3.0-beta尝鲜\ncategories:\n - 前端\ntags:\n - vue\n\n---\n\n## 前言\n\n尤大大前段时间发布了vue3.0-beta版本，现在趁着五一假期尝尝鲜，记录一下。\n\n## vue3设计更新点\n\n先回顾官方提出的vue3.0设计目标\n\n- 更小\n  - 全局 API 和内置组件\n  - 支持 tree-shaking\n  - 常驻代码大小控制在 10kb gzipped 左右\n- 更快\n  - 基于 Proxy 的变动侦测\n  - Virtual DOM 重构\n  - 编译器架构重构，更多的编译时优化\n- 加强API设计一致性\n- 加强TypeScript支持\n- 提高自身可维护性\n  - 代码采用 monorepo 结构，内部分层更清晰\n  - TypeScript 使得外部贡献者更有信心做改动\n- 开放更多底层功能\n\n<!-- more -->\n\n## 开始\n\n### 创建项目\n\n```js\n// 升级vue-cli到4.0版本\ncnpm install -g @vue/cli\n\n// 创建项目（注意，这里的vue版本还是2.x）\nvue create vue-3.0-beta-test\n\n// 切换到项目目录 通过vue add 命令添加3.0版本\nvue add vue-next\n```\n\n然后打开项目，可以看到vue的版本已经变成`^3.0.0-beta.1`，还有一些插件版本的更新和新增了两个插件\n\n![vue升级3.0-beta](/images/vue升级3.0-beta.png)\n\n### 对比项目结构\n\n再从项目的整体结构来看，对比2.x版本基本没有变化，主要看下变化了的`main.js`文件\n\n![main.js](/images/mainjs对比.png)\n\n通过图片可以看到，这里只解构出一个`createApp`函数，因为vue3.0支持`tree-shaking`，可以把每一个用到的API抽取出来，让vue变得更小\n\n### Composition API\n\n原先是叫`Vue-Function-API`，后面经社区意见收集，更改为`Vue-Composition-API`，这里面有几个变化比较大的：\n\n- 生命周期钩子\n- reactive API\n- ref API\n- watch API\n- computed API\n\n#### 生命周期\n\n在3.0中，生命周期发生了很大变化：\n\n| 2.x  | 3.0  |\n| ---- | ---- |\n|  beforeCreate    |   setup   |\n|  created    |   setup   |\n| beforeMount | onBeforeMount |\n| mounted | onMounted |\n| beforeUpdate | onBeforeUpdate |\n| updated | onUpdated |\n| beforeDestroy | onBeforeUnmount |\n| destroyed | onUnmounted |\n\n#### reactive\n\n> 该API作用是创建响应式对象，类似之前在`data`中声明变量\n\n```vue\n// App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n  </div>\n</template>\n\n<script>\nimport { reactive } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    let info = reactive({\n      msg: `vue3.0-beta尝鲜`\n    });\n    return {\n      info\n    };\n  }\n};\n</script>\n```\n\n效果：\n\n![reactive效果](/images/效果图-1.png)\n\n#### ref\n\n> 创建一个包装式对象，含有一个响应式属性value，通过修改value来修改值\n\n```vue\n// App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>{{ tip }}</h3>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    let info = reactive({\n      msg: `vue3.0-beta尝鲜`\n    });\n    let tip = ref(`value of ref`);\n    // 通过修改value属性来修改值\n    tip.value = `change ref of value`;\n    return {\n      info,\n      tip\n    };\n  }\n};\n</script>\n```\n\n效果：\n\n![ref效果](/images/ref效果图.png)\n\n#### 事件处理\n\n3.0没有`methods`对象，也是写在`setup`里面\n\n```vue\n// App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>tip：{{ tip }}</h3>\n    <input v-model=\"inputValue\" />\n    <button @click=\"handleClick\">click me</button>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    let info = reactive({\n      msg: `vue3.0-beta尝鲜`\n    });\n    let tip = ref(`value of ref`);\n    tip.value = `change ref of value`;\n    let inputValue = ref(\"\");\n    const handleClick = () => {\n      tip.value = inputValue.value;\n    };\n    return {\n      info,\n      tip,\n      inputValue,\n      handleClick\n    };\n  }\n};\n</script>\n```\n\n上面写了一个方法，绑定一个点击事件来改变变量`tip`的值，效果如图：\n\n![绑定事件](/images/事件效果图.png)\n\n#### onMounted钩子\n\n我们在vue项目中用得最多的生命钩子就是`created`和`mounted`，在`created`发送请求，接收、处理参数之类，在`mounted`页面渲染后进行相关的业务处理，在上面有提过，现在`beforeCreate`和`created` 都是`setup`了，现在看下新的`onMounted`怎么用：\n\n```vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>tip：{{ tip }}</h3>\n    <input v-model=\"inputValue\" />\n    <button @click=\"handleClick\">click me</button>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref, onMounted } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n    // 省略上面例子的代码\n    // ...  \n    onMounted(() => {\n      console.log(`mounted`);\n      // 页面渲染完 获取所有h3元素  \n      let h3List = document.querySelectorAll(\"h3\");\n      console.log({\n        h3List: h3List\n      });\n    });\n    return {\n        // ...\n    };\n  }\n};\n</script>\n\n```\n\n#### computed\n\n```vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <h3>{{ info.msg }}</h3>\n    <h3>tip：{{ tip }}</h3>\n    <h3>computed num：{{ num }}</h3>\n    <input v-model=\"inputValue\" />\n    <button @click=\"handleClick\">click me</button>\n    <button @click=\"incrementNum\">increment</button>\n  </div>\n</template>\n\n<script>\nimport { reactive, ref, onMounted, computed } from \"vue\";\nexport default {\n  name: \"App\",\n  setup() {\n\t// ...\n    let initNum = ref(0);\n    const incrementNum = () => {\n      initNum.value++;\n    };\n    // 让num成为计算属性\n    let num = computed(() => {\n      return initNum.value * 2;\n    });\n    return {\n      // ...\n      incrementNum,\n      num\n    };\n  }\n};\n</script>\n\n```\n\n看下效果：\n\n![](/images/钩子效果图.png)\n\n### 总结\n\n从上面的例子可以看到，3.0的语法更加简洁精炼！总的来说，3.0会兼容2.x，我们的学习成本基本就只集中在composition这一块，而更具体、更详细的内容，可访问[composition-api](https://composition-api.vuejs.org/#summary)，上面还有很丰富的内容等着我们探索，包括对`TypeScript`的更好支持等。","slug":"vue3.0-beta尝鲜","published":1,"date":"2020-05-02T14:07:03.234Z","updated":"2020-05-02T16:59:04.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4kw000bhsuh6xnlcxww","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>尤大大前段时间发布了vue3.0-beta版本，现在趁着五一假期尝尝鲜，记录一下。</p>\n<h2 id=\"vue3设计更新点\"><a href=\"#vue3设计更新点\" class=\"headerlink\" title=\"vue3设计更新点\"></a>vue3设计更新点</h2><p>先回顾官方提出的vue3.0设计目标</p>\n<ul>\n<li>更小<ul>\n<li>全局 API 和内置组件</li>\n<li>支持 tree-shaking</li>\n<li>常驻代码大小控制在 10kb gzipped 左右</li>\n</ul>\n</li>\n<li>更快<ul>\n<li>基于 Proxy 的变动侦测</li>\n<li>Virtual DOM 重构</li>\n<li>编译器架构重构，更多的编译时优化</li>\n</ul>\n</li>\n<li>加强API设计一致性</li>\n<li>加强TypeScript支持</li>\n<li>提高自身可维护性<ul>\n<li>代码采用 monorepo 结构，内部分层更清晰</li>\n<li>TypeScript 使得外部贡献者更有信心做改动</li>\n</ul>\n</li>\n<li>开放更多底层功能</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><figure class=\"highlight js hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 升级vue-cli到4.0版本</span></span><br><span class=\"line\">cnpm install -g @vue/cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 创建项目（注意，这里的vue版本还是2.x）</span></span><br><span class=\"line\">vue create vue<span class=\"hljs-number\">-3.0</span>-beta-test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 切换到项目目录 通过vue add 命令添加3.0版本</span></span><br><span class=\"line\">vue add vue-next</span><br></pre></td></tr></table></figure>\n\n<p>然后打开项目，可以看到vue的版本已经变成<code>^3.0.0-beta.1</code>，还有一些插件版本的更新和新增了两个插件</p>\n<p><img src=\"/images/vue%E5%8D%87%E7%BA%A73.0-beta.png\" alt=\"vue升级3.0-beta\"></p>\n<h3 id=\"对比项目结构\"><a href=\"#对比项目结构\" class=\"headerlink\" title=\"对比项目结构\"></a>对比项目结构</h3><p>再从项目的整体结构来看，对比2.x版本基本没有变化，主要看下变化了的<code>main.js</code>文件</p>\n<p><img src=\"/images/mainjs%E5%AF%B9%E6%AF%94.png\" alt=\"main.js\"></p>\n<p>通过图片可以看到，这里只解构出一个<code>createApp</code>函数，因为vue3.0支持<code>tree-shaking</code>，可以把每一个用到的API抽取出来，让vue变得更小</p>\n<h3 id=\"Composition-API\"><a href=\"#Composition-API\" class=\"headerlink\" title=\"Composition API\"></a>Composition API</h3><p>原先是叫<code>Vue-Function-API</code>，后面经社区意见收集，更改为<code>Vue-Composition-API</code>，这里面有几个变化比较大的：</p>\n<ul>\n<li>生命周期钩子</li>\n<li>reactive API</li>\n<li>ref API</li>\n<li>watch API</li>\n<li>computed API</li>\n</ul>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>在3.0中，生命周期发生了很大变化：</p>\n<table>\n<thead>\n<tr>\n<th>2.x</th>\n<th>3.0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>beforeCreate</td>\n<td>setup</td>\n</tr>\n<tr>\n<td>created</td>\n<td>setup</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>onBeforeMount</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>onMounted</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>onBeforeUpdate</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>onUpdated</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>onBeforeUnmount</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>onUnmounted</td>\n</tr>\n</tbody></table>\n<h4 id=\"reactive\"><a href=\"#reactive\" class=\"headerlink\" title=\"reactive\"></a>reactive</h4><blockquote>\n<p>该API作用是创建响应式对象，类似之前在<code>data</code>中声明变量</p>\n</blockquote>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// App.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    let info = reactive(&#123;</span><br><span class=\"line\">      msg: `vue3.0-beta尝鲜`</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      info</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"/images/%E6%95%88%E6%9E%9C%E5%9B%BE-1.png\" alt=\"reactive效果\"></p>\n<h4 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h4><blockquote>\n<p>创建一个包装式对象，含有一个响应式属性value，通过修改value来修改值</p>\n</blockquote>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// App.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    let info = reactive(&#123;</span><br><span class=\"line\">      msg: `vue3.0-beta尝鲜`</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    let tip = ref(`value of ref`);</span><br><span class=\"line\">    // 通过修改value属性来修改值</span><br><span class=\"line\">    tip.value = `change ref of value`;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      info,</span><br><span class=\"line\">      tip</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"/images/ref%E6%95%88%E6%9E%9C%E5%9B%BE.png\" alt=\"ref效果\"></p>\n<h4 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h4><p>3.0没有<code>methods</code>对象，也是写在<code>setup</code>里面</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// App.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    let info = reactive(&#123;</span><br><span class=\"line\">      msg: `vue3.0-beta尝鲜`</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    let tip = ref(`value of ref`);</span><br><span class=\"line\">    tip.value = `change ref of value`;</span><br><span class=\"line\">    let inputValue = ref(&quot;&quot;);</span><br><span class=\"line\">    const handleClick = () =&gt; &#123;</span><br><span class=\"line\">      tip.value = inputValue.value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      info,</span><br><span class=\"line\">      tip,</span><br><span class=\"line\">      inputValue,</span><br><span class=\"line\">      handleClick</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面写了一个方法，绑定一个点击事件来改变变量<code>tip</code>的值，效果如图：</p>\n<p><img src=\"/images/%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C%E5%9B%BE.png\" alt=\"绑定事件\"></p>\n<h4 id=\"onMounted钩子\"><a href=\"#onMounted钩子\" class=\"headerlink\" title=\"onMounted钩子\"></a>onMounted钩子</h4><p>我们在vue项目中用得最多的生命钩子就是<code>created</code>和<code>mounted</code>，在<code>created</code>发送请求，接收、处理参数之类，在<code>mounted</code>页面渲染后进行相关的业务处理，在上面有提过，现在<code>beforeCreate</code>和<code>created</code> 都是<code>setup</code>了，现在看下新的<code>onMounted</code>怎么用：</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref, onMounted &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    // 省略上面例子的代码</span><br><span class=\"line\">    // ...  </span><br><span class=\"line\">    onMounted(() =&gt; &#123;</span><br><span class=\"line\">      console.log(`mounted`);</span><br><span class=\"line\">      // 页面渲染完 获取所有h3元素  </span><br><span class=\"line\">      let h3List = document.querySelectorAll(&quot;h3&quot;);</span><br><span class=\"line\">      console.log(&#123;</span><br><span class=\"line\">        h3List: h3List</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h4><figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;computed num：&#123;&#123; num &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;incrementNum&quot;&gt;increment&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref, onMounted, computed &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">    let initNum = ref(0);</span><br><span class=\"line\">    const incrementNum = () =&gt; &#123;</span><br><span class=\"line\">      initNum.value++;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 让num成为计算属性</span><br><span class=\"line\">    let num = computed(() =&gt; &#123;</span><br><span class=\"line\">      return initNum.value * 2;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">      incrementNum,</span><br><span class=\"line\">      num</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>看下效果：</p>\n<p><img src=\"/images/%E9%92%A9%E5%AD%90%E6%95%88%E6%9E%9C%E5%9B%BE.png\" alt></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>从上面的例子可以看到，3.0的语法更加简洁精炼！总的来说，3.0会兼容2.x，我们的学习成本基本就只集中在composition这一块，而更具体、更详细的内容，可访问<a href=\"https://composition-api.vuejs.org/#summary\" target=\"_blank\" rel=\"noopener\">composition-api</a>，上面还有很丰富的内容等着我们探索，包括对<code>TypeScript</code>的更好支持等。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>尤大大前段时间发布了vue3.0-beta版本，现在趁着五一假期尝尝鲜，记录一下。</p>\n<h2 id=\"vue3设计更新点\"><a href=\"#vue3设计更新点\" class=\"headerlink\" title=\"vue3设计更新点\"></a>vue3设计更新点</h2><p>先回顾官方提出的vue3.0设计目标</p>\n<ul>\n<li>更小<ul>\n<li>全局 API 和内置组件</li>\n<li>支持 tree-shaking</li>\n<li>常驻代码大小控制在 10kb gzipped 左右</li>\n</ul>\n</li>\n<li>更快<ul>\n<li>基于 Proxy 的变动侦测</li>\n<li>Virtual DOM 重构</li>\n<li>编译器架构重构，更多的编译时优化</li>\n</ul>\n</li>\n<li>加强API设计一致性</li>\n<li>加强TypeScript支持</li>\n<li>提高自身可维护性<ul>\n<li>代码采用 monorepo 结构，内部分层更清晰</li>\n<li>TypeScript 使得外部贡献者更有信心做改动</li>\n</ul>\n</li>\n<li>开放更多底层功能</li>\n</ul>","more":"<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 升级vue-cli到4.0版本</span></span><br><span class=\"line\">cnpm install -g @vue/cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建项目（注意，这里的vue版本还是2.x）</span></span><br><span class=\"line\">vue create vue<span class=\"number\">-3.0</span>-beta-test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 切换到项目目录 通过vue add 命令添加3.0版本</span></span><br><span class=\"line\">vue add vue-next</span><br></pre></td></tr></table></figure>\n\n<p>然后打开项目，可以看到vue的版本已经变成<code>^3.0.0-beta.1</code>，还有一些插件版本的更新和新增了两个插件</p>\n<p><img src=\"/images/vue%E5%8D%87%E7%BA%A73.0-beta.png\" alt=\"vue升级3.0-beta\"></p>\n<h3 id=\"对比项目结构\"><a href=\"#对比项目结构\" class=\"headerlink\" title=\"对比项目结构\"></a>对比项目结构</h3><p>再从项目的整体结构来看，对比2.x版本基本没有变化，主要看下变化了的<code>main.js</code>文件</p>\n<p><img src=\"/images/mainjs%E5%AF%B9%E6%AF%94.png\" alt=\"main.js\"></p>\n<p>通过图片可以看到，这里只解构出一个<code>createApp</code>函数，因为vue3.0支持<code>tree-shaking</code>，可以把每一个用到的API抽取出来，让vue变得更小</p>\n<h3 id=\"Composition-API\"><a href=\"#Composition-API\" class=\"headerlink\" title=\"Composition API\"></a>Composition API</h3><p>原先是叫<code>Vue-Function-API</code>，后面经社区意见收集，更改为<code>Vue-Composition-API</code>，这里面有几个变化比较大的：</p>\n<ul>\n<li>生命周期钩子</li>\n<li>reactive API</li>\n<li>ref API</li>\n<li>watch API</li>\n<li>computed API</li>\n</ul>\n<h4 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h4><p>在3.0中，生命周期发生了很大变化：</p>\n<table>\n<thead>\n<tr>\n<th>2.x</th>\n<th>3.0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>beforeCreate</td>\n<td>setup</td>\n</tr>\n<tr>\n<td>created</td>\n<td>setup</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>onBeforeMount</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>onMounted</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>onBeforeUpdate</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>onUpdated</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>onBeforeUnmount</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>onUnmounted</td>\n</tr>\n</tbody></table>\n<h4 id=\"reactive\"><a href=\"#reactive\" class=\"headerlink\" title=\"reactive\"></a>reactive</h4><blockquote>\n<p>该API作用是创建响应式对象，类似之前在<code>data</code>中声明变量</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// App.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    let info = reactive(&#123;</span><br><span class=\"line\">      msg: `vue3.0-beta尝鲜`</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      info</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"/images/%E6%95%88%E6%9E%9C%E5%9B%BE-1.png\" alt=\"reactive效果\"></p>\n<h4 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h4><blockquote>\n<p>创建一个包装式对象，含有一个响应式属性value，通过修改value来修改值</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// App.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    let info = reactive(&#123;</span><br><span class=\"line\">      msg: `vue3.0-beta尝鲜`</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    let tip = ref(`value of ref`);</span><br><span class=\"line\">    // 通过修改value属性来修改值</span><br><span class=\"line\">    tip.value = `change ref of value`;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      info,</span><br><span class=\"line\">      tip</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"/images/ref%E6%95%88%E6%9E%9C%E5%9B%BE.png\" alt=\"ref效果\"></p>\n<h4 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h4><p>3.0没有<code>methods</code>对象，也是写在<code>setup</code>里面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// App.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    let info = reactive(&#123;</span><br><span class=\"line\">      msg: `vue3.0-beta尝鲜`</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    let tip = ref(`value of ref`);</span><br><span class=\"line\">    tip.value = `change ref of value`;</span><br><span class=\"line\">    let inputValue = ref(&quot;&quot;);</span><br><span class=\"line\">    const handleClick = () =&gt; &#123;</span><br><span class=\"line\">      tip.value = inputValue.value;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      info,</span><br><span class=\"line\">      tip,</span><br><span class=\"line\">      inputValue,</span><br><span class=\"line\">      handleClick</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面写了一个方法，绑定一个点击事件来改变变量<code>tip</code>的值，效果如图：</p>\n<p><img src=\"/images/%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C%E5%9B%BE.png\" alt=\"绑定事件\"></p>\n<h4 id=\"onMounted钩子\"><a href=\"#onMounted钩子\" class=\"headerlink\" title=\"onMounted钩子\"></a>onMounted钩子</h4><p>我们在vue项目中用得最多的生命钩子就是<code>created</code>和<code>mounted</code>，在<code>created</code>发送请求，接收、处理参数之类，在<code>mounted</code>页面渲染后进行相关的业务处理，在上面有提过，现在<code>beforeCreate</code>和<code>created</code> 都是<code>setup</code>了，现在看下新的<code>onMounted</code>怎么用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref, onMounted &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    // 省略上面例子的代码</span><br><span class=\"line\">    // ...  </span><br><span class=\"line\">    onMounted(() =&gt; &#123;</span><br><span class=\"line\">      console.log(`mounted`);</span><br><span class=\"line\">      // 页面渲染完 获取所有h3元素  </span><br><span class=\"line\">      let h3List = document.querySelectorAll(&quot;h3&quot;);</span><br><span class=\"line\">      console.log(&#123;</span><br><span class=\"line\">        h3List: h3List</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;computed num：&#123;&#123; num &#125;&#125;&lt;/h3&gt;</span><br><span class=\"line\">    &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;incrementNum&quot;&gt;increment&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; reactive, ref, onMounted, computed &#125; from &quot;vue&quot;;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;App&quot;,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">    let initNum = ref(0);</span><br><span class=\"line\">    const incrementNum = () =&gt; &#123;</span><br><span class=\"line\">      initNum.value++;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 让num成为计算属性</span><br><span class=\"line\">    let num = computed(() =&gt; &#123;</span><br><span class=\"line\">      return initNum.value * 2;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">      incrementNum,</span><br><span class=\"line\">      num</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>看下效果：</p>\n<p><img src=\"/images/%E9%92%A9%E5%AD%90%E6%95%88%E6%9E%9C%E5%9B%BE.png\" alt></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>从上面的例子可以看到，3.0的语法更加简洁精炼！总的来说，3.0会兼容2.x，我们的学习成本基本就只集中在composition这一块，而更具体、更详细的内容，可访问<a href=\"https://composition-api.vuejs.org/#summary\" target=\"_blank\" rel=\"noopener\">composition-api</a>，上面还有很丰富的内容等着我们探索，包括对<code>TypeScript</code>的更好支持等。</p>"},{"title":"《程序员修炼之道》 -- 务实的哲学","_content":"\n### 前言\n\n《程修道》第一章讲的是务实的哲学，内容的安排觉得很巧妙，不像传统的书籍那样，上来直接跟你说某个概念，而是通过“哲学”一词来表达“务实”本身所具有的高度以及“务实”是给我们带来的是思想和心理层面的改变和进化的，也让读者对务实有更多的兴趣和探索欲。\n\n<!-- more -->\n\n这一章由7部分组成，分别是`人生是你的`、`我的源码被猫吃了`，`软件的熵`，`石头做的汤和煮熟的青蛙`，`够好即可的软件`，`知识组合`和`交流`。\n\n这里挑感触比较多的部分做感想和记录。\n\n### 我的源码被猫吃了\n\n看到这个标题的时候是不是觉得很搞笑，猫竟然能吃源码？？？\n\n现实中猫肯定是没法把源码吃掉的，这个比喻说的是，当下很多找借口、甩锅、不敢担当的现象。\n\n**承担责任**。不管在工作中还是生活中，我们都需要承担责任，责任意味着我们对某事积极认同，当我们决定对一个结果承担责任时，意味着我们将承接相关的义务，当我们在这期间犯了错，做了错误的决定，写了一个潜藏的BUG导致线上事故，我们都要诚实地去承担，并且尝试给出选择，给出解决方案。\n\n**提供选择，别找借口**。我们很多人经常在出现错误的时候找各种各样的借口来搪塞老板、领导或者同事，想以此来减轻自己犯错后应承担的后果：为什么项目会延期，为什么线上会出现大BUG。如果想找借口，最好是在心里把跟领导的对话过一遍，看看你给出的借口有没有说服力，如果没有，还是老老实实地考虑“有没有试过这样的方案，或者另外的方案”，在找借口前，还有没有其它解决方案可以试试的？我觉得最基本的处理方式，应该是承担责任，说出原因，然后提供解决方案给领导选择，而不是把问题抛给领导。\n\n**更好地改进**。如果真的出现问题，我们最终目的还是要解决问题。是一段老代码引起的坑？那么是不是要进行优化或者重构，跟领导讲一下重构的价值；如果是业务不熟悉造成的，我们是不是应该花多一些时间去了解业务，了解原型；为了防止错误的再次发生，我们可不可以引入更好的测试或者增加一些自动化流程；等等这些，都是一些改进的方案。\n\n### 软件的熵\n\n`熵`是物理学的术语，它定义了一个系统的“**无序**”即混乱程度，熵越大，则代表项目越混乱越难以维护，正在“**腐烂**”。\n\n有很多个因素可以导致软件腐烂，而文中讲了最重要的一个因素，“**项目工作中的心理性状态**”。\n\n这个词看起来可能比较难以理解，我们先看一些对比的例子：\n\n有的项目安排了合理的计划和合适的开发人员，但项目还是可能在生命周期中逐渐荒废，腐烂；有的项目正在经历巨大的困难和挫折，但是却成功地对抗了系统的无序化倾向。\n\n为什么有这种反差存在？文中有一个“破窗”理论“\n\n> 在一栋建筑中有一扇破损的窗户，只要有一段时间不去修理，建筑中的居民就会产生一种潜移默化的被遗弃的感觉--没人在乎这个破窗和这栋建筑。然后，其它窗户也开始损坏，居民开始乱丢垃圾，墙上开始出现涂鸦，建筑开始出现严重的结构性破坏。建筑的损坏程度足以打消居民想修复的期望，被遗弃的感觉最终也变成了现实。\n\n这个“破窗”为什么会造成这样的影响，心理学家的研究表明，负面情绪是会传染的，无视一个明显损坏的东西，会强化这样的观念：**没人在乎，看来可以不用管不用去修好它**。\n\n**不要放任破窗**。这种破窗现象，对应到了我们软件开发中一些问题，`糟糕的设计`、`错误的决定`、`不规范的、劣质的代码`等。如果项目中存在这样的情况，每发现一个最好赶紧修一个，如果项目的版本没有安排到这块范围，那最好把它**标记**起来，或者注释一下，说明这里存在的问题，预防进一步的损害发生。如果团队中没人有这样的想法， 觉得代码烂就烂了，那这种情绪就不单会从现在开始传播，就连躺在项目里的烂代码也会给后来的新人一种“烂”误导。只有保持良好的破窗修复习惯，我们的系统才可以稳健运行，漠视只会加速系统的腐烂，安排再合理的开发计划和技术人员，也无法逃离熵的制裁。\n\n**举个自己的栗子**。刚进入团队的时候，我会仔细阅读团队中已有的技术规范文档，一方面是让自己的开发习惯尽量跟团队的规范保持一致，另一个是避免一些沟通、合作上的问题，而在刚接手已有系统的开发时，我记得第一次我很小心，小心翼翼地观察项目中代码的写法，文件创建规范，特别生怕自己一不小心，就搞了个“破窗”。现在回想起来，我这方面的小心翼翼还是值得的，虽然一开始会花费很多时间。\n\n<---- 2020-05-12 添加 ------>\n\n### 交流\n\n> 我认为被人从头打量到脚总比被人视而不见要好。 ——梅·韦斯特 电影：《九十岁的美女》\n\n我们可以细细品味韦斯特女士的这句话：只拥有是不够的，还是学会如何包装。即使拥有最好的想法，漂亮的代码，务实的思想，如果不懂得和别人交流，最终都无法落地，孕育出果实。\n\n交流这部分本来是在第一章最后的内容，今晚拎出来记录主要是想起一件事情，颇有感触：技术人员A同学需要对接其它分公司的同事，让他们提供技术支持某块业务，本来这事没那么复杂，就是沟通好A这边的业务需求和具体需要哪些技术支持，然后分公司的同事B提供相应的技术支持就OK了。但是就是这么不复杂的事情，足足聊了好几天，期间还不断拉各位大佬进群，导致最后大佬都发话不满意了。\n\n是业务太复杂，涉及的东西太多吗？并不然，看整个沟通过程总结下来就是一个点：“表达不清晰”。A同事没有清晰地表达自己的需求，B同事没有清晰表达自己的问题，导致双方沟通了很长时间，还引发领导的不满。这就是交流的问题。\n\n**明白自己想说什么**。在我们日常沟通、更正式的商务沟通中，可能整理思绪是一件比较困难的事情，所以一开始我们可以计划好我们想表达的内容，然后写一个大纲，自己对着大纲去描述，最后问自己，这份大纲能清晰地向我们沟通的对象传达我们的想法吗？如果不行，就得继续提炼，反复提炼。还有可以准备多个表达的策略，我们的沟通对象可能是产品，技术人员，用户，不同的人群对我们的话术的理解是不一致的，所以我们还需要针对不同的人群，准备不同的沟通策略。\n\n**沟通的时机**。上述事例沟通失败的重要原因之一，还有沟通的时机。B同事有紧急的任务在处理，而A同事还是选择在这个时间点找同事沟通，毫无疑问，B同事处理优先级不在于这一块，所以存在了一个情况：A在催，B没空，A开始觉得B对这件事不上心，B开始觉得A不懂变通，咄咄逼人，最后双方也都稍微带着点情绪在沟通。沟通选择的时机在我们日常中也是很重要的，沟通的时候也要尽量考虑沟通双方当前事项的优先级，避免谈而不得。","source":"_posts/《程序员修炼之道》--务实的哲学.md","raw":"---\ntitle: 《程序员修炼之道》 -- 务实的哲学\ncategories:\n - 代码人生\ntags:\n - 务实\n\n---\n\n### 前言\n\n《程修道》第一章讲的是务实的哲学，内容的安排觉得很巧妙，不像传统的书籍那样，上来直接跟你说某个概念，而是通过“哲学”一词来表达“务实”本身所具有的高度以及“务实”是给我们带来的是思想和心理层面的改变和进化的，也让读者对务实有更多的兴趣和探索欲。\n\n<!-- more -->\n\n这一章由7部分组成，分别是`人生是你的`、`我的源码被猫吃了`，`软件的熵`，`石头做的汤和煮熟的青蛙`，`够好即可的软件`，`知识组合`和`交流`。\n\n这里挑感触比较多的部分做感想和记录。\n\n### 我的源码被猫吃了\n\n看到这个标题的时候是不是觉得很搞笑，猫竟然能吃源码？？？\n\n现实中猫肯定是没法把源码吃掉的，这个比喻说的是，当下很多找借口、甩锅、不敢担当的现象。\n\n**承担责任**。不管在工作中还是生活中，我们都需要承担责任，责任意味着我们对某事积极认同，当我们决定对一个结果承担责任时，意味着我们将承接相关的义务，当我们在这期间犯了错，做了错误的决定，写了一个潜藏的BUG导致线上事故，我们都要诚实地去承担，并且尝试给出选择，给出解决方案。\n\n**提供选择，别找借口**。我们很多人经常在出现错误的时候找各种各样的借口来搪塞老板、领导或者同事，想以此来减轻自己犯错后应承担的后果：为什么项目会延期，为什么线上会出现大BUG。如果想找借口，最好是在心里把跟领导的对话过一遍，看看你给出的借口有没有说服力，如果没有，还是老老实实地考虑“有没有试过这样的方案，或者另外的方案”，在找借口前，还有没有其它解决方案可以试试的？我觉得最基本的处理方式，应该是承担责任，说出原因，然后提供解决方案给领导选择，而不是把问题抛给领导。\n\n**更好地改进**。如果真的出现问题，我们最终目的还是要解决问题。是一段老代码引起的坑？那么是不是要进行优化或者重构，跟领导讲一下重构的价值；如果是业务不熟悉造成的，我们是不是应该花多一些时间去了解业务，了解原型；为了防止错误的再次发生，我们可不可以引入更好的测试或者增加一些自动化流程；等等这些，都是一些改进的方案。\n\n### 软件的熵\n\n`熵`是物理学的术语，它定义了一个系统的“**无序**”即混乱程度，熵越大，则代表项目越混乱越难以维护，正在“**腐烂**”。\n\n有很多个因素可以导致软件腐烂，而文中讲了最重要的一个因素，“**项目工作中的心理性状态**”。\n\n这个词看起来可能比较难以理解，我们先看一些对比的例子：\n\n有的项目安排了合理的计划和合适的开发人员，但项目还是可能在生命周期中逐渐荒废，腐烂；有的项目正在经历巨大的困难和挫折，但是却成功地对抗了系统的无序化倾向。\n\n为什么有这种反差存在？文中有一个“破窗”理论“\n\n> 在一栋建筑中有一扇破损的窗户，只要有一段时间不去修理，建筑中的居民就会产生一种潜移默化的被遗弃的感觉--没人在乎这个破窗和这栋建筑。然后，其它窗户也开始损坏，居民开始乱丢垃圾，墙上开始出现涂鸦，建筑开始出现严重的结构性破坏。建筑的损坏程度足以打消居民想修复的期望，被遗弃的感觉最终也变成了现实。\n\n这个“破窗”为什么会造成这样的影响，心理学家的研究表明，负面情绪是会传染的，无视一个明显损坏的东西，会强化这样的观念：**没人在乎，看来可以不用管不用去修好它**。\n\n**不要放任破窗**。这种破窗现象，对应到了我们软件开发中一些问题，`糟糕的设计`、`错误的决定`、`不规范的、劣质的代码`等。如果项目中存在这样的情况，每发现一个最好赶紧修一个，如果项目的版本没有安排到这块范围，那最好把它**标记**起来，或者注释一下，说明这里存在的问题，预防进一步的损害发生。如果团队中没人有这样的想法， 觉得代码烂就烂了，那这种情绪就不单会从现在开始传播，就连躺在项目里的烂代码也会给后来的新人一种“烂”误导。只有保持良好的破窗修复习惯，我们的系统才可以稳健运行，漠视只会加速系统的腐烂，安排再合理的开发计划和技术人员，也无法逃离熵的制裁。\n\n**举个自己的栗子**。刚进入团队的时候，我会仔细阅读团队中已有的技术规范文档，一方面是让自己的开发习惯尽量跟团队的规范保持一致，另一个是避免一些沟通、合作上的问题，而在刚接手已有系统的开发时，我记得第一次我很小心，小心翼翼地观察项目中代码的写法，文件创建规范，特别生怕自己一不小心，就搞了个“破窗”。现在回想起来，我这方面的小心翼翼还是值得的，虽然一开始会花费很多时间。\n\n<---- 2020-05-12 添加 ------>\n\n### 交流\n\n> 我认为被人从头打量到脚总比被人视而不见要好。 ——梅·韦斯特 电影：《九十岁的美女》\n\n我们可以细细品味韦斯特女士的这句话：只拥有是不够的，还是学会如何包装。即使拥有最好的想法，漂亮的代码，务实的思想，如果不懂得和别人交流，最终都无法落地，孕育出果实。\n\n交流这部分本来是在第一章最后的内容，今晚拎出来记录主要是想起一件事情，颇有感触：技术人员A同学需要对接其它分公司的同事，让他们提供技术支持某块业务，本来这事没那么复杂，就是沟通好A这边的业务需求和具体需要哪些技术支持，然后分公司的同事B提供相应的技术支持就OK了。但是就是这么不复杂的事情，足足聊了好几天，期间还不断拉各位大佬进群，导致最后大佬都发话不满意了。\n\n是业务太复杂，涉及的东西太多吗？并不然，看整个沟通过程总结下来就是一个点：“表达不清晰”。A同事没有清晰地表达自己的需求，B同事没有清晰表达自己的问题，导致双方沟通了很长时间，还引发领导的不满。这就是交流的问题。\n\n**明白自己想说什么**。在我们日常沟通、更正式的商务沟通中，可能整理思绪是一件比较困难的事情，所以一开始我们可以计划好我们想表达的内容，然后写一个大纲，自己对着大纲去描述，最后问自己，这份大纲能清晰地向我们沟通的对象传达我们的想法吗？如果不行，就得继续提炼，反复提炼。还有可以准备多个表达的策略，我们的沟通对象可能是产品，技术人员，用户，不同的人群对我们的话术的理解是不一致的，所以我们还需要针对不同的人群，准备不同的沟通策略。\n\n**沟通的时机**。上述事例沟通失败的重要原因之一，还有沟通的时机。B同事有紧急的任务在处理，而A同事还是选择在这个时间点找同事沟通，毫无疑问，B同事处理优先级不在于这一块，所以存在了一个情况：A在催，B没空，A开始觉得B对这件事不上心，B开始觉得A不懂变通，咄咄逼人，最后双方也都稍微带着点情绪在沟通。沟通选择的时机在我们日常中也是很重要的，沟通的时候也要尽量考虑沟通双方当前事项的优先级，避免谈而不得。","slug":"《程序员修炼之道》--务实的哲学","published":1,"date":"2020-05-09T15:27:09.847Z","updated":"2020-05-24T15:17:50.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4l0000chsuhpmazev5v","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>《程修道》第一章讲的是务实的哲学，内容的安排觉得很巧妙，不像传统的书籍那样，上来直接跟你说某个概念，而是通过“哲学”一词来表达“务实”本身所具有的高度以及“务实”是给我们带来的是思想和心理层面的改变和进化的，也让读者对务实有更多的兴趣和探索欲。</p>\n<a id=\"more\"></a>\n\n<p>这一章由7部分组成，分别是<code>人生是你的</code>、<code>我的源码被猫吃了</code>，<code>软件的熵</code>，<code>石头做的汤和煮熟的青蛙</code>，<code>够好即可的软件</code>，<code>知识组合</code>和<code>交流</code>。</p>\n<p>这里挑感触比较多的部分做感想和记录。</p>\n<h3 id=\"我的源码被猫吃了\"><a href=\"#我的源码被猫吃了\" class=\"headerlink\" title=\"我的源码被猫吃了\"></a>我的源码被猫吃了</h3><p>看到这个标题的时候是不是觉得很搞笑，猫竟然能吃源码？？？</p>\n<p>现实中猫肯定是没法把源码吃掉的，这个比喻说的是，当下很多找借口、甩锅、不敢担当的现象。</p>\n<p><strong>承担责任</strong>。不管在工作中还是生活中，我们都需要承担责任，责任意味着我们对某事积极认同，当我们决定对一个结果承担责任时，意味着我们将承接相关的义务，当我们在这期间犯了错，做了错误的决定，写了一个潜藏的BUG导致线上事故，我们都要诚实地去承担，并且尝试给出选择，给出解决方案。</p>\n<p><strong>提供选择，别找借口</strong>。我们很多人经常在出现错误的时候找各种各样的借口来搪塞老板、领导或者同事，想以此来减轻自己犯错后应承担的后果：为什么项目会延期，为什么线上会出现大BUG。如果想找借口，最好是在心里把跟领导的对话过一遍，看看你给出的借口有没有说服力，如果没有，还是老老实实地考虑“有没有试过这样的方案，或者另外的方案”，在找借口前，还有没有其它解决方案可以试试的？我觉得最基本的处理方式，应该是承担责任，说出原因，然后提供解决方案给领导选择，而不是把问题抛给领导。</p>\n<p><strong>更好地改进</strong>。如果真的出现问题，我们最终目的还是要解决问题。是一段老代码引起的坑？那么是不是要进行优化或者重构，跟领导讲一下重构的价值；如果是业务不熟悉造成的，我们是不是应该花多一些时间去了解业务，了解原型；为了防止错误的再次发生，我们可不可以引入更好的测试或者增加一些自动化流程；等等这些，都是一些改进的方案。</p>\n<h3 id=\"软件的熵\"><a href=\"#软件的熵\" class=\"headerlink\" title=\"软件的熵\"></a>软件的熵</h3><p><code>熵</code>是物理学的术语，它定义了一个系统的“<strong>无序</strong>”即混乱程度，熵越大，则代表项目越混乱越难以维护，正在“<strong>腐烂</strong>”。</p>\n<p>有很多个因素可以导致软件腐烂，而文中讲了最重要的一个因素，“<strong>项目工作中的心理性状态</strong>”。</p>\n<p>这个词看起来可能比较难以理解，我们先看一些对比的例子：</p>\n<p>有的项目安排了合理的计划和合适的开发人员，但项目还是可能在生命周期中逐渐荒废，腐烂；有的项目正在经历巨大的困难和挫折，但是却成功地对抗了系统的无序化倾向。</p>\n<p>为什么有这种反差存在？文中有一个“破窗”理论“</p>\n<blockquote>\n<p>在一栋建筑中有一扇破损的窗户，只要有一段时间不去修理，建筑中的居民就会产生一种潜移默化的被遗弃的感觉–没人在乎这个破窗和这栋建筑。然后，其它窗户也开始损坏，居民开始乱丢垃圾，墙上开始出现涂鸦，建筑开始出现严重的结构性破坏。建筑的损坏程度足以打消居民想修复的期望，被遗弃的感觉最终也变成了现实。</p>\n</blockquote>\n<p>这个“破窗”为什么会造成这样的影响，心理学家的研究表明，负面情绪是会传染的，无视一个明显损坏的东西，会强化这样的观念：<strong>没人在乎，看来可以不用管不用去修好它</strong>。</p>\n<p><strong>不要放任破窗</strong>。这种破窗现象，对应到了我们软件开发中一些问题，<code>糟糕的设计</code>、<code>错误的决定</code>、<code>不规范的、劣质的代码</code>等。如果项目中存在这样的情况，每发现一个最好赶紧修一个，如果项目的版本没有安排到这块范围，那最好把它<strong>标记</strong>起来，或者注释一下，说明这里存在的问题，预防进一步的损害发生。如果团队中没人有这样的想法， 觉得代码烂就烂了，那这种情绪就不单会从现在开始传播，就连躺在项目里的烂代码也会给后来的新人一种“烂”误导。只有保持良好的破窗修复习惯，我们的系统才可以稳健运行，漠视只会加速系统的腐烂，安排再合理的开发计划和技术人员，也无法逃离熵的制裁。</p>\n<p><strong>举个自己的栗子</strong>。刚进入团队的时候，我会仔细阅读团队中已有的技术规范文档，一方面是让自己的开发习惯尽量跟团队的规范保持一致，另一个是避免一些沟通、合作上的问题，而在刚接手已有系统的开发时，我记得第一次我很小心，小心翼翼地观察项目中代码的写法，文件创建规范，特别生怕自己一不小心，就搞了个“破窗”。现在回想起来，我这方面的小心翼翼还是值得的，虽然一开始会花费很多时间。</p>\n<p>&lt;—- 2020-05-12 添加 ——&gt;</p>\n<h3 id=\"交流\"><a href=\"#交流\" class=\"headerlink\" title=\"交流\"></a>交流</h3><blockquote>\n<p>我认为被人从头打量到脚总比被人视而不见要好。 ——梅·韦斯特 电影：《九十岁的美女》</p>\n</blockquote>\n<p>我们可以细细品味韦斯特女士的这句话：只拥有是不够的，还是学会如何包装。即使拥有最好的想法，漂亮的代码，务实的思想，如果不懂得和别人交流，最终都无法落地，孕育出果实。</p>\n<p>交流这部分本来是在第一章最后的内容，今晚拎出来记录主要是想起一件事情，颇有感触：技术人员A同学需要对接其它分公司的同事，让他们提供技术支持某块业务，本来这事没那么复杂，就是沟通好A这边的业务需求和具体需要哪些技术支持，然后分公司的同事B提供相应的技术支持就OK了。但是就是这么不复杂的事情，足足聊了好几天，期间还不断拉各位大佬进群，导致最后大佬都发话不满意了。</p>\n<p>是业务太复杂，涉及的东西太多吗？并不然，看整个沟通过程总结下来就是一个点：“表达不清晰”。A同事没有清晰地表达自己的需求，B同事没有清晰表达自己的问题，导致双方沟通了很长时间，还引发领导的不满。这就是交流的问题。</p>\n<p><strong>明白自己想说什么</strong>。在我们日常沟通、更正式的商务沟通中，可能整理思绪是一件比较困难的事情，所以一开始我们可以计划好我们想表达的内容，然后写一个大纲，自己对着大纲去描述，最后问自己，这份大纲能清晰地向我们沟通的对象传达我们的想法吗？如果不行，就得继续提炼，反复提炼。还有可以准备多个表达的策略，我们的沟通对象可能是产品，技术人员，用户，不同的人群对我们的话术的理解是不一致的，所以我们还需要针对不同的人群，准备不同的沟通策略。</p>\n<p><strong>沟通的时机</strong>。上述事例沟通失败的重要原因之一，还有沟通的时机。B同事有紧急的任务在处理，而A同事还是选择在这个时间点找同事沟通，毫无疑问，B同事处理优先级不在于这一块，所以存在了一个情况：A在催，B没空，A开始觉得B对这件事不上心，B开始觉得A不懂变通，咄咄逼人，最后双方也都稍微带着点情绪在沟通。沟通选择的时机在我们日常中也是很重要的，沟通的时候也要尽量考虑沟通双方当前事项的优先级，避免谈而不得。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>《程修道》第一章讲的是务实的哲学，内容的安排觉得很巧妙，不像传统的书籍那样，上来直接跟你说某个概念，而是通过“哲学”一词来表达“务实”本身所具有的高度以及“务实”是给我们带来的是思想和心理层面的改变和进化的，也让读者对务实有更多的兴趣和探索欲。</p>","more":"<p>这一章由7部分组成，分别是<code>人生是你的</code>、<code>我的源码被猫吃了</code>，<code>软件的熵</code>，<code>石头做的汤和煮熟的青蛙</code>，<code>够好即可的软件</code>，<code>知识组合</code>和<code>交流</code>。</p>\n<p>这里挑感触比较多的部分做感想和记录。</p>\n<h3 id=\"我的源码被猫吃了\"><a href=\"#我的源码被猫吃了\" class=\"headerlink\" title=\"我的源码被猫吃了\"></a>我的源码被猫吃了</h3><p>看到这个标题的时候是不是觉得很搞笑，猫竟然能吃源码？？？</p>\n<p>现实中猫肯定是没法把源码吃掉的，这个比喻说的是，当下很多找借口、甩锅、不敢担当的现象。</p>\n<p><strong>承担责任</strong>。不管在工作中还是生活中，我们都需要承担责任，责任意味着我们对某事积极认同，当我们决定对一个结果承担责任时，意味着我们将承接相关的义务，当我们在这期间犯了错，做了错误的决定，写了一个潜藏的BUG导致线上事故，我们都要诚实地去承担，并且尝试给出选择，给出解决方案。</p>\n<p><strong>提供选择，别找借口</strong>。我们很多人经常在出现错误的时候找各种各样的借口来搪塞老板、领导或者同事，想以此来减轻自己犯错后应承担的后果：为什么项目会延期，为什么线上会出现大BUG。如果想找借口，最好是在心里把跟领导的对话过一遍，看看你给出的借口有没有说服力，如果没有，还是老老实实地考虑“有没有试过这样的方案，或者另外的方案”，在找借口前，还有没有其它解决方案可以试试的？我觉得最基本的处理方式，应该是承担责任，说出原因，然后提供解决方案给领导选择，而不是把问题抛给领导。</p>\n<p><strong>更好地改进</strong>。如果真的出现问题，我们最终目的还是要解决问题。是一段老代码引起的坑？那么是不是要进行优化或者重构，跟领导讲一下重构的价值；如果是业务不熟悉造成的，我们是不是应该花多一些时间去了解业务，了解原型；为了防止错误的再次发生，我们可不可以引入更好的测试或者增加一些自动化流程；等等这些，都是一些改进的方案。</p>\n<h3 id=\"软件的熵\"><a href=\"#软件的熵\" class=\"headerlink\" title=\"软件的熵\"></a>软件的熵</h3><p><code>熵</code>是物理学的术语，它定义了一个系统的“<strong>无序</strong>”即混乱程度，熵越大，则代表项目越混乱越难以维护，正在“<strong>腐烂</strong>”。</p>\n<p>有很多个因素可以导致软件腐烂，而文中讲了最重要的一个因素，“<strong>项目工作中的心理性状态</strong>”。</p>\n<p>这个词看起来可能比较难以理解，我们先看一些对比的例子：</p>\n<p>有的项目安排了合理的计划和合适的开发人员，但项目还是可能在生命周期中逐渐荒废，腐烂；有的项目正在经历巨大的困难和挫折，但是却成功地对抗了系统的无序化倾向。</p>\n<p>为什么有这种反差存在？文中有一个“破窗”理论“</p>\n<blockquote>\n<p>在一栋建筑中有一扇破损的窗户，只要有一段时间不去修理，建筑中的居民就会产生一种潜移默化的被遗弃的感觉–没人在乎这个破窗和这栋建筑。然后，其它窗户也开始损坏，居民开始乱丢垃圾，墙上开始出现涂鸦，建筑开始出现严重的结构性破坏。建筑的损坏程度足以打消居民想修复的期望，被遗弃的感觉最终也变成了现实。</p>\n</blockquote>\n<p>这个“破窗”为什么会造成这样的影响，心理学家的研究表明，负面情绪是会传染的，无视一个明显损坏的东西，会强化这样的观念：<strong>没人在乎，看来可以不用管不用去修好它</strong>。</p>\n<p><strong>不要放任破窗</strong>。这种破窗现象，对应到了我们软件开发中一些问题，<code>糟糕的设计</code>、<code>错误的决定</code>、<code>不规范的、劣质的代码</code>等。如果项目中存在这样的情况，每发现一个最好赶紧修一个，如果项目的版本没有安排到这块范围，那最好把它<strong>标记</strong>起来，或者注释一下，说明这里存在的问题，预防进一步的损害发生。如果团队中没人有这样的想法， 觉得代码烂就烂了，那这种情绪就不单会从现在开始传播，就连躺在项目里的烂代码也会给后来的新人一种“烂”误导。只有保持良好的破窗修复习惯，我们的系统才可以稳健运行，漠视只会加速系统的腐烂，安排再合理的开发计划和技术人员，也无法逃离熵的制裁。</p>\n<p><strong>举个自己的栗子</strong>。刚进入团队的时候，我会仔细阅读团队中已有的技术规范文档，一方面是让自己的开发习惯尽量跟团队的规范保持一致，另一个是避免一些沟通、合作上的问题，而在刚接手已有系统的开发时，我记得第一次我很小心，小心翼翼地观察项目中代码的写法，文件创建规范，特别生怕自己一不小心，就搞了个“破窗”。现在回想起来，我这方面的小心翼翼还是值得的，虽然一开始会花费很多时间。</p>\n<p>&lt;—- 2020-05-12 添加 ——&gt;</p>\n<h3 id=\"交流\"><a href=\"#交流\" class=\"headerlink\" title=\"交流\"></a>交流</h3><blockquote>\n<p>我认为被人从头打量到脚总比被人视而不见要好。 ——梅·韦斯特 电影：《九十岁的美女》</p>\n</blockquote>\n<p>我们可以细细品味韦斯特女士的这句话：只拥有是不够的，还是学会如何包装。即使拥有最好的想法，漂亮的代码，务实的思想，如果不懂得和别人交流，最终都无法落地，孕育出果实。</p>\n<p>交流这部分本来是在第一章最后的内容，今晚拎出来记录主要是想起一件事情，颇有感触：技术人员A同学需要对接其它分公司的同事，让他们提供技术支持某块业务，本来这事没那么复杂，就是沟通好A这边的业务需求和具体需要哪些技术支持，然后分公司的同事B提供相应的技术支持就OK了。但是就是这么不复杂的事情，足足聊了好几天，期间还不断拉各位大佬进群，导致最后大佬都发话不满意了。</p>\n<p>是业务太复杂，涉及的东西太多吗？并不然，看整个沟通过程总结下来就是一个点：“表达不清晰”。A同事没有清晰地表达自己的需求，B同事没有清晰表达自己的问题，导致双方沟通了很长时间，还引发领导的不满。这就是交流的问题。</p>\n<p><strong>明白自己想说什么</strong>。在我们日常沟通、更正式的商务沟通中，可能整理思绪是一件比较困难的事情，所以一开始我们可以计划好我们想表达的内容，然后写一个大纲，自己对着大纲去描述，最后问自己，这份大纲能清晰地向我们沟通的对象传达我们的想法吗？如果不行，就得继续提炼，反复提炼。还有可以准备多个表达的策略，我们的沟通对象可能是产品，技术人员，用户，不同的人群对我们的话术的理解是不一致的，所以我们还需要针对不同的人群，准备不同的沟通策略。</p>\n<p><strong>沟通的时机</strong>。上述事例沟通失败的重要原因之一，还有沟通的时机。B同事有紧急的任务在处理，而A同事还是选择在这个时间点找同事沟通，毫无疑问，B同事处理优先级不在于这一块，所以存在了一个情况：A在催，B没空，A开始觉得B对这件事不上心，B开始觉得A不懂变通，咄咄逼人，最后双方也都稍微带着点情绪在沟通。沟通选择的时机在我们日常中也是很重要的，沟通的时候也要尽量考虑沟通双方当前事项的优先级，避免谈而不得。</p>"},{"title":"《程序员修炼之道》 -- 务实的方法（上）","_content":"\n### 前言\n\n周五啦，忙碌了一个星期，趁着周五晚上听听轻音乐，看会书，写写感想，放松一下~\n\n《程修道》在第一章由务实的哲学开头之后，在接下来的第二章就开始讲务实的方法，由思想理念到操作实践。\n\n务实的方法总共有**8**部分，`优秀设计的精髓`、`DRY-邪恶的重复`、`正交性`、`可逆性`、`曳光弹`、`原型与便签`、`领域语言`、`估算`。\n\n第二章的内容很丰富也更需要深入去阅读品味，今晚先记录一部分。\n\n<!-- more -->\n\n### 优秀设计的精髓\n\n这一部分，可以说是触及软件开发核心的至关重要主题，后面的7部分内容，都是由此来进行更为详细的展开。\n\n**优秀的设计比糟糕的设计更容易变更**。我们在日常经常有谈到怎样设计好的软件，最后总的概括，能适应使用者的就是好的设计。对于我们的代码而言，就是要顺应变化，这个顺应变化怎么理解呢，书中提到了一个重要的原则--**ETC（Easier To Change）原则**，更容易变更。很多设计原则，基本都是ETC原则的特例。\n\n为什么代码要解耦，因为通过隔离关注焦点，可以让每一部分都容易变更。\n\n为什么单一职责原则很有用？因为一个需求变化仅体现为某个单一模块上的一个对应变化。\n\n为什么良好的命名规则很重要？因为好的命名可以使打代码更容易阅读，而我们必须通过阅读才能做到变更。\n\n**ETC应当是一种价值观念，而不是一条规则**。价值观念跟规则的区别在于，规则是用来规范大家的行为，是要遵守的，有一种被动、甚至是束缚的感知。而价值观念是一种思维向导，它会帮助我们去思考，去做决定：哪些是该做的，哪些是不该做的，我们应该把ETC当成跟其它的价值观念一样，像“八荣八耻”，让它漂浮在我们的思维当中，当我们开始思考做决定时，它能微妙地将我们推向正确的方向。\n\n**怎样做到将ETC作为价值观念？**书中作者给出来他们这些年总结的一些经验：一开始需要一点有意识的强化。我们可能花几个星期的时间来有意识地问自己：“刚刚做的代码设计是让整个系统更容易变更还是更难改变？”当我们提交代码的时候问一遍，写测试的时候问一遍，当我们修复BUG的时候再问一遍，甚至要反思这个BUG的出现是不是可以通过更好的设计来规避。\n\n**更进一步**。除了上述作者给出的经验建议，我们还可以做得更好。第一点是让我们的代码坚持保持**解耦**和**内聚**、让我们的代码容易替换，即我们常说的**可配置化**。可配置化的好处就是不管以后有什么需求改变，我们都可以较为容易地去变更，而无需花费精力去重写。第二点是培养直觉，要经常记录我们遇到的问题、可以做的选择、可以怎样改变的猜测，以便我们可以进行快速的回顾和反思，下次遇到同样的问题，可以在脑海里快速提炼出方案。\n\n<--- 2020.05.16 添加 --->\n\n### 正交性\n\n“**正交性**”是从几何中借用来的术语。若两条直线相交成直角，它们就是正交的。用向量术语来说，这两条直线互不依赖。\n\n在计算科学中，正交就代表**独立性**或者**解耦性**。\n\n**消除不相关事物之间的影响**。组件化这个概念在如今已经是一个普遍的概念，很多大厂也都有开源的组件库。我们在写组件的时候，都是希望我们的组件是独立自主，有单一、清晰的定义，能够简单、重复地使用。当我们变更某一个组件的时候，不会对其它组件有很大影响甚至是没有影响。从这角度来看，正交性的系统主要有两个方面的好处：**提高生产力**以及**降低风险**。\n\n**提高生产力**\n\n- 正交的方法促进了复用。前端组件化最基本的定义，就是组件都是职责明确、定位清晰的，像表格组件、时间组件等等，根据不同的职责，能够跟不同的组件进行搭配复用。越是低耦合，我们需要重新配置和变更的地方就越少，也就越容易进行。\n- 节省开发、测试时间。\n\n**减少风险**\n\n- 代码中的“生病”的部分被分隔开。如果一个组件出问题了，我们只需改动组件某部分，减少大幅改动的风险。\n- 系统更加稳健。这样的系统，就像天气预报一样，局部有阵雨，局部多云一样，哪一块“天气不好”，我们只需对特定的部分修复，不会对系统造成影响。\n- 更有意思的一点，就是不会受特定供应商的束缚。我们的系统可能会对外对接一些特定的服务，那这些服务我们更应该遵从正交性，最好将对接的这部分独立，以后供应商改了啥东西，我们也照样只是更改独立的这部分就OK了。\n\n### 可逆性\n\n> 如果某个想法是你唯一的想法，那就没有比它更危险的东西了。 ——埃米尔-奥古斯特-沙尔捷\n\n**可逆性**跟上面的正交性有点相似，正交性强调独立和解耦，可逆性是**可逆**，**容易改变**，两者之间存在一定的联系。\n\n我们在生活中都喜欢简单、唯一的解决方案，甚至有时还会严重依赖某些事实，但这在某种程度上是很危险的。\n\n变化不需要多么剧烈，甚至不必立刻发生，随着时间推移还有项目的演进，我们可能会发现很难前行，甚至陷入无法立足的困境，每当做出一个关键决定，我们就会投身于更具体的目标，由于选择变少，视野会越来越窄。但是问题在于，关键的决定一般不容易逆转。\n\n所以为了做到可逆性，我们要坚持做面向有弹性、适应性强的编程，像解耦，做外部配置，组件化，模块化等等，错误在于认为任何决定都是板上钉钉，而没有为可能出现的意外或者变更做好准备。\n\n现实中我们也不可能为今后会出现的各类架构提前做好准备，我们能做的，就是在变化来临时修改能更容易一点，而不是每次面临巨大的变化，脑海里只有一个念头：“重构”。\n\n\n\n\n\n","source":"_posts/《程序员修炼之道》--务实的方法（上）.md","raw":"---\ntitle: 《程序员修炼之道》 -- 务实的方法（上）\ncategories:\n - 代码人生\ntags:\n - 务实\n\n---\n\n### 前言\n\n周五啦，忙碌了一个星期，趁着周五晚上听听轻音乐，看会书，写写感想，放松一下~\n\n《程修道》在第一章由务实的哲学开头之后，在接下来的第二章就开始讲务实的方法，由思想理念到操作实践。\n\n务实的方法总共有**8**部分，`优秀设计的精髓`、`DRY-邪恶的重复`、`正交性`、`可逆性`、`曳光弹`、`原型与便签`、`领域语言`、`估算`。\n\n第二章的内容很丰富也更需要深入去阅读品味，今晚先记录一部分。\n\n<!-- more -->\n\n### 优秀设计的精髓\n\n这一部分，可以说是触及软件开发核心的至关重要主题，后面的7部分内容，都是由此来进行更为详细的展开。\n\n**优秀的设计比糟糕的设计更容易变更**。我们在日常经常有谈到怎样设计好的软件，最后总的概括，能适应使用者的就是好的设计。对于我们的代码而言，就是要顺应变化，这个顺应变化怎么理解呢，书中提到了一个重要的原则--**ETC（Easier To Change）原则**，更容易变更。很多设计原则，基本都是ETC原则的特例。\n\n为什么代码要解耦，因为通过隔离关注焦点，可以让每一部分都容易变更。\n\n为什么单一职责原则很有用？因为一个需求变化仅体现为某个单一模块上的一个对应变化。\n\n为什么良好的命名规则很重要？因为好的命名可以使打代码更容易阅读，而我们必须通过阅读才能做到变更。\n\n**ETC应当是一种价值观念，而不是一条规则**。价值观念跟规则的区别在于，规则是用来规范大家的行为，是要遵守的，有一种被动、甚至是束缚的感知。而价值观念是一种思维向导，它会帮助我们去思考，去做决定：哪些是该做的，哪些是不该做的，我们应该把ETC当成跟其它的价值观念一样，像“八荣八耻”，让它漂浮在我们的思维当中，当我们开始思考做决定时，它能微妙地将我们推向正确的方向。\n\n**怎样做到将ETC作为价值观念？**书中作者给出来他们这些年总结的一些经验：一开始需要一点有意识的强化。我们可能花几个星期的时间来有意识地问自己：“刚刚做的代码设计是让整个系统更容易变更还是更难改变？”当我们提交代码的时候问一遍，写测试的时候问一遍，当我们修复BUG的时候再问一遍，甚至要反思这个BUG的出现是不是可以通过更好的设计来规避。\n\n**更进一步**。除了上述作者给出的经验建议，我们还可以做得更好。第一点是让我们的代码坚持保持**解耦**和**内聚**、让我们的代码容易替换，即我们常说的**可配置化**。可配置化的好处就是不管以后有什么需求改变，我们都可以较为容易地去变更，而无需花费精力去重写。第二点是培养直觉，要经常记录我们遇到的问题、可以做的选择、可以怎样改变的猜测，以便我们可以进行快速的回顾和反思，下次遇到同样的问题，可以在脑海里快速提炼出方案。\n\n<--- 2020.05.16 添加 --->\n\n### 正交性\n\n“**正交性**”是从几何中借用来的术语。若两条直线相交成直角，它们就是正交的。用向量术语来说，这两条直线互不依赖。\n\n在计算科学中，正交就代表**独立性**或者**解耦性**。\n\n**消除不相关事物之间的影响**。组件化这个概念在如今已经是一个普遍的概念，很多大厂也都有开源的组件库。我们在写组件的时候，都是希望我们的组件是独立自主，有单一、清晰的定义，能够简单、重复地使用。当我们变更某一个组件的时候，不会对其它组件有很大影响甚至是没有影响。从这角度来看，正交性的系统主要有两个方面的好处：**提高生产力**以及**降低风险**。\n\n**提高生产力**\n\n- 正交的方法促进了复用。前端组件化最基本的定义，就是组件都是职责明确、定位清晰的，像表格组件、时间组件等等，根据不同的职责，能够跟不同的组件进行搭配复用。越是低耦合，我们需要重新配置和变更的地方就越少，也就越容易进行。\n- 节省开发、测试时间。\n\n**减少风险**\n\n- 代码中的“生病”的部分被分隔开。如果一个组件出问题了，我们只需改动组件某部分，减少大幅改动的风险。\n- 系统更加稳健。这样的系统，就像天气预报一样，局部有阵雨，局部多云一样，哪一块“天气不好”，我们只需对特定的部分修复，不会对系统造成影响。\n- 更有意思的一点，就是不会受特定供应商的束缚。我们的系统可能会对外对接一些特定的服务，那这些服务我们更应该遵从正交性，最好将对接的这部分独立，以后供应商改了啥东西，我们也照样只是更改独立的这部分就OK了。\n\n### 可逆性\n\n> 如果某个想法是你唯一的想法，那就没有比它更危险的东西了。 ——埃米尔-奥古斯特-沙尔捷\n\n**可逆性**跟上面的正交性有点相似，正交性强调独立和解耦，可逆性是**可逆**，**容易改变**，两者之间存在一定的联系。\n\n我们在生活中都喜欢简单、唯一的解决方案，甚至有时还会严重依赖某些事实，但这在某种程度上是很危险的。\n\n变化不需要多么剧烈，甚至不必立刻发生，随着时间推移还有项目的演进，我们可能会发现很难前行，甚至陷入无法立足的困境，每当做出一个关键决定，我们就会投身于更具体的目标，由于选择变少，视野会越来越窄。但是问题在于，关键的决定一般不容易逆转。\n\n所以为了做到可逆性，我们要坚持做面向有弹性、适应性强的编程，像解耦，做外部配置，组件化，模块化等等，错误在于认为任何决定都是板上钉钉，而没有为可能出现的意外或者变更做好准备。\n\n现实中我们也不可能为今后会出现的各类架构提前做好准备，我们能做的，就是在变化来临时修改能更容易一点，而不是每次面临巨大的变化，脑海里只有一个念头：“重构”。\n\n\n\n\n\n","slug":"《程序员修炼之道》--务实的方法（上）","published":1,"date":"2020-05-15T15:34:25.691Z","updated":"2020-05-20T14:11:04.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4l5000hhsuhakzs5j3r","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>周五啦，忙碌了一个星期，趁着周五晚上听听轻音乐，看会书，写写感想，放松一下~</p>\n<p>《程修道》在第一章由务实的哲学开头之后，在接下来的第二章就开始讲务实的方法，由思想理念到操作实践。</p>\n<p>务实的方法总共有<strong>8</strong>部分，<code>优秀设计的精髓</code>、<code>DRY-邪恶的重复</code>、<code>正交性</code>、<code>可逆性</code>、<code>曳光弹</code>、<code>原型与便签</code>、<code>领域语言</code>、<code>估算</code>。</p>\n<p>第二章的内容很丰富也更需要深入去阅读品味，今晚先记录一部分。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"优秀设计的精髓\"><a href=\"#优秀设计的精髓\" class=\"headerlink\" title=\"优秀设计的精髓\"></a>优秀设计的精髓</h3><p>这一部分，可以说是触及软件开发核心的至关重要主题，后面的7部分内容，都是由此来进行更为详细的展开。</p>\n<p><strong>优秀的设计比糟糕的设计更容易变更</strong>。我们在日常经常有谈到怎样设计好的软件，最后总的概括，能适应使用者的就是好的设计。对于我们的代码而言，就是要顺应变化，这个顺应变化怎么理解呢，书中提到了一个重要的原则–<strong>ETC（Easier To Change）原则</strong>，更容易变更。很多设计原则，基本都是ETC原则的特例。</p>\n<p>为什么代码要解耦，因为通过隔离关注焦点，可以让每一部分都容易变更。</p>\n<p>为什么单一职责原则很有用？因为一个需求变化仅体现为某个单一模块上的一个对应变化。</p>\n<p>为什么良好的命名规则很重要？因为好的命名可以使打代码更容易阅读，而我们必须通过阅读才能做到变更。</p>\n<p><strong>ETC应当是一种价值观念，而不是一条规则</strong>。价值观念跟规则的区别在于，规则是用来规范大家的行为，是要遵守的，有一种被动、甚至是束缚的感知。而价值观念是一种思维向导，它会帮助我们去思考，去做决定：哪些是该做的，哪些是不该做的，我们应该把ETC当成跟其它的价值观念一样，像“八荣八耻”，让它漂浮在我们的思维当中，当我们开始思考做决定时，它能微妙地将我们推向正确的方向。</p>\n<p><strong>怎样做到将ETC作为价值观念？</strong>书中作者给出来他们这些年总结的一些经验：一开始需要一点有意识的强化。我们可能花几个星期的时间来有意识地问自己：“刚刚做的代码设计是让整个系统更容易变更还是更难改变？”当我们提交代码的时候问一遍，写测试的时候问一遍，当我们修复BUG的时候再问一遍，甚至要反思这个BUG的出现是不是可以通过更好的设计来规避。</p>\n<p><strong>更进一步</strong>。除了上述作者给出的经验建议，我们还可以做得更好。第一点是让我们的代码坚持保持<strong>解耦</strong>和<strong>内聚</strong>、让我们的代码容易替换，即我们常说的<strong>可配置化</strong>。可配置化的好处就是不管以后有什么需求改变，我们都可以较为容易地去变更，而无需花费精力去重写。第二点是培养直觉，要经常记录我们遇到的问题、可以做的选择、可以怎样改变的猜测，以便我们可以进行快速的回顾和反思，下次遇到同样的问题，可以在脑海里快速提炼出方案。</p>\n<p>&lt;— 2020.05.16 添加 —&gt;</p>\n<h3 id=\"正交性\"><a href=\"#正交性\" class=\"headerlink\" title=\"正交性\"></a>正交性</h3><p>“<strong>正交性</strong>”是从几何中借用来的术语。若两条直线相交成直角，它们就是正交的。用向量术语来说，这两条直线互不依赖。</p>\n<p>在计算科学中，正交就代表<strong>独立性</strong>或者<strong>解耦性</strong>。</p>\n<p><strong>消除不相关事物之间的影响</strong>。组件化这个概念在如今已经是一个普遍的概念，很多大厂也都有开源的组件库。我们在写组件的时候，都是希望我们的组件是独立自主，有单一、清晰的定义，能够简单、重复地使用。当我们变更某一个组件的时候，不会对其它组件有很大影响甚至是没有影响。从这角度来看，正交性的系统主要有两个方面的好处：<strong>提高生产力</strong>以及<strong>降低风险</strong>。</p>\n<p><strong>提高生产力</strong></p>\n<ul>\n<li>正交的方法促进了复用。前端组件化最基本的定义，就是组件都是职责明确、定位清晰的，像表格组件、时间组件等等，根据不同的职责，能够跟不同的组件进行搭配复用。越是低耦合，我们需要重新配置和变更的地方就越少，也就越容易进行。</li>\n<li>节省开发、测试时间。</li>\n</ul>\n<p><strong>减少风险</strong></p>\n<ul>\n<li>代码中的“生病”的部分被分隔开。如果一个组件出问题了，我们只需改动组件某部分，减少大幅改动的风险。</li>\n<li>系统更加稳健。这样的系统，就像天气预报一样，局部有阵雨，局部多云一样，哪一块“天气不好”，我们只需对特定的部分修复，不会对系统造成影响。</li>\n<li>更有意思的一点，就是不会受特定供应商的束缚。我们的系统可能会对外对接一些特定的服务，那这些服务我们更应该遵从正交性，最好将对接的这部分独立，以后供应商改了啥东西，我们也照样只是更改独立的这部分就OK了。</li>\n</ul>\n<h3 id=\"可逆性\"><a href=\"#可逆性\" class=\"headerlink\" title=\"可逆性\"></a>可逆性</h3><blockquote>\n<p>如果某个想法是你唯一的想法，那就没有比它更危险的东西了。 ——埃米尔-奥古斯特-沙尔捷</p>\n</blockquote>\n<p><strong>可逆性</strong>跟上面的正交性有点相似，正交性强调独立和解耦，可逆性是<strong>可逆</strong>，<strong>容易改变</strong>，两者之间存在一定的联系。</p>\n<p>我们在生活中都喜欢简单、唯一的解决方案，甚至有时还会严重依赖某些事实，但这在某种程度上是很危险的。</p>\n<p>变化不需要多么剧烈，甚至不必立刻发生，随着时间推移还有项目的演进，我们可能会发现很难前行，甚至陷入无法立足的困境，每当做出一个关键决定，我们就会投身于更具体的目标，由于选择变少，视野会越来越窄。但是问题在于，关键的决定一般不容易逆转。</p>\n<p>所以为了做到可逆性，我们要坚持做面向有弹性、适应性强的编程，像解耦，做外部配置，组件化，模块化等等，错误在于认为任何决定都是板上钉钉，而没有为可能出现的意外或者变更做好准备。</p>\n<p>现实中我们也不可能为今后会出现的各类架构提前做好准备，我们能做的，就是在变化来临时修改能更容易一点，而不是每次面临巨大的变化，脑海里只有一个念头：“重构”。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>周五啦，忙碌了一个星期，趁着周五晚上听听轻音乐，看会书，写写感想，放松一下~</p>\n<p>《程修道》在第一章由务实的哲学开头之后，在接下来的第二章就开始讲务实的方法，由思想理念到操作实践。</p>\n<p>务实的方法总共有<strong>8</strong>部分，<code>优秀设计的精髓</code>、<code>DRY-邪恶的重复</code>、<code>正交性</code>、<code>可逆性</code>、<code>曳光弹</code>、<code>原型与便签</code>、<code>领域语言</code>、<code>估算</code>。</p>\n<p>第二章的内容很丰富也更需要深入去阅读品味，今晚先记录一部分。</p>","more":"<h3 id=\"优秀设计的精髓\"><a href=\"#优秀设计的精髓\" class=\"headerlink\" title=\"优秀设计的精髓\"></a>优秀设计的精髓</h3><p>这一部分，可以说是触及软件开发核心的至关重要主题，后面的7部分内容，都是由此来进行更为详细的展开。</p>\n<p><strong>优秀的设计比糟糕的设计更容易变更</strong>。我们在日常经常有谈到怎样设计好的软件，最后总的概括，能适应使用者的就是好的设计。对于我们的代码而言，就是要顺应变化，这个顺应变化怎么理解呢，书中提到了一个重要的原则–<strong>ETC（Easier To Change）原则</strong>，更容易变更。很多设计原则，基本都是ETC原则的特例。</p>\n<p>为什么代码要解耦，因为通过隔离关注焦点，可以让每一部分都容易变更。</p>\n<p>为什么单一职责原则很有用？因为一个需求变化仅体现为某个单一模块上的一个对应变化。</p>\n<p>为什么良好的命名规则很重要？因为好的命名可以使打代码更容易阅读，而我们必须通过阅读才能做到变更。</p>\n<p><strong>ETC应当是一种价值观念，而不是一条规则</strong>。价值观念跟规则的区别在于，规则是用来规范大家的行为，是要遵守的，有一种被动、甚至是束缚的感知。而价值观念是一种思维向导，它会帮助我们去思考，去做决定：哪些是该做的，哪些是不该做的，我们应该把ETC当成跟其它的价值观念一样，像“八荣八耻”，让它漂浮在我们的思维当中，当我们开始思考做决定时，它能微妙地将我们推向正确的方向。</p>\n<p><strong>怎样做到将ETC作为价值观念？</strong>书中作者给出来他们这些年总结的一些经验：一开始需要一点有意识的强化。我们可能花几个星期的时间来有意识地问自己：“刚刚做的代码设计是让整个系统更容易变更还是更难改变？”当我们提交代码的时候问一遍，写测试的时候问一遍，当我们修复BUG的时候再问一遍，甚至要反思这个BUG的出现是不是可以通过更好的设计来规避。</p>\n<p><strong>更进一步</strong>。除了上述作者给出的经验建议，我们还可以做得更好。第一点是让我们的代码坚持保持<strong>解耦</strong>和<strong>内聚</strong>、让我们的代码容易替换，即我们常说的<strong>可配置化</strong>。可配置化的好处就是不管以后有什么需求改变，我们都可以较为容易地去变更，而无需花费精力去重写。第二点是培养直觉，要经常记录我们遇到的问题、可以做的选择、可以怎样改变的猜测，以便我们可以进行快速的回顾和反思，下次遇到同样的问题，可以在脑海里快速提炼出方案。</p>\n<p>&lt;— 2020.05.16 添加 —&gt;</p>\n<h3 id=\"正交性\"><a href=\"#正交性\" class=\"headerlink\" title=\"正交性\"></a>正交性</h3><p>“<strong>正交性</strong>”是从几何中借用来的术语。若两条直线相交成直角，它们就是正交的。用向量术语来说，这两条直线互不依赖。</p>\n<p>在计算科学中，正交就代表<strong>独立性</strong>或者<strong>解耦性</strong>。</p>\n<p><strong>消除不相关事物之间的影响</strong>。组件化这个概念在如今已经是一个普遍的概念，很多大厂也都有开源的组件库。我们在写组件的时候，都是希望我们的组件是独立自主，有单一、清晰的定义，能够简单、重复地使用。当我们变更某一个组件的时候，不会对其它组件有很大影响甚至是没有影响。从这角度来看，正交性的系统主要有两个方面的好处：<strong>提高生产力</strong>以及<strong>降低风险</strong>。</p>\n<p><strong>提高生产力</strong></p>\n<ul>\n<li>正交的方法促进了复用。前端组件化最基本的定义，就是组件都是职责明确、定位清晰的，像表格组件、时间组件等等，根据不同的职责，能够跟不同的组件进行搭配复用。越是低耦合，我们需要重新配置和变更的地方就越少，也就越容易进行。</li>\n<li>节省开发、测试时间。</li>\n</ul>\n<p><strong>减少风险</strong></p>\n<ul>\n<li>代码中的“生病”的部分被分隔开。如果一个组件出问题了，我们只需改动组件某部分，减少大幅改动的风险。</li>\n<li>系统更加稳健。这样的系统，就像天气预报一样，局部有阵雨，局部多云一样，哪一块“天气不好”，我们只需对特定的部分修复，不会对系统造成影响。</li>\n<li>更有意思的一点，就是不会受特定供应商的束缚。我们的系统可能会对外对接一些特定的服务，那这些服务我们更应该遵从正交性，最好将对接的这部分独立，以后供应商改了啥东西，我们也照样只是更改独立的这部分就OK了。</li>\n</ul>\n<h3 id=\"可逆性\"><a href=\"#可逆性\" class=\"headerlink\" title=\"可逆性\"></a>可逆性</h3><blockquote>\n<p>如果某个想法是你唯一的想法，那就没有比它更危险的东西了。 ——埃米尔-奥古斯特-沙尔捷</p>\n</blockquote>\n<p><strong>可逆性</strong>跟上面的正交性有点相似，正交性强调独立和解耦，可逆性是<strong>可逆</strong>，<strong>容易改变</strong>，两者之间存在一定的联系。</p>\n<p>我们在生活中都喜欢简单、唯一的解决方案，甚至有时还会严重依赖某些事实，但这在某种程度上是很危险的。</p>\n<p>变化不需要多么剧烈，甚至不必立刻发生，随着时间推移还有项目的演进，我们可能会发现很难前行，甚至陷入无法立足的困境，每当做出一个关键决定，我们就会投身于更具体的目标，由于选择变少，视野会越来越窄。但是问题在于，关键的决定一般不容易逆转。</p>\n<p>所以为了做到可逆性，我们要坚持做面向有弹性、适应性强的编程，像解耦，做外部配置，组件化，模块化等等，错误在于认为任何决定都是板上钉钉，而没有为可能出现的意外或者变更做好准备。</p>\n<p>现实中我们也不可能为今后会出现的各类架构提前做好准备，我们能做的，就是在变化来临时修改能更容易一点，而不是每次面临巨大的变化，脑海里只有一个念头：“重构”。</p>"},{"title":"《程序员修炼之道》 -- 务实的方法（下）","_content":"\n### 前言\n\n上一篇记录了“务实的方法”上部分的内容，这篇博客记录下部分的内容~\n\n### 曳光弹\n\n很多人应该看过枪击电影、电视节目或者玩过枪击游戏，在这些场景里面，我们经常可以看到子弹在空中留下明亮的轨迹，这些轨迹就是来自**曳光弹**。\n\n<!-- more -->\n\n曳光弹和普通弹药间隔着一起被压入弹夹，当曳光弹发射时，上面的磷会被点着，在枪和击中物之间留下一道轨迹。如果曳光弹击中了目标，那么之后的常规子弹也会击中，士兵们通过使用曳光弹来调整他们的瞄准，这是一种务实的方法，可以在真实条件下实时获得反馈。\n\n**真实条件下获得实时反馈**。这个原则同样适用于我们的开发，特别是我们接触到以前未做过的东西的时候，**曳光弹式开发**针对变化的目标进行实时性的反馈是很有必要的。当我们在使用不熟悉的技术，或者在推进新技术的时候，往往会面临很多未知因素，所以在项目完成的这段时间内，我们的工作环境可能会经常的变动。\n\n**曳光代码**。曳光弹之所以有用，是因为其工作环境和约束跟真实环境是一致的，且能快速的到达目标，从实用性的角度来看，这也是一种低成本的解决方案。为了在开发中能获得同样的效果，我们可以找一些东西，能让我们快速、直观地从需求中得到最终系统的某个方面。开发中最初的曳光代码，就是创建一个简单的工程，加上一行我们熟悉的“hello world”并让这个工程跑起来，然后继续找出系统中不确定的部分再往上添加。我们在平时开发中使用一些demo来快速测试我们的想法是否行得通，其实也是属于曳光代码。\n\n曳光代码并不是一次性的，而应该是持续性的，一开始它并不完整，随着我们不断地往上添加，我们就能知道我们跟目标的距离，一旦偏离了轨迹，我们就应该快速做出调整，这是一个逐步增加的过程。\n\n<--- 2020.06.14 添加 --->\n\n### 原型与便签\n\n各行各业都有使用原型来尝试特定的想法：比如汽车制造商可能会为一款新车的设计制造许多不同的原型，每个原型都是为了测试某一特定的功能。我们开发软件也是一样，可以通过构建软件原型，来分析和暴露风险。\n\n原型被设计出来只是为了回答我们某些疑惑的地方，所以我们的原型可以忽略一些不重要的细节，比如制作UI原型，我们可以忽略数据，制作关于性能方面的，我们可以忽略界面。但是如果是任何一个细节都不能忽略的，那这种情况下，我们应该考虑的是上面的模式--曳光弹，也不是制作原型这种模式。\n\n**需要做原型的东西**。我们会选择用原型来研究什么类型的东西呢？答案是任何有风险的东西，任何之前没有尝试过，或者说在系统中很关键的东西，任何我们觉得可疑的东西，甚至是某些地方让我们觉得不舒服的，都可以制作原型。制作原型的意义就在于吸取经验，减少错误的成本。\n\n**制作架构原型**。有很多原型也会用于还在考虑中的整个系统建模。有时候这些原型不一定得编写代码，还可以用一些标签或者索引卡搞定，下面列出的领域，可能是我们希望在架构原型中找到相关问题的答案：\n\n- 主要组件的定义是否清晰，职责是否恰当？\n- 组件之间的协作是否定义清晰？\n- 耦合度是否已经是最小化？\n- 接口的定义和约束是否可以接受？\n- 在执行过程中是否每个模块都有访问所需数据的途径？在我们需要数据的时候，能访问到吗？\n\n带着这些去寻找，思考，我们往往能获得更有价值的结果。\n\n**不要把原型用于产品**。我们制作的这种原型跟产品经理所做的产品原型的作用是不同的，我们的原型是不完整的且不可能做到完整，因为它是一个用来做特定方面分析的东西，所以在展示我们制作出来的原型时，应该跟其他人说明，这仅仅是一个展示效果，并不是最后的成品，避免其他人后面想要坚持部署不完善的原型。\n\n如果使用得当，原型利于在开发的早期就识别出潜在的问题点，并给予纠正，且在这个时间点修正错误不仅廉价还容易。\n\n**关于便签**。便签非常适合构建动态事务的原型，比如我们的工作流和系统逻辑。最近看了谍战片《局中人》，其中有一处的场景是男二在墙壁上粘贴各种数据、模型，再通过线条来动态确立各模型之间的联系，从而辅助他做逻辑更清晰的判断，而他所做的工作，就是情报分析。\n\n### 估算\n\n估算不管是在生活中，还是程序世界里都是普遍存在的，当我们面对问题不能肯定地答复时，都是属于估算。通过学习估算，把这项技能发展成为对事物的数量级产生直觉，将会对我们的工作和生活产生魔法般的作用，并且在估算的过程中，我们也会加深对程序所处世界的理解。\n\n**多精确才够**。在某种程度上，所有的答案都是估算，区别仅在于一些比另一些更精确。所以当我们需要估算的时候，我们要问自己一个问题：答案会用在什么场合，对方需要怎样的精度？\n\n有一个关于估算有趣的事：我们使用的单位会对结果的解释产生影响。如果我们说某件事需要130个工作日完成，那么听的人往往会觉得实际的时间很接近130这个数字，然而如果我们说的是“大概4个月吧”，他们就会认为还需要5-7个月不等。两个数字代表的时间周期是差不多的，但是“130天”却暗示了更高的精度级别。\n\n因此当我们做估算时，可以挑选答案的单位来反映想要传达的精确性。\n\n**掌握问题域的范围**。所有的评估工作都是建立在所问问题的理解。除了精确度以外，我们还需要掌握问题域的范围。范围通常是问题的隐含前提，我们要养成一个在猜测之前加以考虑的习惯，很多时候，我们选择的范围会成为给出的答案的一部分。\n\n**记录估算能力**。除了从某些点出发去提高估算能力之外，我们还可以记录下我们做过的估算，这样可以看到我们做过的估算的准备却程度，简单来说就是复盘。当我们时常估算准确的时候，我们应该觉得这是理所应当，是估算的魅力；如果估算不准确的时候，我们也要找出为什么偏离的原因，有可能是实际情况的问题，有可能是估算时采用的参数问题，通过复盘，让我们下次的估算能更加准确。","source":"_posts/《程序员修炼之道》--务实的方法（下）.md","raw":"---\ntitle: 《程序员修炼之道》 -- 务实的方法（下）\ncategories:\n - 代码人生\ntags:\n - 务实\n\n---\n\n### 前言\n\n上一篇记录了“务实的方法”上部分的内容，这篇博客记录下部分的内容~\n\n### 曳光弹\n\n很多人应该看过枪击电影、电视节目或者玩过枪击游戏，在这些场景里面，我们经常可以看到子弹在空中留下明亮的轨迹，这些轨迹就是来自**曳光弹**。\n\n<!-- more -->\n\n曳光弹和普通弹药间隔着一起被压入弹夹，当曳光弹发射时，上面的磷会被点着，在枪和击中物之间留下一道轨迹。如果曳光弹击中了目标，那么之后的常规子弹也会击中，士兵们通过使用曳光弹来调整他们的瞄准，这是一种务实的方法，可以在真实条件下实时获得反馈。\n\n**真实条件下获得实时反馈**。这个原则同样适用于我们的开发，特别是我们接触到以前未做过的东西的时候，**曳光弹式开发**针对变化的目标进行实时性的反馈是很有必要的。当我们在使用不熟悉的技术，或者在推进新技术的时候，往往会面临很多未知因素，所以在项目完成的这段时间内，我们的工作环境可能会经常的变动。\n\n**曳光代码**。曳光弹之所以有用，是因为其工作环境和约束跟真实环境是一致的，且能快速的到达目标，从实用性的角度来看，这也是一种低成本的解决方案。为了在开发中能获得同样的效果，我们可以找一些东西，能让我们快速、直观地从需求中得到最终系统的某个方面。开发中最初的曳光代码，就是创建一个简单的工程，加上一行我们熟悉的“hello world”并让这个工程跑起来，然后继续找出系统中不确定的部分再往上添加。我们在平时开发中使用一些demo来快速测试我们的想法是否行得通，其实也是属于曳光代码。\n\n曳光代码并不是一次性的，而应该是持续性的，一开始它并不完整，随着我们不断地往上添加，我们就能知道我们跟目标的距离，一旦偏离了轨迹，我们就应该快速做出调整，这是一个逐步增加的过程。\n\n<--- 2020.06.14 添加 --->\n\n### 原型与便签\n\n各行各业都有使用原型来尝试特定的想法：比如汽车制造商可能会为一款新车的设计制造许多不同的原型，每个原型都是为了测试某一特定的功能。我们开发软件也是一样，可以通过构建软件原型，来分析和暴露风险。\n\n原型被设计出来只是为了回答我们某些疑惑的地方，所以我们的原型可以忽略一些不重要的细节，比如制作UI原型，我们可以忽略数据，制作关于性能方面的，我们可以忽略界面。但是如果是任何一个细节都不能忽略的，那这种情况下，我们应该考虑的是上面的模式--曳光弹，也不是制作原型这种模式。\n\n**需要做原型的东西**。我们会选择用原型来研究什么类型的东西呢？答案是任何有风险的东西，任何之前没有尝试过，或者说在系统中很关键的东西，任何我们觉得可疑的东西，甚至是某些地方让我们觉得不舒服的，都可以制作原型。制作原型的意义就在于吸取经验，减少错误的成本。\n\n**制作架构原型**。有很多原型也会用于还在考虑中的整个系统建模。有时候这些原型不一定得编写代码，还可以用一些标签或者索引卡搞定，下面列出的领域，可能是我们希望在架构原型中找到相关问题的答案：\n\n- 主要组件的定义是否清晰，职责是否恰当？\n- 组件之间的协作是否定义清晰？\n- 耦合度是否已经是最小化？\n- 接口的定义和约束是否可以接受？\n- 在执行过程中是否每个模块都有访问所需数据的途径？在我们需要数据的时候，能访问到吗？\n\n带着这些去寻找，思考，我们往往能获得更有价值的结果。\n\n**不要把原型用于产品**。我们制作的这种原型跟产品经理所做的产品原型的作用是不同的，我们的原型是不完整的且不可能做到完整，因为它是一个用来做特定方面分析的东西，所以在展示我们制作出来的原型时，应该跟其他人说明，这仅仅是一个展示效果，并不是最后的成品，避免其他人后面想要坚持部署不完善的原型。\n\n如果使用得当，原型利于在开发的早期就识别出潜在的问题点，并给予纠正，且在这个时间点修正错误不仅廉价还容易。\n\n**关于便签**。便签非常适合构建动态事务的原型，比如我们的工作流和系统逻辑。最近看了谍战片《局中人》，其中有一处的场景是男二在墙壁上粘贴各种数据、模型，再通过线条来动态确立各模型之间的联系，从而辅助他做逻辑更清晰的判断，而他所做的工作，就是情报分析。\n\n### 估算\n\n估算不管是在生活中，还是程序世界里都是普遍存在的，当我们面对问题不能肯定地答复时，都是属于估算。通过学习估算，把这项技能发展成为对事物的数量级产生直觉，将会对我们的工作和生活产生魔法般的作用，并且在估算的过程中，我们也会加深对程序所处世界的理解。\n\n**多精确才够**。在某种程度上，所有的答案都是估算，区别仅在于一些比另一些更精确。所以当我们需要估算的时候，我们要问自己一个问题：答案会用在什么场合，对方需要怎样的精度？\n\n有一个关于估算有趣的事：我们使用的单位会对结果的解释产生影响。如果我们说某件事需要130个工作日完成，那么听的人往往会觉得实际的时间很接近130这个数字，然而如果我们说的是“大概4个月吧”，他们就会认为还需要5-7个月不等。两个数字代表的时间周期是差不多的，但是“130天”却暗示了更高的精度级别。\n\n因此当我们做估算时，可以挑选答案的单位来反映想要传达的精确性。\n\n**掌握问题域的范围**。所有的评估工作都是建立在所问问题的理解。除了精确度以外，我们还需要掌握问题域的范围。范围通常是问题的隐含前提，我们要养成一个在猜测之前加以考虑的习惯，很多时候，我们选择的范围会成为给出的答案的一部分。\n\n**记录估算能力**。除了从某些点出发去提高估算能力之外，我们还可以记录下我们做过的估算，这样可以看到我们做过的估算的准备却程度，简单来说就是复盘。当我们时常估算准确的时候，我们应该觉得这是理所应当，是估算的魅力；如果估算不准确的时候，我们也要找出为什么偏离的原因，有可能是实际情况的问题，有可能是估算时采用的参数问题，通过复盘，让我们下次的估算能更加准确。","slug":"《程序员修炼之道》--务实的方法（下）","published":1,"date":"2020-08-04T14:12:35.762Z","updated":"2020-08-09T14:35:19.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4l8000jhsuhrthws6ub","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>上一篇记录了“务实的方法”上部分的内容，这篇博客记录下部分的内容~</p>\n<h3 id=\"曳光弹\"><a href=\"#曳光弹\" class=\"headerlink\" title=\"曳光弹\"></a>曳光弹</h3><p>很多人应该看过枪击电影、电视节目或者玩过枪击游戏，在这些场景里面，我们经常可以看到子弹在空中留下明亮的轨迹，这些轨迹就是来自<strong>曳光弹</strong>。</p>\n<a id=\"more\"></a>\n\n<p>曳光弹和普通弹药间隔着一起被压入弹夹，当曳光弹发射时，上面的磷会被点着，在枪和击中物之间留下一道轨迹。如果曳光弹击中了目标，那么之后的常规子弹也会击中，士兵们通过使用曳光弹来调整他们的瞄准，这是一种务实的方法，可以在真实条件下实时获得反馈。</p>\n<p><strong>真实条件下获得实时反馈</strong>。这个原则同样适用于我们的开发，特别是我们接触到以前未做过的东西的时候，<strong>曳光弹式开发</strong>针对变化的目标进行实时性的反馈是很有必要的。当我们在使用不熟悉的技术，或者在推进新技术的时候，往往会面临很多未知因素，所以在项目完成的这段时间内，我们的工作环境可能会经常的变动。</p>\n<p><strong>曳光代码</strong>。曳光弹之所以有用，是因为其工作环境和约束跟真实环境是一致的，且能快速的到达目标，从实用性的角度来看，这也是一种低成本的解决方案。为了在开发中能获得同样的效果，我们可以找一些东西，能让我们快速、直观地从需求中得到最终系统的某个方面。开发中最初的曳光代码，就是创建一个简单的工程，加上一行我们熟悉的“hello world”并让这个工程跑起来，然后继续找出系统中不确定的部分再往上添加。我们在平时开发中使用一些demo来快速测试我们的想法是否行得通，其实也是属于曳光代码。</p>\n<p>曳光代码并不是一次性的，而应该是持续性的，一开始它并不完整，随着我们不断地往上添加，我们就能知道我们跟目标的距离，一旦偏离了轨迹，我们就应该快速做出调整，这是一个逐步增加的过程。</p>\n<p>&lt;— 2020.06.14 添加 —&gt;</p>\n<h3 id=\"原型与便签\"><a href=\"#原型与便签\" class=\"headerlink\" title=\"原型与便签\"></a>原型与便签</h3><p>各行各业都有使用原型来尝试特定的想法：比如汽车制造商可能会为一款新车的设计制造许多不同的原型，每个原型都是为了测试某一特定的功能。我们开发软件也是一样，可以通过构建软件原型，来分析和暴露风险。</p>\n<p>原型被设计出来只是为了回答我们某些疑惑的地方，所以我们的原型可以忽略一些不重要的细节，比如制作UI原型，我们可以忽略数据，制作关于性能方面的，我们可以忽略界面。但是如果是任何一个细节都不能忽略的，那这种情况下，我们应该考虑的是上面的模式–曳光弹，也不是制作原型这种模式。</p>\n<p><strong>需要做原型的东西</strong>。我们会选择用原型来研究什么类型的东西呢？答案是任何有风险的东西，任何之前没有尝试过，或者说在系统中很关键的东西，任何我们觉得可疑的东西，甚至是某些地方让我们觉得不舒服的，都可以制作原型。制作原型的意义就在于吸取经验，减少错误的成本。</p>\n<p><strong>制作架构原型</strong>。有很多原型也会用于还在考虑中的整个系统建模。有时候这些原型不一定得编写代码，还可以用一些标签或者索引卡搞定，下面列出的领域，可能是我们希望在架构原型中找到相关问题的答案：</p>\n<ul>\n<li>主要组件的定义是否清晰，职责是否恰当？</li>\n<li>组件之间的协作是否定义清晰？</li>\n<li>耦合度是否已经是最小化？</li>\n<li>接口的定义和约束是否可以接受？</li>\n<li>在执行过程中是否每个模块都有访问所需数据的途径？在我们需要数据的时候，能访问到吗？</li>\n</ul>\n<p>带着这些去寻找，思考，我们往往能获得更有价值的结果。</p>\n<p><strong>不要把原型用于产品</strong>。我们制作的这种原型跟产品经理所做的产品原型的作用是不同的，我们的原型是不完整的且不可能做到完整，因为它是一个用来做特定方面分析的东西，所以在展示我们制作出来的原型时，应该跟其他人说明，这仅仅是一个展示效果，并不是最后的成品，避免其他人后面想要坚持部署不完善的原型。</p>\n<p>如果使用得当，原型利于在开发的早期就识别出潜在的问题点，并给予纠正，且在这个时间点修正错误不仅廉价还容易。</p>\n<p><strong>关于便签</strong>。便签非常适合构建动态事务的原型，比如我们的工作流和系统逻辑。最近看了谍战片《局中人》，其中有一处的场景是男二在墙壁上粘贴各种数据、模型，再通过线条来动态确立各模型之间的联系，从而辅助他做逻辑更清晰的判断，而他所做的工作，就是情报分析。</p>\n<h3 id=\"估算\"><a href=\"#估算\" class=\"headerlink\" title=\"估算\"></a>估算</h3><p>估算不管是在生活中，还是程序世界里都是普遍存在的，当我们面对问题不能肯定地答复时，都是属于估算。通过学习估算，把这项技能发展成为对事物的数量级产生直觉，将会对我们的工作和生活产生魔法般的作用，并且在估算的过程中，我们也会加深对程序所处世界的理解。</p>\n<p><strong>多精确才够</strong>。在某种程度上，所有的答案都是估算，区别仅在于一些比另一些更精确。所以当我们需要估算的时候，我们要问自己一个问题：答案会用在什么场合，对方需要怎样的精度？</p>\n<p>有一个关于估算有趣的事：我们使用的单位会对结果的解释产生影响。如果我们说某件事需要130个工作日完成，那么听的人往往会觉得实际的时间很接近130这个数字，然而如果我们说的是“大概4个月吧”，他们就会认为还需要5-7个月不等。两个数字代表的时间周期是差不多的，但是“130天”却暗示了更高的精度级别。</p>\n<p>因此当我们做估算时，可以挑选答案的单位来反映想要传达的精确性。</p>\n<p><strong>掌握问题域的范围</strong>。所有的评估工作都是建立在所问问题的理解。除了精确度以外，我们还需要掌握问题域的范围。范围通常是问题的隐含前提，我们要养成一个在猜测之前加以考虑的习惯，很多时候，我们选择的范围会成为给出的答案的一部分。</p>\n<p><strong>记录估算能力</strong>。除了从某些点出发去提高估算能力之外，我们还可以记录下我们做过的估算，这样可以看到我们做过的估算的准备却程度，简单来说就是复盘。当我们时常估算准确的时候，我们应该觉得这是理所应当，是估算的魅力；如果估算不准确的时候，我们也要找出为什么偏离的原因，有可能是实际情况的问题，有可能是估算时采用的参数问题，通过复盘，让我们下次的估算能更加准确。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>上一篇记录了“务实的方法”上部分的内容，这篇博客记录下部分的内容~</p>\n<h3 id=\"曳光弹\"><a href=\"#曳光弹\" class=\"headerlink\" title=\"曳光弹\"></a>曳光弹</h3><p>很多人应该看过枪击电影、电视节目或者玩过枪击游戏，在这些场景里面，我们经常可以看到子弹在空中留下明亮的轨迹，这些轨迹就是来自<strong>曳光弹</strong>。</p>","more":"<p>曳光弹和普通弹药间隔着一起被压入弹夹，当曳光弹发射时，上面的磷会被点着，在枪和击中物之间留下一道轨迹。如果曳光弹击中了目标，那么之后的常规子弹也会击中，士兵们通过使用曳光弹来调整他们的瞄准，这是一种务实的方法，可以在真实条件下实时获得反馈。</p>\n<p><strong>真实条件下获得实时反馈</strong>。这个原则同样适用于我们的开发，特别是我们接触到以前未做过的东西的时候，<strong>曳光弹式开发</strong>针对变化的目标进行实时性的反馈是很有必要的。当我们在使用不熟悉的技术，或者在推进新技术的时候，往往会面临很多未知因素，所以在项目完成的这段时间内，我们的工作环境可能会经常的变动。</p>\n<p><strong>曳光代码</strong>。曳光弹之所以有用，是因为其工作环境和约束跟真实环境是一致的，且能快速的到达目标，从实用性的角度来看，这也是一种低成本的解决方案。为了在开发中能获得同样的效果，我们可以找一些东西，能让我们快速、直观地从需求中得到最终系统的某个方面。开发中最初的曳光代码，就是创建一个简单的工程，加上一行我们熟悉的“hello world”并让这个工程跑起来，然后继续找出系统中不确定的部分再往上添加。我们在平时开发中使用一些demo来快速测试我们的想法是否行得通，其实也是属于曳光代码。</p>\n<p>曳光代码并不是一次性的，而应该是持续性的，一开始它并不完整，随着我们不断地往上添加，我们就能知道我们跟目标的距离，一旦偏离了轨迹，我们就应该快速做出调整，这是一个逐步增加的过程。</p>\n<p>&lt;— 2020.06.14 添加 —&gt;</p>\n<h3 id=\"原型与便签\"><a href=\"#原型与便签\" class=\"headerlink\" title=\"原型与便签\"></a>原型与便签</h3><p>各行各业都有使用原型来尝试特定的想法：比如汽车制造商可能会为一款新车的设计制造许多不同的原型，每个原型都是为了测试某一特定的功能。我们开发软件也是一样，可以通过构建软件原型，来分析和暴露风险。</p>\n<p>原型被设计出来只是为了回答我们某些疑惑的地方，所以我们的原型可以忽略一些不重要的细节，比如制作UI原型，我们可以忽略数据，制作关于性能方面的，我们可以忽略界面。但是如果是任何一个细节都不能忽略的，那这种情况下，我们应该考虑的是上面的模式–曳光弹，也不是制作原型这种模式。</p>\n<p><strong>需要做原型的东西</strong>。我们会选择用原型来研究什么类型的东西呢？答案是任何有风险的东西，任何之前没有尝试过，或者说在系统中很关键的东西，任何我们觉得可疑的东西，甚至是某些地方让我们觉得不舒服的，都可以制作原型。制作原型的意义就在于吸取经验，减少错误的成本。</p>\n<p><strong>制作架构原型</strong>。有很多原型也会用于还在考虑中的整个系统建模。有时候这些原型不一定得编写代码，还可以用一些标签或者索引卡搞定，下面列出的领域，可能是我们希望在架构原型中找到相关问题的答案：</p>\n<ul>\n<li>主要组件的定义是否清晰，职责是否恰当？</li>\n<li>组件之间的协作是否定义清晰？</li>\n<li>耦合度是否已经是最小化？</li>\n<li>接口的定义和约束是否可以接受？</li>\n<li>在执行过程中是否每个模块都有访问所需数据的途径？在我们需要数据的时候，能访问到吗？</li>\n</ul>\n<p>带着这些去寻找，思考，我们往往能获得更有价值的结果。</p>\n<p><strong>不要把原型用于产品</strong>。我们制作的这种原型跟产品经理所做的产品原型的作用是不同的，我们的原型是不完整的且不可能做到完整，因为它是一个用来做特定方面分析的东西，所以在展示我们制作出来的原型时，应该跟其他人说明，这仅仅是一个展示效果，并不是最后的成品，避免其他人后面想要坚持部署不完善的原型。</p>\n<p>如果使用得当，原型利于在开发的早期就识别出潜在的问题点，并给予纠正，且在这个时间点修正错误不仅廉价还容易。</p>\n<p><strong>关于便签</strong>。便签非常适合构建动态事务的原型，比如我们的工作流和系统逻辑。最近看了谍战片《局中人》，其中有一处的场景是男二在墙壁上粘贴各种数据、模型，再通过线条来动态确立各模型之间的联系，从而辅助他做逻辑更清晰的判断，而他所做的工作，就是情报分析。</p>\n<h3 id=\"估算\"><a href=\"#估算\" class=\"headerlink\" title=\"估算\"></a>估算</h3><p>估算不管是在生活中，还是程序世界里都是普遍存在的，当我们面对问题不能肯定地答复时，都是属于估算。通过学习估算，把这项技能发展成为对事物的数量级产生直觉，将会对我们的工作和生活产生魔法般的作用，并且在估算的过程中，我们也会加深对程序所处世界的理解。</p>\n<p><strong>多精确才够</strong>。在某种程度上，所有的答案都是估算，区别仅在于一些比另一些更精确。所以当我们需要估算的时候，我们要问自己一个问题：答案会用在什么场合，对方需要怎样的精度？</p>\n<p>有一个关于估算有趣的事：我们使用的单位会对结果的解释产生影响。如果我们说某件事需要130个工作日完成，那么听的人往往会觉得实际的时间很接近130这个数字，然而如果我们说的是“大概4个月吧”，他们就会认为还需要5-7个月不等。两个数字代表的时间周期是差不多的，但是“130天”却暗示了更高的精度级别。</p>\n<p>因此当我们做估算时，可以挑选答案的单位来反映想要传达的精确性。</p>\n<p><strong>掌握问题域的范围</strong>。所有的评估工作都是建立在所问问题的理解。除了精确度以外，我们还需要掌握问题域的范围。范围通常是问题的隐含前提，我们要养成一个在猜测之前加以考虑的习惯，很多时候，我们选择的范围会成为给出的答案的一部分。</p>\n<p><strong>记录估算能力</strong>。除了从某些点出发去提高估算能力之外，我们还可以记录下我们做过的估算，这样可以看到我们做过的估算的准备却程度，简单来说就是复盘。当我们时常估算准确的时候，我们应该觉得这是理所应当，是估算的魅力；如果估算不准确的时候，我们也要找出为什么偏离的原因，有可能是实际情况的问题，有可能是估算时采用的参数问题，通过复盘，让我们下次的估算能更加准确。</p>"},{"title":"《程序员修炼之道》","_content":"\n### 前言\n\n最近买了**《程序员修炼之道（第二版）-通向务实的最高境界》**这本书，第一版是在2004年3月出版的**《程序员修炼之道-从小工到专家》**，听说是一本神书，90%程序员都看过（我就是那10%的一员(￣ω￣;)），还颠覆了很多IT界大牛的技术生涯。时隔16年，即今年2020年4月份出版了现在的第二版，除了回顾、更新前一版所引用的技术，两位作者还充分借鉴这16年来增加的丰富经验来重新审视前一版所推崇的时间背后的种种假设，构成了一本更胜第一版的神书。\n\n<!-- more -->\n\n### 为什么阅读这本书\n\n除了书籍本身所携带的光环和知名度之外，吸引我的还是这个书名。\n\n**《程序员修炼之道》**，让我想到了星爷的**《演员的自我修养》**，星爷本身就是一个励志、传奇故事，他的电影可以说是很多人的美好回忆，所以这种异曲同工之妙，是第一个吸引点；\n\n第二吸引点是书的副题，“**通向务实的最高境界**”，“**务实**”一词，给我的感触就是现实中已经越来越少有这种精神了，不单是开发，映射到各种各样的行业，“**浮躁**”反而是当前更多人的心态。前端开发，给人也是这种“浮躁”的感觉，培训班、自学生出来的各种不合格的初级前端，嘴里喊着“别更新了，我已经学不动了”，开发中各种骚操作，种种现象。包括我自己也算是比较浮躁，所以探索“务实”对我来说，格外的有吸引力。\n\n### 阅读计划\n\n“**是骡子是马拉出来溜溜**”，是不是好书要读过才知道，所以自己已经开始阅读这本书，然后打算在个人博客记录、分享阅读后的感想，通过读+想+写，来让自己距离务实更近一些。\n\n### 最后，瞄一眼书的样貌\n\n![《程序员修炼之道第二版》](/images/book.jpg)","source":"_posts/《程序员修炼之道》.md","raw":"---\ntitle: 《程序员修炼之道》\ncategories:\n - 代码人生\ntags:\n - 务实\n---\n\n### 前言\n\n最近买了**《程序员修炼之道（第二版）-通向务实的最高境界》**这本书，第一版是在2004年3月出版的**《程序员修炼之道-从小工到专家》**，听说是一本神书，90%程序员都看过（我就是那10%的一员(￣ω￣;)），还颠覆了很多IT界大牛的技术生涯。时隔16年，即今年2020年4月份出版了现在的第二版，除了回顾、更新前一版所引用的技术，两位作者还充分借鉴这16年来增加的丰富经验来重新审视前一版所推崇的时间背后的种种假设，构成了一本更胜第一版的神书。\n\n<!-- more -->\n\n### 为什么阅读这本书\n\n除了书籍本身所携带的光环和知名度之外，吸引我的还是这个书名。\n\n**《程序员修炼之道》**，让我想到了星爷的**《演员的自我修养》**，星爷本身就是一个励志、传奇故事，他的电影可以说是很多人的美好回忆，所以这种异曲同工之妙，是第一个吸引点；\n\n第二吸引点是书的副题，“**通向务实的最高境界**”，“**务实**”一词，给我的感触就是现实中已经越来越少有这种精神了，不单是开发，映射到各种各样的行业，“**浮躁**”反而是当前更多人的心态。前端开发，给人也是这种“浮躁”的感觉，培训班、自学生出来的各种不合格的初级前端，嘴里喊着“别更新了，我已经学不动了”，开发中各种骚操作，种种现象。包括我自己也算是比较浮躁，所以探索“务实”对我来说，格外的有吸引力。\n\n### 阅读计划\n\n“**是骡子是马拉出来溜溜**”，是不是好书要读过才知道，所以自己已经开始阅读这本书，然后打算在个人博客记录、分享阅读后的感想，通过读+想+写，来让自己距离务实更近一些。\n\n### 最后，瞄一眼书的样貌\n\n![《程序员修炼之道第二版》](/images/book.jpg)","slug":"《程序员修炼之道》","published":1,"date":"2020-05-07T14:13:40.073Z","updated":"2020-05-08T14:15:20.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4ld000nhsuh36iu9an7","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近买了<strong>《程序员修炼之道（第二版）-通向务实的最高境界》</strong>这本书，第一版是在2004年3月出版的<strong>《程序员修炼之道-从小工到专家》</strong>，听说是一本神书，90%程序员都看过（我就是那10%的一员(￣ω￣;)），还颠覆了很多IT界大牛的技术生涯。时隔16年，即今年2020年4月份出版了现在的第二版，除了回顾、更新前一版所引用的技术，两位作者还充分借鉴这16年来增加的丰富经验来重新审视前一版所推崇的时间背后的种种假设，构成了一本更胜第一版的神书。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"为什么阅读这本书\"><a href=\"#为什么阅读这本书\" class=\"headerlink\" title=\"为什么阅读这本书\"></a>为什么阅读这本书</h3><p>除了书籍本身所携带的光环和知名度之外，吸引我的还是这个书名。</p>\n<p><strong>《程序员修炼之道》</strong>，让我想到了星爷的<strong>《演员的自我修养》</strong>，星爷本身就是一个励志、传奇故事，他的电影可以说是很多人的美好回忆，所以这种异曲同工之妙，是第一个吸引点；</p>\n<p>第二吸引点是书的副题，“<strong>通向务实的最高境界</strong>”，“<strong>务实</strong>”一词，给我的感触就是现实中已经越来越少有这种精神了，不单是开发，映射到各种各样的行业，“<strong>浮躁</strong>”反而是当前更多人的心态。前端开发，给人也是这种“浮躁”的感觉，培训班、自学生出来的各种不合格的初级前端，嘴里喊着“别更新了，我已经学不动了”，开发中各种骚操作，种种现象。包括我自己也算是比较浮躁，所以探索“务实”对我来说，格外的有吸引力。</p>\n<h3 id=\"阅读计划\"><a href=\"#阅读计划\" class=\"headerlink\" title=\"阅读计划\"></a>阅读计划</h3><p>“<strong>是骡子是马拉出来溜溜</strong>”，是不是好书要读过才知道，所以自己已经开始阅读这本书，然后打算在个人博客记录、分享阅读后的感想，通过读+想+写，来让自己距离务实更近一些。</p>\n<h3 id=\"最后，瞄一眼书的样貌\"><a href=\"#最后，瞄一眼书的样貌\" class=\"headerlink\" title=\"最后，瞄一眼书的样貌\"></a>最后，瞄一眼书的样貌</h3><p><img src=\"/images/book.jpg\" alt=\"《程序员修炼之道第二版》\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近买了<strong>《程序员修炼之道（第二版）-通向务实的最高境界》</strong>这本书，第一版是在2004年3月出版的<strong>《程序员修炼之道-从小工到专家》</strong>，听说是一本神书，90%程序员都看过（我就是那10%的一员(￣ω￣;)），还颠覆了很多IT界大牛的技术生涯。时隔16年，即今年2020年4月份出版了现在的第二版，除了回顾、更新前一版所引用的技术，两位作者还充分借鉴这16年来增加的丰富经验来重新审视前一版所推崇的时间背后的种种假设，构成了一本更胜第一版的神书。</p>","more":"<h3 id=\"为什么阅读这本书\"><a href=\"#为什么阅读这本书\" class=\"headerlink\" title=\"为什么阅读这本书\"></a>为什么阅读这本书</h3><p>除了书籍本身所携带的光环和知名度之外，吸引我的还是这个书名。</p>\n<p><strong>《程序员修炼之道》</strong>，让我想到了星爷的<strong>《演员的自我修养》</strong>，星爷本身就是一个励志、传奇故事，他的电影可以说是很多人的美好回忆，所以这种异曲同工之妙，是第一个吸引点；</p>\n<p>第二吸引点是书的副题，“<strong>通向务实的最高境界</strong>”，“<strong>务实</strong>”一词，给我的感触就是现实中已经越来越少有这种精神了，不单是开发，映射到各种各样的行业，“<strong>浮躁</strong>”反而是当前更多人的心态。前端开发，给人也是这种“浮躁”的感觉，培训班、自学生出来的各种不合格的初级前端，嘴里喊着“别更新了，我已经学不动了”，开发中各种骚操作，种种现象。包括我自己也算是比较浮躁，所以探索“务实”对我来说，格外的有吸引力。</p>\n<h3 id=\"阅读计划\"><a href=\"#阅读计划\" class=\"headerlink\" title=\"阅读计划\"></a>阅读计划</h3><p>“<strong>是骡子是马拉出来溜溜</strong>”，是不是好书要读过才知道，所以自己已经开始阅读这本书，然后打算在个人博客记录、分享阅读后的感想，通过读+想+写，来让自己距离务实更近一些。</p>\n<h3 id=\"最后，瞄一眼书的样貌\"><a href=\"#最后，瞄一眼书的样貌\" class=\"headerlink\" title=\"最后，瞄一眼书的样貌\"></a>最后，瞄一眼书的样貌</h3><p><img src=\"/images/book.jpg\" alt=\"《程序员修炼之道第二版》\"></p>"},{"title":"分享一道有趣的题","_content":"\n今天在群里看到朋友发了一道有趣的题\n\n![](/images/有趣的题.jpg)\n\n就是如何让`(a == 1 && a == 2 && a == 3) === true`这个等式成立。一开始看到这个题觉得是无稽之谈，这不扯淡吗，一个变量能同时满足几个值？但是朋友这么问还真说不定有可能，于是开始一波思考。\n\n<!-- more -->\n\n首先分析一下等式左边的`a==1`，`a==2`，`a==3`，相等符号`==`会判断两个变量的值是否相等，如果不相等，则会涉及到变量类型的转换，全等符号`===`则会同时判断变量的值和类型，其中一个不相等，则结果为`false`\n\n然后我们假设等式已经成立，既然这个等式能够成立，那么变量`a`肯定不是一个普通的变量，至少**基本数据类型**满足不了这种骚操作，那么它应该是**复杂数据类型**。\n\n那我们接着假定是对象，那么对象跟基本数据类型对比的时候，会有我们上面说的涉及到类型转换，对象会先转换成基本数据类型，这里就会触发原型上`toString()`方法，如下：\n\n![触发toString](/images/触发toString.png)\n\n我们给`a`重写覆盖了`toString`方法，以方便我们调试，可以看到，对象在判断转换过程中，会触发`toString`方法。那么我们就可以根据这个特性，对`a`进行一波骚操作：\n\n```javascript\nvar a = {\n\ti: 1,\n    toString: function() {\n        return this.i++\n    }\n}\n```\n\n运行一下：\n\n![](/images/等式成立.png)\n\n可以看到，**等式成立！！！**这说明确实可以存在这种情况的，不过现实中不建议这样重写去改变原本默认行为，可能会导致出现不可预料的错误。但是不可否认，这种骚操作的题，一定程度上可以反馈出我们对JS基础、还有一些底层操作的理解。学习路上，真的是任重而道远啊~\n\n","source":"_posts/分享一道有趣的题.md","raw":"---\ntitle: 分享一道有趣的题\ncategories:\n - 前端\ntags:\n - JS\n\n---\n\n今天在群里看到朋友发了一道有趣的题\n\n![](/images/有趣的题.jpg)\n\n就是如何让`(a == 1 && a == 2 && a == 3) === true`这个等式成立。一开始看到这个题觉得是无稽之谈，这不扯淡吗，一个变量能同时满足几个值？但是朋友这么问还真说不定有可能，于是开始一波思考。\n\n<!-- more -->\n\n首先分析一下等式左边的`a==1`，`a==2`，`a==3`，相等符号`==`会判断两个变量的值是否相等，如果不相等，则会涉及到变量类型的转换，全等符号`===`则会同时判断变量的值和类型，其中一个不相等，则结果为`false`\n\n然后我们假设等式已经成立，既然这个等式能够成立，那么变量`a`肯定不是一个普通的变量，至少**基本数据类型**满足不了这种骚操作，那么它应该是**复杂数据类型**。\n\n那我们接着假定是对象，那么对象跟基本数据类型对比的时候，会有我们上面说的涉及到类型转换，对象会先转换成基本数据类型，这里就会触发原型上`toString()`方法，如下：\n\n![触发toString](/images/触发toString.png)\n\n我们给`a`重写覆盖了`toString`方法，以方便我们调试，可以看到，对象在判断转换过程中，会触发`toString`方法。那么我们就可以根据这个特性，对`a`进行一波骚操作：\n\n```javascript\nvar a = {\n\ti: 1,\n    toString: function() {\n        return this.i++\n    }\n}\n```\n\n运行一下：\n\n![](/images/等式成立.png)\n\n可以看到，**等式成立！！！**这说明确实可以存在这种情况的，不过现实中不建议这样重写去改变原本默认行为，可能会导致出现不可预料的错误。但是不可否认，这种骚操作的题，一定程度上可以反馈出我们对JS基础、还有一些底层操作的理解。学习路上，真的是任重而道远啊~\n\n","slug":"分享一道有趣的题","published":1,"date":"2020-03-22T13:47:57.801Z","updated":"2020-03-22T14:00:48.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4li000qhsuhrq1h9ddr","content":"<p>今天在群里看到朋友发了一道有趣的题</p>\n<p><img src=\"/images/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98.jpg\" alt></p>\n<p>就是如何让<code>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) === true</code>这个等式成立。一开始看到这个题觉得是无稽之谈，这不扯淡吗，一个变量能同时满足几个值？但是朋友这么问还真说不定有可能，于是开始一波思考。</p>\n<a id=\"more\"></a>\n\n<p>首先分析一下等式左边的<code>a==1</code>，<code>a==2</code>，<code>a==3</code>，相等符号<code>==</code>会判断两个变量的值是否相等，如果不相等，则会涉及到变量类型的转换，全等符号<code>===</code>则会同时判断变量的值和类型，其中一个不相等，则结果为<code>false</code></p>\n<p>然后我们假设等式已经成立，既然这个等式能够成立，那么变量<code>a</code>肯定不是一个普通的变量，至少<strong>基本数据类型</strong>满足不了这种骚操作，那么它应该是<strong>复杂数据类型</strong>。</p>\n<p>那我们接着假定是对象，那么对象跟基本数据类型对比的时候，会有我们上面说的涉及到类型转换，对象会先转换成基本数据类型，这里就会触发原型上<code>toString()</code>方法，如下：</p>\n<p><img src=\"/images/%E8%A7%A6%E5%8F%91toString.png\" alt=\"触发toString\"></p>\n<p>我们给<code>a</code>重写覆盖了<code>toString</code>方法，以方便我们调试，可以看到，对象在判断转换过程中，会触发<code>toString</code>方法。那么我们就可以根据这个特性，对<code>a</code>进行一波骚操作：</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = &#123;</span><br><span class=\"line\">\ti: <span class=\"hljs-number\">1</span>,</span><br><span class=\"line\">    toString: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行一下：</p>\n<p><img src=\"/images/%E7%AD%89%E5%BC%8F%E6%88%90%E7%AB%8B.png\" alt></p>\n<p>可以看到，<strong>等式成立！！！</strong>这说明确实可以存在这种情况的，不过现实中不建议这样重写去改变原本默认行为，可能会导致出现不可预料的错误。但是不可否认，这种骚操作的题，一定程度上可以反馈出我们对JS基础、还有一些底层操作的理解。学习路上，真的是任重而道远啊~</p>\n","site":{"data":{}},"excerpt":"<p>今天在群里看到朋友发了一道有趣的题</p>\n<p><img src=\"/images/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98.jpg\" alt></p>\n<p>就是如何让<code>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) === true</code>这个等式成立。一开始看到这个题觉得是无稽之谈，这不扯淡吗，一个变量能同时满足几个值？但是朋友这么问还真说不定有可能，于是开始一波思考。</p>","more":"<p>首先分析一下等式左边的<code>a==1</code>，<code>a==2</code>，<code>a==3</code>，相等符号<code>==</code>会判断两个变量的值是否相等，如果不相等，则会涉及到变量类型的转换，全等符号<code>===</code>则会同时判断变量的值和类型，其中一个不相等，则结果为<code>false</code></p>\n<p>然后我们假设等式已经成立，既然这个等式能够成立，那么变量<code>a</code>肯定不是一个普通的变量，至少<strong>基本数据类型</strong>满足不了这种骚操作，那么它应该是<strong>复杂数据类型</strong>。</p>\n<p>那我们接着假定是对象，那么对象跟基本数据类型对比的时候，会有我们上面说的涉及到类型转换，对象会先转换成基本数据类型，这里就会触发原型上<code>toString()</code>方法，如下：</p>\n<p><img src=\"/images/%E8%A7%A6%E5%8F%91toString.png\" alt=\"触发toString\"></p>\n<p>我们给<code>a</code>重写覆盖了<code>toString</code>方法，以方便我们调试，可以看到，对象在判断转换过程中，会触发<code>toString</code>方法。那么我们就可以根据这个特性，对<code>a</code>进行一波骚操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\ti: <span class=\"number\">1</span>,</span><br><span class=\"line\">    toString: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.i++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行一下：</p>\n<p><img src=\"/images/%E7%AD%89%E5%BC%8F%E6%88%90%E7%AB%8B.png\" alt></p>\n<p>可以看到，<strong>等式成立！！！</strong>这说明确实可以存在这种情况的，不过现实中不建议这样重写去改变原本默认行为，可能会导致出现不可预料的错误。但是不可否认，这种骚操作的题，一定程度上可以反馈出我们对JS基础、还有一些底层操作的理解。学习路上，真的是任重而道远啊~</p>"},{"title":"前端幸福感是如何炼成的（上）","_content":"\n### 前言\n\n> 做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？\n\n近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成**外在因素**和**内在因素（技巧、技术提升）**两方面，这里分享**外在因素**。\n\n### 重要的几个点\n\n<!-- more -->\n\n在说外在因素之前，先看以下一些点：\n\n* 熟知业务，熟悉产品原型\n* 积极参加项目评审\n* 技术评估，了解技术实现的细节，确定技术边界\n* 全局视野，业务、技术拓展性\n\n不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？\n\n### 于产品而言\n\n> 熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。\n\n很多时候技术跟产品的撕x，都是因为沟通不顺畅。\n\n我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。\n\n前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。\n\n### 于后端而言\n\n前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？\n\n* 发现潜在的坑与隐藏的业务，及时让后端同学补充接口\n* 制定接口文档规范，提高对接效率\n* 接口提供时间节点（很重要！防止接口拖延！）\n* 数据模拟，提前对接\n\n这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过`yApi`、`mock`、`easy-mock`等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。\n\n### 于测试而言\n\n当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？**主动提供复杂的交互测试指引**。\n\n很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。\n\n### 结语\n\n最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。","source":"_posts/前端幸福感是如何炼成的.md","raw":"---\n\ntitle: 前端幸福感是如何炼成的（上）\ncategories:\n - 前端\ntags:\n - 总结\n---\n\n### 前言\n\n> 做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？\n\n近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成**外在因素**和**内在因素（技巧、技术提升）**两方面，这里分享**外在因素**。\n\n### 重要的几个点\n\n<!-- more -->\n\n在说外在因素之前，先看以下一些点：\n\n* 熟知业务，熟悉产品原型\n* 积极参加项目评审\n* 技术评估，了解技术实现的细节，确定技术边界\n* 全局视野，业务、技术拓展性\n\n不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？\n\n### 于产品而言\n\n> 熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。\n\n很多时候技术跟产品的撕x，都是因为沟通不顺畅。\n\n我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。\n\n前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。\n\n### 于后端而言\n\n前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？\n\n* 发现潜在的坑与隐藏的业务，及时让后端同学补充接口\n* 制定接口文档规范，提高对接效率\n* 接口提供时间节点（很重要！防止接口拖延！）\n* 数据模拟，提前对接\n\n这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过`yApi`、`mock`、`easy-mock`等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。\n\n### 于测试而言\n\n当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？**主动提供复杂的交互测试指引**。\n\n很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。\n\n### 结语\n\n最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。","slug":"前端幸福感是如何炼成的","published":1,"date":"2019-10-04T14:58:44.900Z","updated":"2020-01-21T03:26:19.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4ll000uhsuhox3hbu5w","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？</p>\n</blockquote>\n<p>近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成<strong>外在因素</strong>和<strong>内在因素（技巧、技术提升）</strong>两方面，这里分享<strong>外在因素</strong>。</p>\n<h3 id=\"重要的几个点\"><a href=\"#重要的几个点\" class=\"headerlink\" title=\"重要的几个点\"></a>重要的几个点</h3><a id=\"more\"></a>\n\n<p>在说外在因素之前，先看以下一些点：</p>\n<ul>\n<li>熟知业务，熟悉产品原型</li>\n<li>积极参加项目评审</li>\n<li>技术评估，了解技术实现的细节，确定技术边界</li>\n<li>全局视野，业务、技术拓展性</li>\n</ul>\n<p>不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？</p>\n<h3 id=\"于产品而言\"><a href=\"#于产品而言\" class=\"headerlink\" title=\"于产品而言\"></a>于产品而言</h3><blockquote>\n<p>熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。</p>\n</blockquote>\n<p>很多时候技术跟产品的撕x，都是因为沟通不顺畅。</p>\n<p>我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。</p>\n<p>前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。</p>\n<h3 id=\"于后端而言\"><a href=\"#于后端而言\" class=\"headerlink\" title=\"于后端而言\"></a>于后端而言</h3><p>前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？</p>\n<ul>\n<li>发现潜在的坑与隐藏的业务，及时让后端同学补充接口</li>\n<li>制定接口文档规范，提高对接效率</li>\n<li>接口提供时间节点（很重要！防止接口拖延！）</li>\n<li>数据模拟，提前对接</li>\n</ul>\n<p>这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过<code>yApi</code>、<code>mock</code>、<code>easy-mock</code>等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。</p>\n<h3 id=\"于测试而言\"><a href=\"#于测试而言\" class=\"headerlink\" title=\"于测试而言\"></a>于测试而言</h3><p>当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？<strong>主动提供复杂的交互测试指引</strong>。</p>\n<p>很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？</p>\n</blockquote>\n<p>近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成<strong>外在因素</strong>和<strong>内在因素（技巧、技术提升）</strong>两方面，这里分享<strong>外在因素</strong>。</p>\n<h3 id=\"重要的几个点\"><a href=\"#重要的几个点\" class=\"headerlink\" title=\"重要的几个点\"></a>重要的几个点</h3>","more":"<p>在说外在因素之前，先看以下一些点：</p>\n<ul>\n<li>熟知业务，熟悉产品原型</li>\n<li>积极参加项目评审</li>\n<li>技术评估，了解技术实现的细节，确定技术边界</li>\n<li>全局视野，业务、技术拓展性</li>\n</ul>\n<p>不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？</p>\n<h3 id=\"于产品而言\"><a href=\"#于产品而言\" class=\"headerlink\" title=\"于产品而言\"></a>于产品而言</h3><blockquote>\n<p>熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。</p>\n</blockquote>\n<p>很多时候技术跟产品的撕x，都是因为沟通不顺畅。</p>\n<p>我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。</p>\n<p>前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。</p>\n<h3 id=\"于后端而言\"><a href=\"#于后端而言\" class=\"headerlink\" title=\"于后端而言\"></a>于后端而言</h3><p>前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？</p>\n<ul>\n<li>发现潜在的坑与隐藏的业务，及时让后端同学补充接口</li>\n<li>制定接口文档规范，提高对接效率</li>\n<li>接口提供时间节点（很重要！防止接口拖延！）</li>\n<li>数据模拟，提前对接</li>\n</ul>\n<p>这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过<code>yApi</code>、<code>mock</code>、<code>easy-mock</code>等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。</p>\n<h3 id=\"于测试而言\"><a href=\"#于测试而言\" class=\"headerlink\" title=\"于测试而言\"></a>于测试而言</h3><p>当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？<strong>主动提供复杂的交互测试指引</strong>。</p>\n<p>很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。</p>"},{"title":"回归初心，重新出发","_content":"\n很长时间没有写博客，之前有基于**hexo**+**NextT**搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。\n\n现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。\n\n<!-- more -->\n\n现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。\n\n现在重新基于**hexo**+**icarus**来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。","source":"_posts/回归初心，重新出发.md","raw":"---\ntitle: 回归初心，重新出发\ncategories:\n - 生活\ntags: \n - 感想\n---\n\n很长时间没有写博客，之前有基于**hexo**+**NextT**搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。\n\n现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。\n\n<!-- more -->\n\n现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。\n\n现在重新基于**hexo**+**icarus**来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。","slug":"回归初心，重新出发","published":1,"date":"2019-09-24T15:12:29.623Z","updated":"2019-09-25T03:13:05.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4ln000xhsuhgsiw6yvc","content":"<p>很长时间没有写博客，之前有基于<strong>hexo</strong>+<strong>NextT</strong>搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。</p>\n<p>现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。</p>\n<a id=\"more\"></a>\n\n<p>现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。</p>\n<p>现在重新基于<strong>hexo</strong>+<strong>icarus</strong>来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。</p>\n","site":{"data":{}},"excerpt":"<p>很长时间没有写博客，之前有基于<strong>hexo</strong>+<strong>NextT</strong>搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。</p>\n<p>现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。</p>","more":"<p>现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。</p>\n<p>现在重新基于<strong>hexo</strong>+<strong>icarus</strong>来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。</p>"},{"title":"左手绿皮，右手红宝","_content":"\n\n\n买的两本书今天都到了，就是前端比较热门和重量级的两本书：**《JavaScript语言精髓和编程实践（第三版）》**和**《JavaScript高级程序设计（第四版）》**，也就是大家常说的绿皮书和红宝书，一本是今年4月份出版，一本是9月份刚出版。\n\n献上图过过瘾\n\n<!-- more -->\n\n<img src=\"/images/3and4.jpg\" alt=\"绿皮书和红宝书\" width=\"560\" height=\"400\"/>\n\n看了目录以及部分内容，个人感觉绿皮书是偏“**阐释**”的，就像是修炼JS内功，目的在于告诉你**为什么**，而不是教你**如何用**，跟市面上其它书就是**思维型**与**实战型**的区别。\n\n红宝书还是一如既往地适合各个阶段的前端开发者阅读，时隔8年，第三版坐着的小孩如今也已经站了起来。今年第四版图灵更是贴心地提供了**前端学习路线图**和**第四版阅读路线图**，这对于新手和刚入门的前端算是指引了前进的方向。看下路线图长啥样：\n\n<img src=\"/images/red4route.jpg\" alt=\"高4阅读路线\" width=\"490\" height=\"350\" />\n\n<img src=\"/images/tllearnroute.jpg\" alt=\"图灵前端学习路线\" width=\"490\" height=\"350\" />\n\n这两本“**厚重**”的书够看一段时间了，加上昨天尤大大官宣`vue3.0 one piece`发布，需要看的东西又多了起来，只能左手绿皮，右手红宝努力去找寻前端的**one piece**了~\n\n","source":"_posts/左手绿皮，右手红宝.md","raw":"---\ntitle: 左手绿皮，右手红宝\ncategories:\n - 书籍\ntags:\n - JS\n---\n\n\n\n买的两本书今天都到了，就是前端比较热门和重量级的两本书：**《JavaScript语言精髓和编程实践（第三版）》**和**《JavaScript高级程序设计（第四版）》**，也就是大家常说的绿皮书和红宝书，一本是今年4月份出版，一本是9月份刚出版。\n\n献上图过过瘾\n\n<!-- more -->\n\n<img src=\"/images/3and4.jpg\" alt=\"绿皮书和红宝书\" width=\"560\" height=\"400\"/>\n\n看了目录以及部分内容，个人感觉绿皮书是偏“**阐释**”的，就像是修炼JS内功，目的在于告诉你**为什么**，而不是教你**如何用**，跟市面上其它书就是**思维型**与**实战型**的区别。\n\n红宝书还是一如既往地适合各个阶段的前端开发者阅读，时隔8年，第三版坐着的小孩如今也已经站了起来。今年第四版图灵更是贴心地提供了**前端学习路线图**和**第四版阅读路线图**，这对于新手和刚入门的前端算是指引了前进的方向。看下路线图长啥样：\n\n<img src=\"/images/red4route.jpg\" alt=\"高4阅读路线\" width=\"490\" height=\"350\" />\n\n<img src=\"/images/tllearnroute.jpg\" alt=\"图灵前端学习路线\" width=\"490\" height=\"350\" />\n\n这两本“**厚重**”的书够看一段时间了，加上昨天尤大大官宣`vue3.0 one piece`发布，需要看的东西又多了起来，只能左手绿皮，右手红宝努力去找寻前端的**one piece**了~\n\n","slug":"左手绿皮，右手红宝","published":1,"date":"2020-09-20T06:53:21.928Z","updated":"2020-09-20T08:30:01.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4lq0012hsuh0keuzmxf","content":"<p>买的两本书今天都到了，就是前端比较热门和重量级的两本书：<strong>《JavaScript语言精髓和编程实践（第三版）》</strong>和<strong>《JavaScript高级程序设计（第四版）》</strong>，也就是大家常说的绿皮书和红宝书，一本是今年4月份出版，一本是9月份刚出版。</p>\n<p>献上图过过瘾</p>\n<a id=\"more\"></a>\n\n<img src=\"/images/3and4.jpg\" alt=\"绿皮书和红宝书\" width=\"560\" height=\"400\">\n\n<p>看了目录以及部分内容，个人感觉绿皮书是偏“<strong>阐释</strong>”的，就像是修炼JS内功，目的在于告诉你<strong>为什么</strong>，而不是教你<strong>如何用</strong>，跟市面上其它书就是<strong>思维型</strong>与<strong>实战型</strong>的区别。</p>\n<p>红宝书还是一如既往地适合各个阶段的前端开发者阅读，时隔8年，第三版坐着的小孩如今也已经站了起来。今年第四版图灵更是贴心地提供了<strong>前端学习路线图</strong>和<strong>第四版阅读路线图</strong>，这对于新手和刚入门的前端算是指引了前进的方向。看下路线图长啥样：</p>\n<img src=\"/images/red4route.jpg\" alt=\"高4阅读路线\" width=\"490\" height=\"350\">\n\n<img src=\"/images/tllearnroute.jpg\" alt=\"图灵前端学习路线\" width=\"490\" height=\"350\">\n\n<p>这两本“<strong>厚重</strong>”的书够看一段时间了，加上昨天尤大大官宣<code>vue3.0 one piece</code>发布，需要看的东西又多了起来，只能左手绿皮，右手红宝努力去找寻前端的<strong>one piece</strong>了~</p>\n","site":{"data":{}},"excerpt":"<p>买的两本书今天都到了，就是前端比较热门和重量级的两本书：<strong>《JavaScript语言精髓和编程实践（第三版）》</strong>和<strong>《JavaScript高级程序设计（第四版）》</strong>，也就是大家常说的绿皮书和红宝书，一本是今年4月份出版，一本是9月份刚出版。</p>\n<p>献上图过过瘾</p>","more":"<img src=\"/images/3and4.jpg\" alt=\"绿皮书和红宝书\" width=\"560\" height=\"400\">\n\n<p>看了目录以及部分内容，个人感觉绿皮书是偏“<strong>阐释</strong>”的，就像是修炼JS内功，目的在于告诉你<strong>为什么</strong>，而不是教你<strong>如何用</strong>，跟市面上其它书就是<strong>思维型</strong>与<strong>实战型</strong>的区别。</p>\n<p>红宝书还是一如既往地适合各个阶段的前端开发者阅读，时隔8年，第三版坐着的小孩如今也已经站了起来。今年第四版图灵更是贴心地提供了<strong>前端学习路线图</strong>和<strong>第四版阅读路线图</strong>，这对于新手和刚入门的前端算是指引了前进的方向。看下路线图长啥样：</p>\n<img src=\"/images/red4route.jpg\" alt=\"高4阅读路线\" width=\"490\" height=\"350\">\n\n<img src=\"/images/tllearnroute.jpg\" alt=\"图灵前端学习路线\" width=\"490\" height=\"350\">\n\n<p>这两本“<strong>厚重</strong>”的书够看一段时间了，加上昨天尤大大官宣<code>vue3.0 one piece</code>发布，需要看的东西又多了起来，只能左手绿皮，右手红宝努力去找寻前端的<strong>one piece</strong>了~</p>"},{"title":"开发一个UI框架项目[2]-Button","_content":"\n## 设计细节\n\n1. 高度最好为**8**的倍数，此处设置为**32px**；如果要支持大小类型的按钮，可设置为**24px**(**small**)和**40px**(**large**)；\n2. 按钮不设置固定宽度，左右`padding`设置为**1em**，表示左右各留一个字的空间；\n3. 因为`button`设置为`inline-flex`布局，在多个按钮并列时会存在位置不对齐的问题，使用`vertical-align: middle`解决。\n\n<!-- more -->\n\n## 功能细节\n\n1. 支持icon的设置。比较常见的场景是icon在文案左边或者右边，这个可以通过传入一个`iconPosition`为**left**或**right**来决定，一开始的想法是通过`v-if`来决定显示哪一行：\n\n```vue\n<button>\n  <yv-icon v-if=\"iconPosition === 'left'\"></yv-icon>\n  <div class=\"button-content\"></div>\n  <yv-icon v-if=\"iconPosition === 'right'\"></yv-icon>\n</button>\n```\n\n但是这种做法有点low，也多了一行没必要的重复代码，然后想到`flex`有一个`order`的属性，可以决定子元素布局的排列优先级，`template`修改成如下：\n\n```vue\n<template>\n    <button class=\"yv-button\" :class=\"{[`icon-${iconPosition}`]: true}\">\n      <div class=\"button-content\">\n        <slot></slot>\n      </div>\n      <yv-icon class=\"icon\"></yv-icon>\n    </button>\n</template>\n<style scoped lang=\"scss\">\n  .yv-button {\n    > .button-content {\n      order: 2;\n    }\n    > .icon {\n      order: 1;\n    }\n    &.icon-right {\n      > .button-content {\n        order: 1;\n      } \n      > .icon {\n        order: 2;\n      } \n    } \n  }\n</style>\n```\n\n一开始设置icon的`order`为**1**表示默认icon是在左边，当用户传了`iconPosition`为**right**时，就会给`button`加上\n`icon-right`的**class**名，这时icon的`order`设置为**2**，`content`的`order`设置为**1**，这样在不修改代码的情况下，通过`order`的值就可以设置icon的显示位置。\n\n2. 支持loading的设置。因为loading也要有图标，所以需要处理loading时不出现其它图标的情况，增加一个判断条件：\n\n```vue\n<button>\n  <div class=\"button-content\">\n    <slot></slot>\n  </div>\n  <yv-icon class=\"icon\" v-if=\"icon && !loading\" :name=\"name\"></yv-icon>\n  <yv-icon class=\"loading icon\" v-if=\"loading\" name=\"loading\"></yv-icon>\n</button>\n```\n\n3. 让loading的图标动起来。因为**iconfont**上面的图标都是静态的，而loading是要动起来的。仔细想了一下，loading就是360°不断地旋转，那我们只要写一个旋转的动画处理就可以，如下：\n\n```css\n@keyframes spin{\n  0% {transform: rotate(0deg)}\n  100% {transform: rotate(360deg)}\n}\n\n.loading {\n  animation: spin 1s infinite linear;\n}\n```\n\n4. 按钮组合。按钮组合应该让按钮衔接看起来顺滑一点，这里采取的默认方案是按钮紧挨，然后第一个按钮和最后一个按钮的边缘钝化，同时中间的按钮应向前靠**1像素**，因为`button`都有`border`，看起来会很粗。代码如下：\n\n```vue\n<style scoped lang=\"scss\">\n$button-radius: 4px;\n.yv-button-group {\n  display: inline-flex;\n  vertical-align: middle;\n  .yv-button {\n    border-radius: 0;\n    &:not(:first-child) {\n      margin-left: -1px;\n    }\n    &:first-child {\n      border-bottom-left-radius: $button-radius;\n      border-top-left-radius: $button-radius;\n    }\n    &:last-child {\n      border-top-right-radius: $button-radius;\n      border-bottom-right-radius: $button-radius;\n    }\n  }\n}\n</style>\n```\n\n## 人工测试\n\n手动测试。。。已完成。\n\n## 自动化测试\n\n在**test**文件夹下增加`button.test.js`文件。\n\n主要增加**7**个测试用例，分别是：**测试button是否存在**、**设置icon**、**icon初始位置**、**设置icon位置**、**设置loading**、**设置disabled**、**click点击事件**。\n\n运行`npm run dev-test`命令，是配置在package.json文件中的该命令：`parcel watch test/* --no-cache & karma start`，就是监听、打包test文件夹下的*.test.js文件，然后运行karma开始自动化测试，测试结果可在浏览器控制台查看：\n\n\n\n![浏览器控制台显示](/images/browser.png)\n\n或者powershell面板查看：\n\n\n\n![powershell显示](/images/powershell.png)\n\n## vuepress配置\n\n在**docs/.vuepress/components**文件夹下增加`button-demo`的vue文件，内容就是我们要展示的`button`示例，然后在**docs/components**文件夹下增加`button`的md文件，内容就是放置整个`button`组件说明。\n\n具体内容请[访问这里](https://ysom.github.io/yvue-ui/components/button.html)","source":"_posts/开发一个UI框架-button.md","raw":"---\ntitle: 开发一个UI框架项目[2]-Button\ncategories:\n - 前端\ntags:\n - vue\n---\n\n## 设计细节\n\n1. 高度最好为**8**的倍数，此处设置为**32px**；如果要支持大小类型的按钮，可设置为**24px**(**small**)和**40px**(**large**)；\n2. 按钮不设置固定宽度，左右`padding`设置为**1em**，表示左右各留一个字的空间；\n3. 因为`button`设置为`inline-flex`布局，在多个按钮并列时会存在位置不对齐的问题，使用`vertical-align: middle`解决。\n\n<!-- more -->\n\n## 功能细节\n\n1. 支持icon的设置。比较常见的场景是icon在文案左边或者右边，这个可以通过传入一个`iconPosition`为**left**或**right**来决定，一开始的想法是通过`v-if`来决定显示哪一行：\n\n```vue\n<button>\n  <yv-icon v-if=\"iconPosition === 'left'\"></yv-icon>\n  <div class=\"button-content\"></div>\n  <yv-icon v-if=\"iconPosition === 'right'\"></yv-icon>\n</button>\n```\n\n但是这种做法有点low，也多了一行没必要的重复代码，然后想到`flex`有一个`order`的属性，可以决定子元素布局的排列优先级，`template`修改成如下：\n\n```vue\n<template>\n    <button class=\"yv-button\" :class=\"{[`icon-${iconPosition}`]: true}\">\n      <div class=\"button-content\">\n        <slot></slot>\n      </div>\n      <yv-icon class=\"icon\"></yv-icon>\n    </button>\n</template>\n<style scoped lang=\"scss\">\n  .yv-button {\n    > .button-content {\n      order: 2;\n    }\n    > .icon {\n      order: 1;\n    }\n    &.icon-right {\n      > .button-content {\n        order: 1;\n      } \n      > .icon {\n        order: 2;\n      } \n    } \n  }\n</style>\n```\n\n一开始设置icon的`order`为**1**表示默认icon是在左边，当用户传了`iconPosition`为**right**时，就会给`button`加上\n`icon-right`的**class**名，这时icon的`order`设置为**2**，`content`的`order`设置为**1**，这样在不修改代码的情况下，通过`order`的值就可以设置icon的显示位置。\n\n2. 支持loading的设置。因为loading也要有图标，所以需要处理loading时不出现其它图标的情况，增加一个判断条件：\n\n```vue\n<button>\n  <div class=\"button-content\">\n    <slot></slot>\n  </div>\n  <yv-icon class=\"icon\" v-if=\"icon && !loading\" :name=\"name\"></yv-icon>\n  <yv-icon class=\"loading icon\" v-if=\"loading\" name=\"loading\"></yv-icon>\n</button>\n```\n\n3. 让loading的图标动起来。因为**iconfont**上面的图标都是静态的，而loading是要动起来的。仔细想了一下，loading就是360°不断地旋转，那我们只要写一个旋转的动画处理就可以，如下：\n\n```css\n@keyframes spin{\n  0% {transform: rotate(0deg)}\n  100% {transform: rotate(360deg)}\n}\n\n.loading {\n  animation: spin 1s infinite linear;\n}\n```\n\n4. 按钮组合。按钮组合应该让按钮衔接看起来顺滑一点，这里采取的默认方案是按钮紧挨，然后第一个按钮和最后一个按钮的边缘钝化，同时中间的按钮应向前靠**1像素**，因为`button`都有`border`，看起来会很粗。代码如下：\n\n```vue\n<style scoped lang=\"scss\">\n$button-radius: 4px;\n.yv-button-group {\n  display: inline-flex;\n  vertical-align: middle;\n  .yv-button {\n    border-radius: 0;\n    &:not(:first-child) {\n      margin-left: -1px;\n    }\n    &:first-child {\n      border-bottom-left-radius: $button-radius;\n      border-top-left-radius: $button-radius;\n    }\n    &:last-child {\n      border-top-right-radius: $button-radius;\n      border-bottom-right-radius: $button-radius;\n    }\n  }\n}\n</style>\n```\n\n## 人工测试\n\n手动测试。。。已完成。\n\n## 自动化测试\n\n在**test**文件夹下增加`button.test.js`文件。\n\n主要增加**7**个测试用例，分别是：**测试button是否存在**、**设置icon**、**icon初始位置**、**设置icon位置**、**设置loading**、**设置disabled**、**click点击事件**。\n\n运行`npm run dev-test`命令，是配置在package.json文件中的该命令：`parcel watch test/* --no-cache & karma start`，就是监听、打包test文件夹下的*.test.js文件，然后运行karma开始自动化测试，测试结果可在浏览器控制台查看：\n\n\n\n![浏览器控制台显示](/images/browser.png)\n\n或者powershell面板查看：\n\n\n\n![powershell显示](/images/powershell.png)\n\n## vuepress配置\n\n在**docs/.vuepress/components**文件夹下增加`button-demo`的vue文件，内容就是我们要展示的`button`示例，然后在**docs/components**文件夹下增加`button`的md文件，内容就是放置整个`button`组件说明。\n\n具体内容请[访问这里](https://ysom.github.io/yvue-ui/components/button.html)","slug":"开发一个UI框架-button","published":1,"date":"2020-09-04T15:56:37.721Z","updated":"2020-09-12T14:15:29.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4lt0015hsuh4y5mz7ys","content":"<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><ol>\n<li>高度最好为<strong>8</strong>的倍数，此处设置为<strong>32px</strong>；如果要支持大小类型的按钮，可设置为<strong>24px</strong>(<strong>small</strong>)和<strong>40px</strong>(<strong>large</strong>)；</li>\n<li>按钮不设置固定宽度，左右<code>padding</code>设置为<strong>1em</strong>，表示左右各留一个字的空间；</li>\n<li>因为<code>button</code>设置为<code>inline-flex</code>布局，在多个按钮并列时会存在位置不对齐的问题，使用<code>vertical-align: middle</code>解决。</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"功能细节\"><a href=\"#功能细节\" class=\"headerlink\" title=\"功能细节\"></a>功能细节</h2><ol>\n<li>支持icon的设置。比较常见的场景是icon在文案左边或者右边，这个可以通过传入一个<code>iconPosition</code>为<strong>left</strong>或<strong>right</strong>来决定，一开始的想法是通过<code>v-if</code>来决定显示哪一行：</li>\n</ol>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button&gt;</span><br><span class=\"line\">  &lt;yv-icon v-if=&quot;iconPosition === &apos;left&apos;&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">  &lt;div class=&quot;button-content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;yv-icon v-if=&quot;iconPosition === &apos;right&apos;&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种做法有点low，也多了一行没必要的重复代码，然后想到<code>flex</code>有一个<code>order</code>的属性，可以决定子元素布局的排列优先级，<code>template</code>修改成如下：</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;button class=&quot;yv-button&quot; :class=&quot;&#123;[`icon-$&#123;iconPosition&#125;`]: true&#125;&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;button-content&quot;&gt;</span><br><span class=\"line\">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;yv-icon class=&quot;icon&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">    &lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class=\"line\">  .yv-button &#123;</span><br><span class=\"line\">    &gt; .button-content &#123;</span><br><span class=\"line\">      order: 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &gt; .icon &#123;</span><br><span class=\"line\">      order: 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;.icon-right &#123;</span><br><span class=\"line\">      &gt; .button-content &#123;</span><br><span class=\"line\">        order: 1;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      &gt; .icon &#123;</span><br><span class=\"line\">        order: 2;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一开始设置icon的<code>order</code>为<strong>1</strong>表示默认icon是在左边，当用户传了<code>iconPosition</code>为<strong>right</strong>时，就会给<code>button</code>加上<br><code>icon-right</code>的<strong>class</strong>名，这时icon的<code>order</code>设置为<strong>2</strong>，<code>content</code>的<code>order</code>设置为<strong>1</strong>，这样在不修改代码的情况下，通过<code>order</code>的值就可以设置icon的显示位置。</p>\n<ol start=\"2\">\n<li>支持loading的设置。因为loading也要有图标，所以需要处理loading时不出现其它图标的情况，增加一个判断条件：</li>\n</ol>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button&gt;</span><br><span class=\"line\">  &lt;div class=&quot;button-content&quot;&gt;</span><br><span class=\"line\">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;yv-icon class=&quot;icon&quot; v-if=&quot;icon &amp;&amp; !loading&quot; :name=&quot;name&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">  &lt;yv-icon class=&quot;loading icon&quot; v-if=&quot;loading&quot; name=&quot;loading&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>让loading的图标动起来。因为<strong>iconfont</strong>上面的图标都是静态的，而loading是要动起来的。仔细想了一下，loading就是360°不断地旋转，那我们只要写一个旋转的动画处理就可以，如下：</li>\n</ol>\n<figure class=\"highlight css hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"hljs-keyword\">keyframes</span> spin&#123;</span><br><span class=\"line\">  0% &#123;<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">rotate</span>(0deg)&#125;</span><br><span class=\"line\">  100% &#123;<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">rotate</span>(360deg)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-selector-class\">.loading</span> &#123;</span><br><span class=\"line\">  <span class=\"hljs-attribute\">animation</span>: spin <span class=\"hljs-number\">1s</span> infinite linear;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>按钮组合。按钮组合应该让按钮衔接看起来顺滑一点，这里采取的默认方案是按钮紧挨，然后第一个按钮和最后一个按钮的边缘钝化，同时中间的按钮应向前靠<strong>1像素</strong>，因为<code>button</code>都有<code>border</code>，看起来会很粗。代码如下：</li>\n</ol>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class=\"line\">$button-radius: 4px;</span><br><span class=\"line\">.yv-button-group &#123;</span><br><span class=\"line\">  display: inline-flex;</span><br><span class=\"line\">  vertical-align: middle;</span><br><span class=\"line\">  .yv-button &#123;</span><br><span class=\"line\">    border-radius: 0;</span><br><span class=\"line\">    &amp;:not(:first-child) &#123;</span><br><span class=\"line\">      margin-left: -1px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      border-bottom-left-radius: $button-radius;</span><br><span class=\"line\">      border-top-left-radius: $button-radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:last-child &#123;</span><br><span class=\"line\">      border-top-right-radius: $button-radius;</span><br><span class=\"line\">      border-bottom-right-radius: $button-radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"人工测试\"><a href=\"#人工测试\" class=\"headerlink\" title=\"人工测试\"></a>人工测试</h2><p>手动测试。。。已完成。</p>\n<h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><p>在<strong>test</strong>文件夹下增加<code>button.test.js</code>文件。</p>\n<p>主要增加<strong>7</strong>个测试用例，分别是：<strong>测试button是否存在</strong>、<strong>设置icon</strong>、<strong>icon初始位置</strong>、<strong>设置icon位置</strong>、<strong>设置loading</strong>、<strong>设置disabled</strong>、<strong>click点击事件</strong>。</p>\n<p>运行<code>npm run dev-test</code>命令，是配置在package.json文件中的该命令：<code>parcel watch test/* --no-cache &amp; karma start</code>，就是监听、打包test文件夹下的*.test.js文件，然后运行karma开始自动化测试，测试结果可在浏览器控制台查看：</p>\n<p><img src=\"/images/browser.png\" alt=\"浏览器控制台显示\"></p>\n<p>或者powershell面板查看：</p>\n<p><img src=\"/images/powershell.png\" alt=\"powershell显示\"></p>\n<h2 id=\"vuepress配置\"><a href=\"#vuepress配置\" class=\"headerlink\" title=\"vuepress配置\"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>button-demo</code>的vue文件，内容就是我们要展示的<code>button</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>button</code>的md文件，内容就是放置整个<code>button</code>组件说明。</p>\n<p>具体内容请<a href=\"https://ysom.github.io/yvue-ui/components/button.html\" target=\"_blank\" rel=\"noopener\">访问这里</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><ol>\n<li>高度最好为<strong>8</strong>的倍数，此处设置为<strong>32px</strong>；如果要支持大小类型的按钮，可设置为<strong>24px</strong>(<strong>small</strong>)和<strong>40px</strong>(<strong>large</strong>)；</li>\n<li>按钮不设置固定宽度，左右<code>padding</code>设置为<strong>1em</strong>，表示左右各留一个字的空间；</li>\n<li>因为<code>button</code>设置为<code>inline-flex</code>布局，在多个按钮并列时会存在位置不对齐的问题，使用<code>vertical-align: middle</code>解决。</li>\n</ol>","more":"<h2 id=\"功能细节\"><a href=\"#功能细节\" class=\"headerlink\" title=\"功能细节\"></a>功能细节</h2><ol>\n<li>支持icon的设置。比较常见的场景是icon在文案左边或者右边，这个可以通过传入一个<code>iconPosition</code>为<strong>left</strong>或<strong>right</strong>来决定，一开始的想法是通过<code>v-if</code>来决定显示哪一行：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button&gt;</span><br><span class=\"line\">  &lt;yv-icon v-if=&quot;iconPosition === &apos;left&apos;&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">  &lt;div class=&quot;button-content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">  &lt;yv-icon v-if=&quot;iconPosition === &apos;right&apos;&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是这种做法有点low，也多了一行没必要的重复代码，然后想到<code>flex</code>有一个<code>order</code>的属性，可以决定子元素布局的排列优先级，<code>template</code>修改成如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;button class=&quot;yv-button&quot; :class=&quot;&#123;[`icon-$&#123;iconPosition&#125;`]: true&#125;&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;button-content&quot;&gt;</span><br><span class=\"line\">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;yv-icon class=&quot;icon&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">    &lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class=\"line\">  .yv-button &#123;</span><br><span class=\"line\">    &gt; .button-content &#123;</span><br><span class=\"line\">      order: 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &gt; .icon &#123;</span><br><span class=\"line\">      order: 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;.icon-right &#123;</span><br><span class=\"line\">      &gt; .button-content &#123;</span><br><span class=\"line\">        order: 1;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      &gt; .icon &#123;</span><br><span class=\"line\">        order: 2;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一开始设置icon的<code>order</code>为<strong>1</strong>表示默认icon是在左边，当用户传了<code>iconPosition</code>为<strong>right</strong>时，就会给<code>button</code>加上<br><code>icon-right</code>的<strong>class</strong>名，这时icon的<code>order</code>设置为<strong>2</strong>，<code>content</code>的<code>order</code>设置为<strong>1</strong>，这样在不修改代码的情况下，通过<code>order</code>的值就可以设置icon的显示位置。</p>\n<ol start=\"2\">\n<li>支持loading的设置。因为loading也要有图标，所以需要处理loading时不出现其它图标的情况，增加一个判断条件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button&gt;</span><br><span class=\"line\">  &lt;div class=&quot;button-content&quot;&gt;</span><br><span class=\"line\">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;yv-icon class=&quot;icon&quot; v-if=&quot;icon &amp;&amp; !loading&quot; :name=&quot;name&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">  &lt;yv-icon class=&quot;loading icon&quot; v-if=&quot;loading&quot; name=&quot;loading&quot;&gt;&lt;/yv-icon&gt;</span><br><span class=\"line\">&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>让loading的图标动起来。因为<strong>iconfont</strong>上面的图标都是静态的，而loading是要动起来的。仔细想了一下，loading就是360°不断地旋转，那我们只要写一个旋转的动画处理就可以，如下：</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">keyframes</span> spin&#123;</span><br><span class=\"line\">  0% &#123;<span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(0deg)&#125;</span><br><span class=\"line\">  100% &#123;<span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(360deg)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.loading</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: spin <span class=\"number\">1s</span> infinite linear;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>按钮组合。按钮组合应该让按钮衔接看起来顺滑一点，这里采取的默认方案是按钮紧挨，然后第一个按钮和最后一个按钮的边缘钝化，同时中间的按钮应向前靠<strong>1像素</strong>，因为<code>button</code>都有<code>border</code>，看起来会很粗。代码如下：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class=\"line\">$button-radius: 4px;</span><br><span class=\"line\">.yv-button-group &#123;</span><br><span class=\"line\">  display: inline-flex;</span><br><span class=\"line\">  vertical-align: middle;</span><br><span class=\"line\">  .yv-button &#123;</span><br><span class=\"line\">    border-radius: 0;</span><br><span class=\"line\">    &amp;:not(:first-child) &#123;</span><br><span class=\"line\">      margin-left: -1px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      border-bottom-left-radius: $button-radius;</span><br><span class=\"line\">      border-top-left-radius: $button-radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:last-child &#123;</span><br><span class=\"line\">      border-top-right-radius: $button-radius;</span><br><span class=\"line\">      border-bottom-right-radius: $button-radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"人工测试\"><a href=\"#人工测试\" class=\"headerlink\" title=\"人工测试\"></a>人工测试</h2><p>手动测试。。。已完成。</p>\n<h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><p>在<strong>test</strong>文件夹下增加<code>button.test.js</code>文件。</p>\n<p>主要增加<strong>7</strong>个测试用例，分别是：<strong>测试button是否存在</strong>、<strong>设置icon</strong>、<strong>icon初始位置</strong>、<strong>设置icon位置</strong>、<strong>设置loading</strong>、<strong>设置disabled</strong>、<strong>click点击事件</strong>。</p>\n<p>运行<code>npm run dev-test</code>命令，是配置在package.json文件中的该命令：<code>parcel watch test/* --no-cache &amp; karma start</code>，就是监听、打包test文件夹下的*.test.js文件，然后运行karma开始自动化测试，测试结果可在浏览器控制台查看：</p>\n<p><img src=\"/images/browser.png\" alt=\"浏览器控制台显示\"></p>\n<p>或者powershell面板查看：</p>\n<p><img src=\"/images/powershell.png\" alt=\"powershell显示\"></p>\n<h2 id=\"vuepress配置\"><a href=\"#vuepress配置\" class=\"headerlink\" title=\"vuepress配置\"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>button-demo</code>的vue文件，内容就是我们要展示的<code>button</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>button</code>的md文件，内容就是放置整个<code>button</code>组件说明。</p>\n<p>具体内容请<a href=\"https://ysom.github.io/yvue-ui/components/button.html\" target=\"_blank\" rel=\"noopener\">访问这里</a></p>"},{"title":"开发一个UI框架项目[4]-Container","_content":"\n## 设计细节\n\n容器的功能比较简单，主要将页面切分成`头部header`、`侧边栏aside`、`主要区域main`、`底部footer`，这几个部分都放在`容器container`里。\n\n<!-- more -->\n\n在没有侧边栏的时候，container里的排列方向是`column`，当有侧边栏时，container里的排列方向就切换成`row`：\n\n```vue\n<script>\nexport default {\n  name: \"YvContainer\",\n  data() {\n    return {\n      containerClass: {\n        hasAside: false\n      }\n    }\n  },\n  mounted() {\n    this.$children.some(child => {\n      if (child.$options.name === 'YvAside') {\n        this.containerClass.hasAside = true\n        return true\n      }\n    })\n  }\n}\n</script>\n```\n\n通过遍历判断是否存在`aside`组件，存在`aside`的时候将`hasAside`设置为`true`，同时给`container`加上了`hasAside`的类，样式为`flex-direction: row`\n\n## vuepress配置\n\n在**docs/.vuepress/components**文件夹下增加`container-demo`的vue文件，内容就是我们要展示的`container`示例，然后在**docs/components**文件夹下增加`container`的md文件，内容就是放置整个`container`组件说明。","source":"_posts/开发一个UI框架-container.md","raw":"---\ntitle: 开发一个UI框架项目[4]-Container\ncategories:\n - 前端\ntags:\n - vue\n---\n\n## 设计细节\n\n容器的功能比较简单，主要将页面切分成`头部header`、`侧边栏aside`、`主要区域main`、`底部footer`，这几个部分都放在`容器container`里。\n\n<!-- more -->\n\n在没有侧边栏的时候，container里的排列方向是`column`，当有侧边栏时，container里的排列方向就切换成`row`：\n\n```vue\n<script>\nexport default {\n  name: \"YvContainer\",\n  data() {\n    return {\n      containerClass: {\n        hasAside: false\n      }\n    }\n  },\n  mounted() {\n    this.$children.some(child => {\n      if (child.$options.name === 'YvAside') {\n        this.containerClass.hasAside = true\n        return true\n      }\n    })\n  }\n}\n</script>\n```\n\n通过遍历判断是否存在`aside`组件，存在`aside`的时候将`hasAside`设置为`true`，同时给`container`加上了`hasAside`的类，样式为`flex-direction: row`\n\n## vuepress配置\n\n在**docs/.vuepress/components**文件夹下增加`container-demo`的vue文件，内容就是我们要展示的`container`示例，然后在**docs/components**文件夹下增加`container`的md文件，内容就是放置整个`container`组件说明。","slug":"开发一个UI框架-container","published":1,"date":"2020-09-16T15:19:01.433Z","updated":"2020-09-16T15:21:41.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4lv001ahsuh988njkz2","content":"<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><p>容器的功能比较简单，主要将页面切分成<code>头部header</code>、<code>侧边栏aside</code>、<code>主要区域main</code>、<code>底部footer</code>，这几个部分都放在<code>容器container</code>里。</p>\n<a id=\"more\"></a>\n\n<p>在没有侧边栏的时候，container里的排列方向是<code>column</code>，当有侧边栏时，container里的排列方向就切换成<code>row</code>：</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;YvContainer&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      containerClass: &#123;</span><br><span class=\"line\">        hasAside: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    this.$children.some(child =&gt; &#123;</span><br><span class=\"line\">      if (child.$options.name === &apos;YvAside&apos;) &#123;</span><br><span class=\"line\">        this.containerClass.hasAside = true</span><br><span class=\"line\">        return true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>通过遍历判断是否存在<code>aside</code>组件，存在<code>aside</code>的时候将<code>hasAside</code>设置为<code>true</code>，同时给<code>container</code>加上了<code>hasAside</code>的类，样式为<code>flex-direction: row</code></p>\n<h2 id=\"vuepress配置\"><a href=\"#vuepress配置\" class=\"headerlink\" title=\"vuepress配置\"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>container-demo</code>的vue文件，内容就是我们要展示的<code>container</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>container</code>的md文件，内容就是放置整个<code>container</code>组件说明。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><p>容器的功能比较简单，主要将页面切分成<code>头部header</code>、<code>侧边栏aside</code>、<code>主要区域main</code>、<code>底部footer</code>，这几个部分都放在<code>容器container</code>里。</p>","more":"<p>在没有侧边栏的时候，container里的排列方向是<code>column</code>，当有侧边栏时，container里的排列方向就切换成<code>row</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;YvContainer&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      containerClass: &#123;</span><br><span class=\"line\">        hasAside: false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    this.$children.some(child =&gt; &#123;</span><br><span class=\"line\">      if (child.$options.name === &apos;YvAside&apos;) &#123;</span><br><span class=\"line\">        this.containerClass.hasAside = true</span><br><span class=\"line\">        return true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>通过遍历判断是否存在<code>aside</code>组件，存在<code>aside</code>的时候将<code>hasAside</code>设置为<code>true</code>，同时给<code>container</code>加上了<code>hasAside</code>的类，样式为<code>flex-direction: row</code></p>\n<h2 id=\"vuepress配置\"><a href=\"#vuepress配置\" class=\"headerlink\" title=\"vuepress配置\"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>container-demo</code>的vue文件，内容就是我们要展示的<code>container</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>container</code>的md文件，内容就是放置整个<code>container</code>组件说明。</p>"},{"title":"开发一个UI框架项目[3]-Layout","_content":"\n## 设计细节\n1. `row`组件默认采用`flex`布局，可通过`left`、`center`、`right`来设置对齐方式；\n2. `row`组件可通过设置`gutter`参数来设置列之间的间隔；\n3. `col`组件可通过设置`span`参数来设置不同列数，默认将宽度分为**24**列，同时可搭配`offset`参数来设置分栏偏移数；\n4. 响应式布局传递的参数不采用`element-ui`那些`xs`、`sm`参数，字面上不利于理解，\n所以这里采用了`phone`、`iPad`、`narrowPC`和`widePC`等参数来分别表示在屏幕大小为\n手机、平板、窄屏PC端和宽屏PC端下的展示。\n\n<!-- more -->\n\n## 功能处理细节\n1. `span`设置分栏数。默认将页面宽度分成了24等分，再通过`span/24`来算出分栏的占比，那要怎么设置各占比分栏宽度呢？如果直接通过`yv-col-1 ~ 24`这样写24个类名，就会出现一堆重复的代码，维护、改动也麻烦。幸好可以通过**css预处理器**来处理这种情况，**预处理器**可以像JS那样写变量，函数，可以为我们提供很多方便的操作，这里采用了`scss`来处理：\n```scss\n@for $n from 1 through 24 {\n  $class-prefix: yv-col-;\n  &.#{$class-prefix}#{$n} {\n    width: ($n / 24) * 100%\n  }\n}\n```\n先设置通用前缀`yv-col-`，再通过for循环从1到24，算出每一份的宽度，这样就可以根据`span`的值得到对应的类名`yv-col-n`从而得到对应的宽度。包括`offset`设置偏移栏数也是如此：\n```scss\n@for $n from 1 through 24 {\n  $class-prefix:yv-col-offset-;\n  &.#{$class-prefix}#{$n} {\n    margin-left: ($n / 24) * 100%\n  }\n}\n```\n\n2. `gutter`传参问题。设置分栏间隔是通过在`row`组件上面传递`gutter`参数，但实际上我们还得靠处理`col`组件来实现。一开始直接像下面这样直接把`gutter`传个每个`col`组件：\n```vue\n<yv-row :gutter=\"10\">\n  <yv-col :gutter=\"10\"></yv-col>\n  <yv-col :gutter=\"10\"></yv-col>\n</yv-row>\n```\n看起来很不友好。这里可以使用父子组件通信的另一种方法：`$parent`和`$children`。如下：\n```vue\n<!-- Row.vue -->\nmounted() {\n  this.$children.forEach(child => {\n    child.gutter = this.gutter\n  })\n}\n\n<!-- Col.vue -->\ndata() {\n  return {\n    gutter: 0\n  }\n}\n```\n在`row`的生命周期`mounted`中通过`$children`给每个子组件的`gutter`属性赋值，同时`col`组件也要在`data`里面定义`gutter`属性。\n\n3. `gutter`具体设置问题。一开始的想法是直接给每一列的左右加上`gutter/2`的外边距，但是这会跟通过`offset`设置的偏移分栏外边距产生冲突。那么换成内边距如何呢？试下内边距的效果。\n![设置内边距效果](/images/gutter-padding.png)\n从图片可以发现最左边跟最右边的分栏没有紧挨父级容器，这是设置了内边距的原因，跟父容器的空隙就是`gutter/2`px。解决方案是给父级容器加上`-gutter/2`的左右外边距，就ok了。\n\n4. 响应式处理。这里采用了`phone`、`iPad`、`narrowPC`、`widePC`这种直观的字段来表示不同屏幕宽度。通过`createClasses`方法来创建不同的类名：\n```vue\ncomputed: {\n  colClass() {\n    let {\n      span,\n      offset,\n      phone,\n      iPad,\n      narrowPC,\n      widePC\n    } = this\n    return [\n      'yv-col',\n      ...this.createClasses(phone, 'phone-'),\n      ...this.createClasses(iPad, 'iPad-'),\n      ...this.createClasses(narrowPC, 'narrowPC-'),\n      ...this.createClasses(widePC, 'widePC-'),\n      ...this.createClasses({ span, offset })\n    ]\n  }\n},\n\nmethods: {\n  createClasses(obj, str = '') {\n    if (!obj) return []\n    let arr = []\n    if (obj.span) {\n      arr.push(`yv-col-${str}${obj.span}`)\n    }\n    if (obj.offset) {\n      arr.push(`yv-col-${str}offset-${obj.offset}`)\n    }\n    return arr\n  }\n}\n```\n设置一个计算属性`colClass`，根据传入不同的尺寸属性生成不同的class添加到col上面，再通过媒体查询的写法，来实现不同尺寸下的宽度计算：\n```scss\n@media (min-width: 0px) {\n  @for $n from 1 through 24 {\n    $class-prefix:yv-col-phone-;\n    &.#{$class-prefix}#{$n} {\n      width: ($n / 24) * 100%\n    }\n  }\n  @for $n from 1 through 24 {\n    $class-prefix:yv-col-phone-offset-;\n    &.#{$class-prefix}#{$n} {\n      margin-left: ($n / 24) * 100%\n    }\n  }\n}\n@media (min-width: 577px) {\n  // ...\n}\n@media (min-width: 769px) {\n  // ...\n}\n@media (min-width: 993px) {\n  // ...\n}\n@media (min-width: 1201px) {\n  // ...\n}\n```\n\n## 人工测试\n手动测试。。。已完成。\n\n## 自动化测试\n在**test**文件夹下增加`row.test.js`和`col.test.js`文件。\n\n`row.test.js`文件有3个测试用例：**测试row是否存在**、**接收getter**、**接收align**；\n\n`col.test.js`文件有7个测试用例：**测试col是否存在**、**接收span**、**接收offset**、**接收phone**、**接收iPad**、**接收narrowPC**、**接收widePC**。\n\n运行命令`parcel watch test/* --no-cache`和`karma start`查看测试结果：\n\n\n\n![layout测试结果](/images/layout-browser.png)\n\n## vuepress\n\n在**docs/.vuepress/components**文件夹下增加多个`layout-*`的vue文件，内容就是我们要展示的`layout`示例，然后在**docs/components**文件夹下增加`layout`的md文件，内容就是放置整个`layout`组件说明。\n\n具体内容请[访问这里](https://ysom.github.io/yvue-ui/components/layout.html)。","source":"_posts/开发一个UI框架-layout.md","raw":"---\ntitle: 开发一个UI框架项目[3]-Layout\ncategories:\n - 前端\ntags:\n - vue\n---\n\n## 设计细节\n1. `row`组件默认采用`flex`布局，可通过`left`、`center`、`right`来设置对齐方式；\n2. `row`组件可通过设置`gutter`参数来设置列之间的间隔；\n3. `col`组件可通过设置`span`参数来设置不同列数，默认将宽度分为**24**列，同时可搭配`offset`参数来设置分栏偏移数；\n4. 响应式布局传递的参数不采用`element-ui`那些`xs`、`sm`参数，字面上不利于理解，\n所以这里采用了`phone`、`iPad`、`narrowPC`和`widePC`等参数来分别表示在屏幕大小为\n手机、平板、窄屏PC端和宽屏PC端下的展示。\n\n<!-- more -->\n\n## 功能处理细节\n1. `span`设置分栏数。默认将页面宽度分成了24等分，再通过`span/24`来算出分栏的占比，那要怎么设置各占比分栏宽度呢？如果直接通过`yv-col-1 ~ 24`这样写24个类名，就会出现一堆重复的代码，维护、改动也麻烦。幸好可以通过**css预处理器**来处理这种情况，**预处理器**可以像JS那样写变量，函数，可以为我们提供很多方便的操作，这里采用了`scss`来处理：\n```scss\n@for $n from 1 through 24 {\n  $class-prefix: yv-col-;\n  &.#{$class-prefix}#{$n} {\n    width: ($n / 24) * 100%\n  }\n}\n```\n先设置通用前缀`yv-col-`，再通过for循环从1到24，算出每一份的宽度，这样就可以根据`span`的值得到对应的类名`yv-col-n`从而得到对应的宽度。包括`offset`设置偏移栏数也是如此：\n```scss\n@for $n from 1 through 24 {\n  $class-prefix:yv-col-offset-;\n  &.#{$class-prefix}#{$n} {\n    margin-left: ($n / 24) * 100%\n  }\n}\n```\n\n2. `gutter`传参问题。设置分栏间隔是通过在`row`组件上面传递`gutter`参数，但实际上我们还得靠处理`col`组件来实现。一开始直接像下面这样直接把`gutter`传个每个`col`组件：\n```vue\n<yv-row :gutter=\"10\">\n  <yv-col :gutter=\"10\"></yv-col>\n  <yv-col :gutter=\"10\"></yv-col>\n</yv-row>\n```\n看起来很不友好。这里可以使用父子组件通信的另一种方法：`$parent`和`$children`。如下：\n```vue\n<!-- Row.vue -->\nmounted() {\n  this.$children.forEach(child => {\n    child.gutter = this.gutter\n  })\n}\n\n<!-- Col.vue -->\ndata() {\n  return {\n    gutter: 0\n  }\n}\n```\n在`row`的生命周期`mounted`中通过`$children`给每个子组件的`gutter`属性赋值，同时`col`组件也要在`data`里面定义`gutter`属性。\n\n3. `gutter`具体设置问题。一开始的想法是直接给每一列的左右加上`gutter/2`的外边距，但是这会跟通过`offset`设置的偏移分栏外边距产生冲突。那么换成内边距如何呢？试下内边距的效果。\n![设置内边距效果](/images/gutter-padding.png)\n从图片可以发现最左边跟最右边的分栏没有紧挨父级容器，这是设置了内边距的原因，跟父容器的空隙就是`gutter/2`px。解决方案是给父级容器加上`-gutter/2`的左右外边距，就ok了。\n\n4. 响应式处理。这里采用了`phone`、`iPad`、`narrowPC`、`widePC`这种直观的字段来表示不同屏幕宽度。通过`createClasses`方法来创建不同的类名：\n```vue\ncomputed: {\n  colClass() {\n    let {\n      span,\n      offset,\n      phone,\n      iPad,\n      narrowPC,\n      widePC\n    } = this\n    return [\n      'yv-col',\n      ...this.createClasses(phone, 'phone-'),\n      ...this.createClasses(iPad, 'iPad-'),\n      ...this.createClasses(narrowPC, 'narrowPC-'),\n      ...this.createClasses(widePC, 'widePC-'),\n      ...this.createClasses({ span, offset })\n    ]\n  }\n},\n\nmethods: {\n  createClasses(obj, str = '') {\n    if (!obj) return []\n    let arr = []\n    if (obj.span) {\n      arr.push(`yv-col-${str}${obj.span}`)\n    }\n    if (obj.offset) {\n      arr.push(`yv-col-${str}offset-${obj.offset}`)\n    }\n    return arr\n  }\n}\n```\n设置一个计算属性`colClass`，根据传入不同的尺寸属性生成不同的class添加到col上面，再通过媒体查询的写法，来实现不同尺寸下的宽度计算：\n```scss\n@media (min-width: 0px) {\n  @for $n from 1 through 24 {\n    $class-prefix:yv-col-phone-;\n    &.#{$class-prefix}#{$n} {\n      width: ($n / 24) * 100%\n    }\n  }\n  @for $n from 1 through 24 {\n    $class-prefix:yv-col-phone-offset-;\n    &.#{$class-prefix}#{$n} {\n      margin-left: ($n / 24) * 100%\n    }\n  }\n}\n@media (min-width: 577px) {\n  // ...\n}\n@media (min-width: 769px) {\n  // ...\n}\n@media (min-width: 993px) {\n  // ...\n}\n@media (min-width: 1201px) {\n  // ...\n}\n```\n\n## 人工测试\n手动测试。。。已完成。\n\n## 自动化测试\n在**test**文件夹下增加`row.test.js`和`col.test.js`文件。\n\n`row.test.js`文件有3个测试用例：**测试row是否存在**、**接收getter**、**接收align**；\n\n`col.test.js`文件有7个测试用例：**测试col是否存在**、**接收span**、**接收offset**、**接收phone**、**接收iPad**、**接收narrowPC**、**接收widePC**。\n\n运行命令`parcel watch test/* --no-cache`和`karma start`查看测试结果：\n\n\n\n![layout测试结果](/images/layout-browser.png)\n\n## vuepress\n\n在**docs/.vuepress/components**文件夹下增加多个`layout-*`的vue文件，内容就是我们要展示的`layout`示例，然后在**docs/components**文件夹下增加`layout`的md文件，内容就是放置整个`layout`组件说明。\n\n具体内容请[访问这里](https://ysom.github.io/yvue-ui/components/layout.html)。","slug":"开发一个UI框架-layout","published":1,"date":"2020-09-12T14:07:07.410Z","updated":"2020-09-12T14:14:55.071Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4m4001dhsuh9e72i8jl","content":"<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><ol>\n<li><code>row</code>组件默认采用<code>flex</code>布局，可通过<code>left</code>、<code>center</code>、<code>right</code>来设置对齐方式；</li>\n<li><code>row</code>组件可通过设置<code>gutter</code>参数来设置列之间的间隔；</li>\n<li><code>col</code>组件可通过设置<code>span</code>参数来设置不同列数，默认将宽度分为<strong>24</strong>列，同时可搭配<code>offset</code>参数来设置分栏偏移数；</li>\n<li>响应式布局传递的参数不采用<code>element-ui</code>那些<code>xs</code>、<code>sm</code>参数，字面上不利于理解，<br>所以这里采用了<code>phone</code>、<code>iPad</code>、<code>narrowPC</code>和<code>widePC</code>等参数来分别表示在屏幕大小为<br>手机、平板、窄屏PC端和宽屏PC端下的展示。</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"功能处理细节\"><a href=\"#功能处理细节\" class=\"headerlink\" title=\"功能处理细节\"></a>功能处理细节</h2><ol>\n<li><code>span</code>设置分栏数。默认将页面宽度分成了24等分，再通过<code>span/24</code>来算出分栏的占比，那要怎么设置各占比分栏宽度呢？如果直接通过<code>yv-col-1 ~ 24</code>这样写24个类名，就会出现一堆重复的代码，维护、改动也麻烦。幸好可以通过<strong>css预处理器</strong>来处理这种情况，<strong>预处理器</strong>可以像JS那样写变量，函数，可以为我们提供很多方便的操作，这里采用了<code>scss</code>来处理：<figure class=\"highlight scss hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">$n</span> from 1 through 24 &#123;</span><br><span class=\"line\">  <span class=\"hljs-variable\">$class-prefix</span>: yv-col-;</span><br><span class=\"line\">  &amp;.#&#123;<span class=\"hljs-variable\">$class-prefix</span>&#125;#&#123;<span class=\"hljs-variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">width</span>: (<span class=\"hljs-variable\">$n</span> / <span class=\"hljs-number\">24</span>) * <span class=\"hljs-number\">100%</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>先设置通用前缀<code>yv-col-</code>，再通过for循环从1到24，算出每一份的宽度，这样就可以根据<code>span</code>的值得到对应的类名<code>yv-col-n</code>从而得到对应的宽度。包括<code>offset</code>设置偏移栏数也是如此：</p>\n<figure class=\"highlight scss hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">$n</span> from 1 through 24 &#123;</span><br><span class=\"line\">  <span class=\"hljs-variable\">$class-prefix</span>:yv-col-offset-;</span><br><span class=\"line\">  &amp;.#&#123;<span class=\"hljs-variable\">$class-prefix</span>&#125;#&#123;<span class=\"hljs-variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">margin-left</span>: (<span class=\"hljs-variable\">$n</span> / <span class=\"hljs-number\">24</span>) * <span class=\"hljs-number\">100%</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>gutter</code>传参问题。设置分栏间隔是通过在<code>row</code>组件上面传递<code>gutter</code>参数，但实际上我们还得靠处理<code>col</code>组件来实现。一开始直接像下面这样直接把<code>gutter</code>传个每个<code>col</code>组件：<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;yv-row :gutter=&quot;10&quot;&gt;</span><br><span class=\"line\">  &lt;yv-col :gutter=&quot;10&quot;&gt;&lt;/yv-col&gt;</span><br><span class=\"line\">  &lt;yv-col :gutter=&quot;10&quot;&gt;&lt;/yv-col&gt;</span><br><span class=\"line\">&lt;/yv-row&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>看起来很不友好。这里可以使用父子组件通信的另一种方法：<code>$parent</code>和<code>$children</code>。如下：</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Row.vue --&gt;</span><br><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">  this.$children.forEach(child =&gt; &#123;</span><br><span class=\"line\">    child.gutter = this.gutter</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Col.vue --&gt;</span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    gutter: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>row</code>的生命周期<code>mounted</code>中通过<code>$children</code>给每个子组件的<code>gutter</code>属性赋值，同时<code>col</code>组件也要在<code>data</code>里面定义<code>gutter</code>属性。</p>\n<ol start=\"3\">\n<li><p><code>gutter</code>具体设置问题。一开始的想法是直接给每一列的左右加上<code>gutter/2</code>的外边距，但是这会跟通过<code>offset</code>设置的偏移分栏外边距产生冲突。那么换成内边距如何呢？试下内边距的效果。<br><img src=\"/images/gutter-padding.png\" alt=\"设置内边距效果\"><br>从图片可以发现最左边跟最右边的分栏没有紧挨父级容器，这是设置了内边距的原因，跟父容器的空隙就是<code>gutter/2</code>px。解决方案是给父级容器加上<code>-gutter/2</code>的左右外边距，就ok了。</p>\n</li>\n<li><p>响应式处理。这里采用了<code>phone</code>、<code>iPad</code>、<code>narrowPC</code>、<code>widePC</code>这种直观的字段来表示不同屏幕宽度。通过<code>createClasses</code>方法来创建不同的类名：</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  colClass() &#123;</span><br><span class=\"line\">    let &#123;</span><br><span class=\"line\">      span,</span><br><span class=\"line\">      offset,</span><br><span class=\"line\">      phone,</span><br><span class=\"line\">      iPad,</span><br><span class=\"line\">      narrowPC,</span><br><span class=\"line\">      widePC</span><br><span class=\"line\">    &#125; = this</span><br><span class=\"line\">    return [</span><br><span class=\"line\">      &apos;yv-col&apos;,</span><br><span class=\"line\">      ...this.createClasses(phone, &apos;phone-&apos;),</span><br><span class=\"line\">      ...this.createClasses(iPad, &apos;iPad-&apos;),</span><br><span class=\"line\">      ...this.createClasses(narrowPC, &apos;narrowPC-&apos;),</span><br><span class=\"line\">      ...this.createClasses(widePC, &apos;widePC-&apos;),</span><br><span class=\"line\">      ...this.createClasses(&#123; span, offset &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  createClasses(obj, str = &apos;&apos;) &#123;</span><br><span class=\"line\">    if (!obj) return []</span><br><span class=\"line\">    let arr = []</span><br><span class=\"line\">    if (obj.span) &#123;</span><br><span class=\"line\">      arr.push(`yv-col-$&#123;str&#125;$&#123;obj.span&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (obj.offset) &#123;</span><br><span class=\"line\">      arr.push(`yv-col-$&#123;str&#125;offset-$&#123;obj.offset&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>设置一个计算属性<code>colClass</code>，根据传入不同的尺寸属性生成不同的class添加到col上面，再通过媒体查询的写法，来实现不同尺寸下的宽度计算：</p>\n<figure class=\"highlight scss hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"hljs-keyword\">media</span> (min-width: 0px) &#123;</span><br><span class=\"line\">  @<span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">$n</span> from 1 through 24 &#123;</span><br><span class=\"line\">    <span class=\"hljs-variable\">$class-prefix</span>:yv-col-phone-;</span><br><span class=\"line\">    &amp;.#&#123;<span class=\"hljs-variable\">$class-prefix</span>&#125;#&#123;<span class=\"hljs-variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">      <span class=\"hljs-attribute\">width</span>: (<span class=\"hljs-variable\">$n</span> / <span class=\"hljs-number\">24</span>) * <span class=\"hljs-number\">100%</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @for <span class=\"hljs-variable\">$n</span> from <span class=\"hljs-number\">1</span> through <span class=\"hljs-number\">24</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-variable\">$class-prefix</span>:yv-col-phone-offset-;</span><br><span class=\"line\">    &amp;.#&#123;<span class=\"hljs-variable\">$class-prefix</span>&#125;#&#123;<span class=\"hljs-variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">      <span class=\"hljs-attribute\">margin-left</span>: (<span class=\"hljs-variable\">$n</span> / <span class=\"hljs-number\">24</span>) * <span class=\"hljs-number\">100%</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"hljs-number\">577px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"hljs-number\">769px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"hljs-number\">993px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"hljs-number\">1201px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"人工测试\"><a href=\"#人工测试\" class=\"headerlink\" title=\"人工测试\"></a>人工测试</h2><p>手动测试。。。已完成。</p>\n<h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><p>在<strong>test</strong>文件夹下增加<code>row.test.js</code>和<code>col.test.js</code>文件。</p>\n<p><code>row.test.js</code>文件有3个测试用例：<strong>测试row是否存在</strong>、<strong>接收getter</strong>、<strong>接收align</strong>；</p>\n<p><code>col.test.js</code>文件有7个测试用例：<strong>测试col是否存在</strong>、<strong>接收span</strong>、<strong>接收offset</strong>、<strong>接收phone</strong>、<strong>接收iPad</strong>、<strong>接收narrowPC</strong>、<strong>接收widePC</strong>。</p>\n<p>运行命令<code>parcel watch test/* --no-cache</code>和<code>karma start</code>查看测试结果：</p>\n<p><img src=\"/images/layout-browser.png\" alt=\"layout测试结果\"></p>\n<h2 id=\"vuepress\"><a href=\"#vuepress\" class=\"headerlink\" title=\"vuepress\"></a>vuepress</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加多个<code>layout-*</code>的vue文件，内容就是我们要展示的<code>layout</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>layout</code>的md文件，内容就是放置整个<code>layout</code>组件说明。</p>\n<p>具体内容请<a href=\"https://ysom.github.io/yvue-ui/components/layout.html\" target=\"_blank\" rel=\"noopener\">访问这里</a>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"设计细节\"><a href=\"#设计细节\" class=\"headerlink\" title=\"设计细节\"></a>设计细节</h2><ol>\n<li><code>row</code>组件默认采用<code>flex</code>布局，可通过<code>left</code>、<code>center</code>、<code>right</code>来设置对齐方式；</li>\n<li><code>row</code>组件可通过设置<code>gutter</code>参数来设置列之间的间隔；</li>\n<li><code>col</code>组件可通过设置<code>span</code>参数来设置不同列数，默认将宽度分为<strong>24</strong>列，同时可搭配<code>offset</code>参数来设置分栏偏移数；</li>\n<li>响应式布局传递的参数不采用<code>element-ui</code>那些<code>xs</code>、<code>sm</code>参数，字面上不利于理解，<br>所以这里采用了<code>phone</code>、<code>iPad</code>、<code>narrowPC</code>和<code>widePC</code>等参数来分别表示在屏幕大小为<br>手机、平板、窄屏PC端和宽屏PC端下的展示。</li>\n</ol>","more":"<h2 id=\"功能处理细节\"><a href=\"#功能处理细节\" class=\"headerlink\" title=\"功能处理细节\"></a>功能处理细节</h2><ol>\n<li><code>span</code>设置分栏数。默认将页面宽度分成了24等分，再通过<code>span/24</code>来算出分栏的占比，那要怎么设置各占比分栏宽度呢？如果直接通过<code>yv-col-1 ~ 24</code>这样写24个类名，就会出现一堆重复的代码，维护、改动也麻烦。幸好可以通过<strong>css预处理器</strong>来处理这种情况，<strong>预处理器</strong>可以像JS那样写变量，函数，可以为我们提供很多方便的操作，这里采用了<code>scss</code>来处理：<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">for</span> <span class=\"variable\">$n</span> from 1 through 24 &#123;</span><br><span class=\"line\">  <span class=\"variable\">$class-prefix</span>: yv-col-;</span><br><span class=\"line\">  &amp;.#&#123;<span class=\"variable\">$class-prefix</span>&#125;#&#123;<span class=\"variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: (<span class=\"variable\">$n</span> / <span class=\"number\">24</span>) * <span class=\"number\">100%</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>先设置通用前缀<code>yv-col-</code>，再通过for循环从1到24，算出每一份的宽度，这样就可以根据<code>span</code>的值得到对应的类名<code>yv-col-n</code>从而得到对应的宽度。包括<code>offset</code>设置偏移栏数也是如此：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">for</span> <span class=\"variable\">$n</span> from 1 through 24 &#123;</span><br><span class=\"line\">  <span class=\"variable\">$class-prefix</span>:yv-col-offset-;</span><br><span class=\"line\">  &amp;.#&#123;<span class=\"variable\">$class-prefix</span>&#125;#&#123;<span class=\"variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: (<span class=\"variable\">$n</span> / <span class=\"number\">24</span>) * <span class=\"number\">100%</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>gutter</code>传参问题。设置分栏间隔是通过在<code>row</code>组件上面传递<code>gutter</code>参数，但实际上我们还得靠处理<code>col</code>组件来实现。一开始直接像下面这样直接把<code>gutter</code>传个每个<code>col</code>组件：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;yv-row :gutter=&quot;10&quot;&gt;</span><br><span class=\"line\">  &lt;yv-col :gutter=&quot;10&quot;&gt;&lt;/yv-col&gt;</span><br><span class=\"line\">  &lt;yv-col :gutter=&quot;10&quot;&gt;&lt;/yv-col&gt;</span><br><span class=\"line\">&lt;/yv-row&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>看起来很不友好。这里可以使用父子组件通信的另一种方法：<code>$parent</code>和<code>$children</code>。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Row.vue --&gt;</span><br><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">  this.$children.forEach(child =&gt; &#123;</span><br><span class=\"line\">    child.gutter = this.gutter</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Col.vue --&gt;</span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    gutter: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>row</code>的生命周期<code>mounted</code>中通过<code>$children</code>给每个子组件的<code>gutter</code>属性赋值，同时<code>col</code>组件也要在<code>data</code>里面定义<code>gutter</code>属性。</p>\n<ol start=\"3\">\n<li><p><code>gutter</code>具体设置问题。一开始的想法是直接给每一列的左右加上<code>gutter/2</code>的外边距，但是这会跟通过<code>offset</code>设置的偏移分栏外边距产生冲突。那么换成内边距如何呢？试下内边距的效果。<br><img src=\"/images/gutter-padding.png\" alt=\"设置内边距效果\"><br>从图片可以发现最左边跟最右边的分栏没有紧挨父级容器，这是设置了内边距的原因，跟父容器的空隙就是<code>gutter/2</code>px。解决方案是给父级容器加上<code>-gutter/2</code>的左右外边距，就ok了。</p>\n</li>\n<li><p>响应式处理。这里采用了<code>phone</code>、<code>iPad</code>、<code>narrowPC</code>、<code>widePC</code>这种直观的字段来表示不同屏幕宽度。通过<code>createClasses</code>方法来创建不同的类名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  colClass() &#123;</span><br><span class=\"line\">    let &#123;</span><br><span class=\"line\">      span,</span><br><span class=\"line\">      offset,</span><br><span class=\"line\">      phone,</span><br><span class=\"line\">      iPad,</span><br><span class=\"line\">      narrowPC,</span><br><span class=\"line\">      widePC</span><br><span class=\"line\">    &#125; = this</span><br><span class=\"line\">    return [</span><br><span class=\"line\">      &apos;yv-col&apos;,</span><br><span class=\"line\">      ...this.createClasses(phone, &apos;phone-&apos;),</span><br><span class=\"line\">      ...this.createClasses(iPad, &apos;iPad-&apos;),</span><br><span class=\"line\">      ...this.createClasses(narrowPC, &apos;narrowPC-&apos;),</span><br><span class=\"line\">      ...this.createClasses(widePC, &apos;widePC-&apos;),</span><br><span class=\"line\">      ...this.createClasses(&#123; span, offset &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  createClasses(obj, str = &apos;&apos;) &#123;</span><br><span class=\"line\">    if (!obj) return []</span><br><span class=\"line\">    let arr = []</span><br><span class=\"line\">    if (obj.span) &#123;</span><br><span class=\"line\">      arr.push(`yv-col-$&#123;str&#125;$&#123;obj.span&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (obj.offset) &#123;</span><br><span class=\"line\">      arr.push(`yv-col-$&#123;str&#125;offset-$&#123;obj.offset&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>设置一个计算属性<code>colClass</code>，根据传入不同的尺寸属性生成不同的class添加到col上面，再通过媒体查询的写法，来实现不同尺寸下的宽度计算：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> (min-width: 0px) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">for</span> <span class=\"variable\">$n</span> from 1 through 24 &#123;</span><br><span class=\"line\">    <span class=\"variable\">$class-prefix</span>:yv-col-phone-;</span><br><span class=\"line\">    &amp;.#&#123;<span class=\"variable\">$class-prefix</span>&#125;#&#123;<span class=\"variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">      <span class=\"attribute\">width</span>: (<span class=\"variable\">$n</span> / <span class=\"number\">24</span>) * <span class=\"number\">100%</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @for <span class=\"variable\">$n</span> from <span class=\"number\">1</span> through <span class=\"number\">24</span> &#123;</span><br><span class=\"line\">    <span class=\"variable\">$class-prefix</span>:yv-col-phone-offset-;</span><br><span class=\"line\">    &amp;.#&#123;<span class=\"variable\">$class-prefix</span>&#125;#&#123;<span class=\"variable\">$n</span>&#125; &#123;</span><br><span class=\"line\">      <span class=\"attribute\">margin-left</span>: (<span class=\"variable\">$n</span> / <span class=\"number\">24</span>) * <span class=\"number\">100%</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"number\">577px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"number\">769px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"number\">993px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@media (min-width: <span class=\"number\">1201px</span>) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"人工测试\"><a href=\"#人工测试\" class=\"headerlink\" title=\"人工测试\"></a>人工测试</h2><p>手动测试。。。已完成。</p>\n<h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><p>在<strong>test</strong>文件夹下增加<code>row.test.js</code>和<code>col.test.js</code>文件。</p>\n<p><code>row.test.js</code>文件有3个测试用例：<strong>测试row是否存在</strong>、<strong>接收getter</strong>、<strong>接收align</strong>；</p>\n<p><code>col.test.js</code>文件有7个测试用例：<strong>测试col是否存在</strong>、<strong>接收span</strong>、<strong>接收offset</strong>、<strong>接收phone</strong>、<strong>接收iPad</strong>、<strong>接收narrowPC</strong>、<strong>接收widePC</strong>。</p>\n<p>运行命令<code>parcel watch test/* --no-cache</code>和<code>karma start</code>查看测试结果：</p>\n<p><img src=\"/images/layout-browser.png\" alt=\"layout测试结果\"></p>\n<h2 id=\"vuepress\"><a href=\"#vuepress\" class=\"headerlink\" title=\"vuepress\"></a>vuepress</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加多个<code>layout-*</code>的vue文件，内容就是我们要展示的<code>layout</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>layout</code>的md文件，内容就是放置整个<code>layout</code>组件说明。</p>\n<p>具体内容请<a href=\"https://ysom.github.io/yvue-ui/components/layout.html\" target=\"_blank\" rel=\"noopener\">访问这里</a>。</p>"},{"title":"开发一个UI框架项目[1]-前置工作","_content":"\n## 准备工作\n### 账号\n1. github\n2. gitee\n\n\n<!-- more -->\n\n### 包管理器（二选一）\n1. npm\n2. yarn\n\n\n### 打包工具\n1. parcel（无需配置，可快速预览）\n2. webpack（项目后续复杂的时候切换到webpack）\n\n\n### 业界成熟方案\n1. ant-design\n2. element-ui\n3. ant-design-vue\n\n\n### 原型设计工具\n1. Balsamiq\n\n\n### 交互设计工具\n1. 墨刀\n2. Sketch(mac)\n\n\n### 文章系统\n1. vuepress\n2. github pages\n\n\n### 持续部署工具\n1. Travis CI\n\n## 开始工作\n### 初始化项目\n1. `npm init`\n2. 完成项目初始化\n\n\n### 添加需要的插件\n```\nnpm i vue\nnpm i parcel-bundler vuepress -D\n```\n\n### 创建文件\n1. index.html\n2. app.js\n3. 在index.html文件引入app.js\n4. 使用npx parcel index.html即可根据提示观察打包后结果\n5. 开发各个组件\n\n## 坑点总结\n1. 使用parcel打包成功后，打开`http://localhost:1234`会报这样一个错误：\n```\nYou are using the runtime-only build of Vue where the template compiler is not available.\nEither pre-compile the templates into render functions,\nor use the compiler-included build.\n```\n这个错误是因为vue有两种模式的代码，`compiler`和`runtime`，vue默认指向的是`runtime`模式，即`dist/vue.runtime.common.js`。如果是使用webpack的话，可以在webpack.config.js文件添加以下配置：\n```js\nconfigureWebpack: {\n  resolve: {\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js'\n    }\n  }\n}\n```\n因为我使用的是parcel，没有配置文件，所以直接在package.json里面添加这一句即可：\n```json\n\"alias\": {\n  \"vue\": \"./node_modules/vue/dist/vue.esm.js\"\n}\n```\n\n2.如果使用parcel打包后打开页面发现报错了，但是你能确定代码没错的时候，那错误的原因大概就是因为parcel使用了缓存没有重新构建，使用以下命令解决：\n```js\nnpx parcel --no-cache\n```\n或者删除`.cache`文件夹。因为parcel是默认启用缓存的。\n\n## 闲话\n1. 为啥使用parcel？\n\n首先parcel使用起来非常方便，无需配置，只需一个命令，就能自动找到文件所依赖的文件，包括文件需要什么样的依赖包，它都会自动安装；\n\n其次parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换，让我们改动起来十分方便；\n\n最后也是最重要的一个原因，对于我来说，这是一个全新的挑战，刚开始肯定会是在不断试错，如何花最少的成本在短时间得到我想要的效果，parcel会比webpack更适合做这件事情，\n等到我对所有流程都比较熟悉、项目开始复杂起来的时候，再切换成webpack也不迟。\n\n2. 只会实现大致功能，不会像成熟的UI框架那么丰富\n\n自己周末仔细地算了一下，每个组件从**功能需求分析-可行性分析-原型设计-交互设计-功能开发-测试-发布**这样的流程会耗费非常多的时间，而我的主要目的是在于提升技术的深度，所以每个组件应该是尽量只实现核心的功能，不会囊括常见的所有功能（除非刚好有业务需求）。\n所以这个项目最后的样子应该是：一个简洁、清爽的UI轮子（不敢说是UI框架了，哈哈哈）。\n","source":"_posts/开发一个UI框架-前置工作.md","raw":"---\ntitle: 开发一个UI框架项目[1]-前置工作\ncategories:\n - 前端\ntags:\n - vue\n---\n\n## 准备工作\n### 账号\n1. github\n2. gitee\n\n\n<!-- more -->\n\n### 包管理器（二选一）\n1. npm\n2. yarn\n\n\n### 打包工具\n1. parcel（无需配置，可快速预览）\n2. webpack（项目后续复杂的时候切换到webpack）\n\n\n### 业界成熟方案\n1. ant-design\n2. element-ui\n3. ant-design-vue\n\n\n### 原型设计工具\n1. Balsamiq\n\n\n### 交互设计工具\n1. 墨刀\n2. Sketch(mac)\n\n\n### 文章系统\n1. vuepress\n2. github pages\n\n\n### 持续部署工具\n1. Travis CI\n\n## 开始工作\n### 初始化项目\n1. `npm init`\n2. 完成项目初始化\n\n\n### 添加需要的插件\n```\nnpm i vue\nnpm i parcel-bundler vuepress -D\n```\n\n### 创建文件\n1. index.html\n2. app.js\n3. 在index.html文件引入app.js\n4. 使用npx parcel index.html即可根据提示观察打包后结果\n5. 开发各个组件\n\n## 坑点总结\n1. 使用parcel打包成功后，打开`http://localhost:1234`会报这样一个错误：\n```\nYou are using the runtime-only build of Vue where the template compiler is not available.\nEither pre-compile the templates into render functions,\nor use the compiler-included build.\n```\n这个错误是因为vue有两种模式的代码，`compiler`和`runtime`，vue默认指向的是`runtime`模式，即`dist/vue.runtime.common.js`。如果是使用webpack的话，可以在webpack.config.js文件添加以下配置：\n```js\nconfigureWebpack: {\n  resolve: {\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js'\n    }\n  }\n}\n```\n因为我使用的是parcel，没有配置文件，所以直接在package.json里面添加这一句即可：\n```json\n\"alias\": {\n  \"vue\": \"./node_modules/vue/dist/vue.esm.js\"\n}\n```\n\n2.如果使用parcel打包后打开页面发现报错了，但是你能确定代码没错的时候，那错误的原因大概就是因为parcel使用了缓存没有重新构建，使用以下命令解决：\n```js\nnpx parcel --no-cache\n```\n或者删除`.cache`文件夹。因为parcel是默认启用缓存的。\n\n## 闲话\n1. 为啥使用parcel？\n\n首先parcel使用起来非常方便，无需配置，只需一个命令，就能自动找到文件所依赖的文件，包括文件需要什么样的依赖包，它都会自动安装；\n\n其次parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换，让我们改动起来十分方便；\n\n最后也是最重要的一个原因，对于我来说，这是一个全新的挑战，刚开始肯定会是在不断试错，如何花最少的成本在短时间得到我想要的效果，parcel会比webpack更适合做这件事情，\n等到我对所有流程都比较熟悉、项目开始复杂起来的时候，再切换成webpack也不迟。\n\n2. 只会实现大致功能，不会像成熟的UI框架那么丰富\n\n自己周末仔细地算了一下，每个组件从**功能需求分析-可行性分析-原型设计-交互设计-功能开发-测试-发布**这样的流程会耗费非常多的时间，而我的主要目的是在于提升技术的深度，所以每个组件应该是尽量只实现核心的功能，不会囊括常见的所有功能（除非刚好有业务需求）。\n所以这个项目最后的样子应该是：一个简洁、清爽的UI轮子（不敢说是UI框架了，哈哈哈）。\n","slug":"开发一个UI框架-前置工作","published":1,"date":"2020-08-31T15:27:29.701Z","updated":"2020-09-12T14:16:17.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4m6001ihsuhb4lb56rk","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"账号\"><a href=\"#账号\" class=\"headerlink\" title=\"账号\"></a>账号</h3><ol>\n<li>github</li>\n<li>gitee</li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"包管理器（二选一）\"><a href=\"#包管理器（二选一）\" class=\"headerlink\" title=\"包管理器（二选一）\"></a>包管理器（二选一）</h3><ol>\n<li>npm</li>\n<li>yarn</li>\n</ol>\n<h3 id=\"打包工具\"><a href=\"#打包工具\" class=\"headerlink\" title=\"打包工具\"></a>打包工具</h3><ol>\n<li>parcel（无需配置，可快速预览）</li>\n<li>webpack（项目后续复杂的时候切换到webpack）</li>\n</ol>\n<h3 id=\"业界成熟方案\"><a href=\"#业界成熟方案\" class=\"headerlink\" title=\"业界成熟方案\"></a>业界成熟方案</h3><ol>\n<li>ant-design</li>\n<li>element-ui</li>\n<li>ant-design-vue</li>\n</ol>\n<h3 id=\"原型设计工具\"><a href=\"#原型设计工具\" class=\"headerlink\" title=\"原型设计工具\"></a>原型设计工具</h3><ol>\n<li>Balsamiq</li>\n</ol>\n<h3 id=\"交互设计工具\"><a href=\"#交互设计工具\" class=\"headerlink\" title=\"交互设计工具\"></a>交互设计工具</h3><ol>\n<li>墨刀</li>\n<li>Sketch(mac)</li>\n</ol>\n<h3 id=\"文章系统\"><a href=\"#文章系统\" class=\"headerlink\" title=\"文章系统\"></a>文章系统</h3><ol>\n<li>vuepress</li>\n<li>github pages</li>\n</ol>\n<h3 id=\"持续部署工具\"><a href=\"#持续部署工具\" class=\"headerlink\" title=\"持续部署工具\"></a>持续部署工具</h3><ol>\n<li>Travis CI</li>\n</ol>\n<h2 id=\"开始工作\"><a href=\"#开始工作\" class=\"headerlink\" title=\"开始工作\"></a>开始工作</h2><h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><ol>\n<li><code>npm init</code></li>\n<li>完成项目初始化</li>\n</ol>\n<h3 id=\"添加需要的插件\"><a href=\"#添加需要的插件\" class=\"headerlink\" title=\"添加需要的插件\"></a>添加需要的插件</h3><figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i vue</span><br><span class=\"line\">npm i parcel-bundler vuepress -D</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h3><ol>\n<li>index.html</li>\n<li>app.js</li>\n<li>在index.html文件引入app.js</li>\n<li>使用npx parcel index.html即可根据提示观察打包后结果</li>\n<li>开发各个组件</li>\n</ol>\n<h2 id=\"坑点总结\"><a href=\"#坑点总结\" class=\"headerlink\" title=\"坑点总结\"></a>坑点总结</h2><ol>\n<li>使用parcel打包成功后，打开<code>http://localhost:1234</code>会报这样一个错误：<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You are using the runtime-only build of Vue where the template compiler is not available.</span><br><span class=\"line\">Either pre-compile the templates into render functions,</span><br><span class=\"line\">or use the compiler-included build.</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>这个错误是因为vue有两种模式的代码，<code>compiler</code>和<code>runtime</code>，vue默认指向的是<code>runtime</code>模式，即<code>dist/vue.runtime.common.js</code>。如果是使用webpack的话，可以在webpack.config.js文件添加以下配置：</p>\n<figure class=\"highlight js hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configureWebpack: &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      <span class=\"hljs-string\">'vue$'</span>: <span class=\"hljs-string\">'vue/dist/vue.esm.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我使用的是parcel，没有配置文件，所以直接在package.json里面添加这一句即可：</p>\n<figure class=\"highlight hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"alias\": &#123;</span><br><span class=\"line\">  \"vue\": \"./node_modules/vue/dist/vue.esm.js\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.如果使用parcel打包后打开页面发现报错了，但是你能确定代码没错的时候，那错误的原因大概就是因为parcel使用了缓存没有重新构建，使用以下命令解决：</p>\n<figure class=\"highlight js hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx parcel --no-cache</span><br></pre></td></tr></table></figure>\n\n<p>或者删除<code>.cache</code>文件夹。因为parcel是默认启用缓存的。</p>\n<h2 id=\"闲话\"><a href=\"#闲话\" class=\"headerlink\" title=\"闲话\"></a>闲话</h2><ol>\n<li>为啥使用parcel？</li>\n</ol>\n<p>首先parcel使用起来非常方便，无需配置，只需一个命令，就能自动找到文件所依赖的文件，包括文件需要什么样的依赖包，它都会自动安装；</p>\n<p>其次parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换，让我们改动起来十分方便；</p>\n<p>最后也是最重要的一个原因，对于我来说，这是一个全新的挑战，刚开始肯定会是在不断试错，如何花最少的成本在短时间得到我想要的效果，parcel会比webpack更适合做这件事情，<br>等到我对所有流程都比较熟悉、项目开始复杂起来的时候，再切换成webpack也不迟。</p>\n<ol start=\"2\">\n<li>只会实现大致功能，不会像成熟的UI框架那么丰富</li>\n</ol>\n<p>自己周末仔细地算了一下，每个组件从<strong>功能需求分析-可行性分析-原型设计-交互设计-功能开发-测试-发布</strong>这样的流程会耗费非常多的时间，而我的主要目的是在于提升技术的深度，所以每个组件应该是尽量只实现核心的功能，不会囊括常见的所有功能（除非刚好有业务需求）。<br>所以这个项目最后的样子应该是：一个简洁、清爽的UI轮子（不敢说是UI框架了，哈哈哈）。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"账号\"><a href=\"#账号\" class=\"headerlink\" title=\"账号\"></a>账号</h3><ol>\n<li>github</li>\n<li>gitee</li>\n</ol>","more":"<h3 id=\"包管理器（二选一）\"><a href=\"#包管理器（二选一）\" class=\"headerlink\" title=\"包管理器（二选一）\"></a>包管理器（二选一）</h3><ol>\n<li>npm</li>\n<li>yarn</li>\n</ol>\n<h3 id=\"打包工具\"><a href=\"#打包工具\" class=\"headerlink\" title=\"打包工具\"></a>打包工具</h3><ol>\n<li>parcel（无需配置，可快速预览）</li>\n<li>webpack（项目后续复杂的时候切换到webpack）</li>\n</ol>\n<h3 id=\"业界成熟方案\"><a href=\"#业界成熟方案\" class=\"headerlink\" title=\"业界成熟方案\"></a>业界成熟方案</h3><ol>\n<li>ant-design</li>\n<li>element-ui</li>\n<li>ant-design-vue</li>\n</ol>\n<h3 id=\"原型设计工具\"><a href=\"#原型设计工具\" class=\"headerlink\" title=\"原型设计工具\"></a>原型设计工具</h3><ol>\n<li>Balsamiq</li>\n</ol>\n<h3 id=\"交互设计工具\"><a href=\"#交互设计工具\" class=\"headerlink\" title=\"交互设计工具\"></a>交互设计工具</h3><ol>\n<li>墨刀</li>\n<li>Sketch(mac)</li>\n</ol>\n<h3 id=\"文章系统\"><a href=\"#文章系统\" class=\"headerlink\" title=\"文章系统\"></a>文章系统</h3><ol>\n<li>vuepress</li>\n<li>github pages</li>\n</ol>\n<h3 id=\"持续部署工具\"><a href=\"#持续部署工具\" class=\"headerlink\" title=\"持续部署工具\"></a>持续部署工具</h3><ol>\n<li>Travis CI</li>\n</ol>\n<h2 id=\"开始工作\"><a href=\"#开始工作\" class=\"headerlink\" title=\"开始工作\"></a>开始工作</h2><h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><ol>\n<li><code>npm init</code></li>\n<li>完成项目初始化</li>\n</ol>\n<h3 id=\"添加需要的插件\"><a href=\"#添加需要的插件\" class=\"headerlink\" title=\"添加需要的插件\"></a>添加需要的插件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i vue</span><br><span class=\"line\">npm i parcel-bundler vuepress -D</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h3><ol>\n<li>index.html</li>\n<li>app.js</li>\n<li>在index.html文件引入app.js</li>\n<li>使用npx parcel index.html即可根据提示观察打包后结果</li>\n<li>开发各个组件</li>\n</ol>\n<h2 id=\"坑点总结\"><a href=\"#坑点总结\" class=\"headerlink\" title=\"坑点总结\"></a>坑点总结</h2><ol>\n<li>使用parcel打包成功后，打开<code>http://localhost:1234</code>会报这样一个错误：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">You are using the runtime-only build of Vue where the template compiler is not available.</span><br><span class=\"line\">Either pre-compile the templates into render functions,</span><br><span class=\"line\">or use the compiler-included build.</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>这个错误是因为vue有两种模式的代码，<code>compiler</code>和<code>runtime</code>，vue默认指向的是<code>runtime</code>模式，即<code>dist/vue.runtime.common.js</code>。如果是使用webpack的话，可以在webpack.config.js文件添加以下配置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configureWebpack: &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      <span class=\"string\">'vue$'</span>: <span class=\"string\">'vue/dist/vue.esm.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我使用的是parcel，没有配置文件，所以直接在package.json里面添加这一句即可：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"alias\": &#123;</span><br><span class=\"line\">  \"vue\": \"./node_modules/vue/dist/vue.esm.js\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.如果使用parcel打包后打开页面发现报错了，但是你能确定代码没错的时候，那错误的原因大概就是因为parcel使用了缓存没有重新构建，使用以下命令解决：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx parcel --no-cache</span><br></pre></td></tr></table></figure>\n\n<p>或者删除<code>.cache</code>文件夹。因为parcel是默认启用缓存的。</p>\n<h2 id=\"闲话\"><a href=\"#闲话\" class=\"headerlink\" title=\"闲话\"></a>闲话</h2><ol>\n<li>为啥使用parcel？</li>\n</ol>\n<p>首先parcel使用起来非常方便，无需配置，只需一个命令，就能自动找到文件所依赖的文件，包括文件需要什么样的依赖包，它都会自动安装；</p>\n<p>其次parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换，让我们改动起来十分方便；</p>\n<p>最后也是最重要的一个原因，对于我来说，这是一个全新的挑战，刚开始肯定会是在不断试错，如何花最少的成本在短时间得到我想要的效果，parcel会比webpack更适合做这件事情，<br>等到我对所有流程都比较熟悉、项目开始复杂起来的时候，再切换成webpack也不迟。</p>\n<ol start=\"2\">\n<li>只会实现大致功能，不会像成熟的UI框架那么丰富</li>\n</ol>\n<p>自己周末仔细地算了一下，每个组件从<strong>功能需求分析-可行性分析-原型设计-交互设计-功能开发-测试-发布</strong>这样的流程会耗费非常多的时间，而我的主要目的是在于提升技术的深度，所以每个组件应该是尽量只实现核心的功能，不会囊括常见的所有功能（除非刚好有业务需求）。<br>所以这个项目最后的样子应该是：一个简洁、清爽的UI轮子（不敢说是UI框架了，哈哈哈）。</p>"},{"title":"开发一个UI框架项目[0]-想法","_content":"\n## 写在前面\n\n近段时间一直有搞个开源项目的想法，但是却没有什么思路，最后思来想去，再结合近段时间的一些事情和个人在开发中遇到的一些情况，最终决定造一个UI框架轮子，具体的原因跟分析见下面。\n\n## 造轮子的初衷\n\n<!-- more -->\n\n1. **深度、持续提升自己**。这是最根本的原因。大多数前端工程师应该和我一样，平时基本都是在写业务代码，这本身没有问题，但是如果我们写业务代码写习惯了，又没有给自己做一个总结性、提升性的东西，就会不断重复做着同一件事而没有提升，就会陷入**内卷化**。所以要如何让自己保持不断提升和进步，这是最根本和最核心的问题。\n\n2. **纸上得来终觉浅，绝知此事要躬行**。现在的前端技术日新月异，我们需要学习很多知识，同时我们也看过很多理论知识，我们会发现在和别人聊天的时候能侃侃而谈，但在实践的时候却是手忙脚乱，这是为什么？最重要的原因之一就是缺乏实践。理论知识很重要，是我们核心竞争力之一，但只有把掌握的知识发挥出来，才是真正的有用，不然也只能算是“**纸上谈兵**”。造轮子就是一个很好的实践过程，我们本身所存在的很多问题，都会在实践中不断暴露出来，而我们要做的，就是发现问题-解决问题-发现问题-解决问题。。。如此循环然后总结，复盘。虽然这个过程确实非常耗费时间和精力。\n\n3. **居安思危**。很多人会觉得造轮子是一件费力不讨好的事情，现在网上资源那么丰富，github上面开源的项目那么多，直接拿来用就好，为啥还要自己造呢？这种想法一般情况下是对的，但也有存在比较特殊的情况：\n\n   1. 特殊的需求。总会有一些特定、个性化的需求是第三方无法满足的，无论是公司的业务还是个人的项目，最后还是需要我们自己去创造；\n   2. 迭代稳定性。我们永远无法保证我们使用的第三方库能否保证一直维护更新，第三方库也不会给予我们这样的保证。比如现在`vue`比较热门的组件库`element-ui`，目前也停止维护了，包括以前的`mint-ui`也是这样，时代一直在进步，我们所依赖的的东西止步不前，我们是否也要跟着止步不前？如果每次都要更换ui库，迁移成本如何考虑？\n   3. 服务稳定性。如果第三方库出于某些因素考虑，不再对我们提供服务呢？这个也是很显现实的问题，就像今年以来，美帝对华为还有其它中国企业强制采取某些制裁手段，这时候有道理也是讲不清的，君子不立危墙之下，我们还是要做到居安思危，有自己的东西才是最稳妥的。\n\n   \n\n## 实践想法\n\n   1. **从0到1**。第一个开源项目，应该要好好准备，采用软件工程的理论以及当前环境项目的发布，过程大概包含**立项**、**需求收集和分析**、**可行性分析**、**功能设计**、**原型设计**、**交互设计**、**功能开发**、**测试**、**功能预演**、**发布**，部分步骤可以直接采用业界已有的成熟方案，虽然是造轮子，但也不是全部都是从0开始，我们不能这么傻ヽ(￣▽￣)ﾉ。\n\n   2. **同步记录**。打算使用`vuepress`来记录下这个伟大的过程，同时由于`vuepress`强大的功能，还可以用来展示开发的功能示例，这简直不能太棒ヾ(ﾟ∀ﾟゞ)！\n   3. **同时部署在github和gitee**。本来打算后面项目部署在`github`这个全球最大同性交友社区的，但是种种原因限制，访问慢，有时还会被限制，特别是这段时间，因为运营商`dns`污染，`github.io`也访问不了，需要修改dns或者自己部署其它域名，确实有点坑，所以还是那句话，居安思危，因此多部署一个`gitee`。\n   4. **发布到npm**。既然是开源项目，还是得发布到npm上面，虽然用在生产环境的概率比较小，但是一整个完整流程还是要认真走完的。\n\n## 总结\n从该想法萌生之后，自己也查阅很多资料做了一些了解，这样的项目会耗费比较多的时间，后面也许也不会直接用于生产环境，但是如果有一天需要自己去创造轮子或者其它类似功能的时候，这个项目就会发挥很大的作用。\n\n","source":"_posts/打算开发一个UI框架项目.md","raw":"---\ntitle: 开发一个UI框架项目[0]-想法\ncategories:\n - 前端\ntags:\n - vue\n---\n\n## 写在前面\n\n近段时间一直有搞个开源项目的想法，但是却没有什么思路，最后思来想去，再结合近段时间的一些事情和个人在开发中遇到的一些情况，最终决定造一个UI框架轮子，具体的原因跟分析见下面。\n\n## 造轮子的初衷\n\n<!-- more -->\n\n1. **深度、持续提升自己**。这是最根本的原因。大多数前端工程师应该和我一样，平时基本都是在写业务代码，这本身没有问题，但是如果我们写业务代码写习惯了，又没有给自己做一个总结性、提升性的东西，就会不断重复做着同一件事而没有提升，就会陷入**内卷化**。所以要如何让自己保持不断提升和进步，这是最根本和最核心的问题。\n\n2. **纸上得来终觉浅，绝知此事要躬行**。现在的前端技术日新月异，我们需要学习很多知识，同时我们也看过很多理论知识，我们会发现在和别人聊天的时候能侃侃而谈，但在实践的时候却是手忙脚乱，这是为什么？最重要的原因之一就是缺乏实践。理论知识很重要，是我们核心竞争力之一，但只有把掌握的知识发挥出来，才是真正的有用，不然也只能算是“**纸上谈兵**”。造轮子就是一个很好的实践过程，我们本身所存在的很多问题，都会在实践中不断暴露出来，而我们要做的，就是发现问题-解决问题-发现问题-解决问题。。。如此循环然后总结，复盘。虽然这个过程确实非常耗费时间和精力。\n\n3. **居安思危**。很多人会觉得造轮子是一件费力不讨好的事情，现在网上资源那么丰富，github上面开源的项目那么多，直接拿来用就好，为啥还要自己造呢？这种想法一般情况下是对的，但也有存在比较特殊的情况：\n\n   1. 特殊的需求。总会有一些特定、个性化的需求是第三方无法满足的，无论是公司的业务还是个人的项目，最后还是需要我们自己去创造；\n   2. 迭代稳定性。我们永远无法保证我们使用的第三方库能否保证一直维护更新，第三方库也不会给予我们这样的保证。比如现在`vue`比较热门的组件库`element-ui`，目前也停止维护了，包括以前的`mint-ui`也是这样，时代一直在进步，我们所依赖的的东西止步不前，我们是否也要跟着止步不前？如果每次都要更换ui库，迁移成本如何考虑？\n   3. 服务稳定性。如果第三方库出于某些因素考虑，不再对我们提供服务呢？这个也是很显现实的问题，就像今年以来，美帝对华为还有其它中国企业强制采取某些制裁手段，这时候有道理也是讲不清的，君子不立危墙之下，我们还是要做到居安思危，有自己的东西才是最稳妥的。\n\n   \n\n## 实践想法\n\n   1. **从0到1**。第一个开源项目，应该要好好准备，采用软件工程的理论以及当前环境项目的发布，过程大概包含**立项**、**需求收集和分析**、**可行性分析**、**功能设计**、**原型设计**、**交互设计**、**功能开发**、**测试**、**功能预演**、**发布**，部分步骤可以直接采用业界已有的成熟方案，虽然是造轮子，但也不是全部都是从0开始，我们不能这么傻ヽ(￣▽￣)ﾉ。\n\n   2. **同步记录**。打算使用`vuepress`来记录下这个伟大的过程，同时由于`vuepress`强大的功能，还可以用来展示开发的功能示例，这简直不能太棒ヾ(ﾟ∀ﾟゞ)！\n   3. **同时部署在github和gitee**。本来打算后面项目部署在`github`这个全球最大同性交友社区的，但是种种原因限制，访问慢，有时还会被限制，特别是这段时间，因为运营商`dns`污染，`github.io`也访问不了，需要修改dns或者自己部署其它域名，确实有点坑，所以还是那句话，居安思危，因此多部署一个`gitee`。\n   4. **发布到npm**。既然是开源项目，还是得发布到npm上面，虽然用在生产环境的概率比较小，但是一整个完整流程还是要认真走完的。\n\n## 总结\n从该想法萌生之后，自己也查阅很多资料做了一些了解，这样的项目会耗费比较多的时间，后面也许也不会直接用于生产环境，但是如果有一天需要自己去创造轮子或者其它类似功能的时候，这个项目就会发挥很大的作用。\n\n","slug":"打算开发一个UI框架项目","published":1,"date":"2020-08-30T15:56:06.765Z","updated":"2020-09-12T14:17:12.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4m8001lhsuhf749y2m4","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>近段时间一直有搞个开源项目的想法，但是却没有什么思路，最后思来想去，再结合近段时间的一些事情和个人在开发中遇到的一些情况，最终决定造一个UI框架轮子，具体的原因跟分析见下面。</p>\n<h2 id=\"造轮子的初衷\"><a href=\"#造轮子的初衷\" class=\"headerlink\" title=\"造轮子的初衷\"></a>造轮子的初衷</h2><a id=\"more\"></a>\n\n<ol>\n<li><p><strong>深度、持续提升自己</strong>。这是最根本的原因。大多数前端工程师应该和我一样，平时基本都是在写业务代码，这本身没有问题，但是如果我们写业务代码写习惯了，又没有给自己做一个总结性、提升性的东西，就会不断重复做着同一件事而没有提升，就会陷入<strong>内卷化</strong>。所以要如何让自己保持不断提升和进步，这是最根本和最核心的问题。</p>\n</li>\n<li><p><strong>纸上得来终觉浅，绝知此事要躬行</strong>。现在的前端技术日新月异，我们需要学习很多知识，同时我们也看过很多理论知识，我们会发现在和别人聊天的时候能侃侃而谈，但在实践的时候却是手忙脚乱，这是为什么？最重要的原因之一就是缺乏实践。理论知识很重要，是我们核心竞争力之一，但只有把掌握的知识发挥出来，才是真正的有用，不然也只能算是“<strong>纸上谈兵</strong>”。造轮子就是一个很好的实践过程，我们本身所存在的很多问题，都会在实践中不断暴露出来，而我们要做的，就是发现问题-解决问题-发现问题-解决问题。。。如此循环然后总结，复盘。虽然这个过程确实非常耗费时间和精力。</p>\n</li>\n<li><p><strong>居安思危</strong>。很多人会觉得造轮子是一件费力不讨好的事情，现在网上资源那么丰富，github上面开源的项目那么多，直接拿来用就好，为啥还要自己造呢？这种想法一般情况下是对的，但也有存在比较特殊的情况：</p>\n<ol>\n<li>特殊的需求。总会有一些特定、个性化的需求是第三方无法满足的，无论是公司的业务还是个人的项目，最后还是需要我们自己去创造；</li>\n<li>迭代稳定性。我们永远无法保证我们使用的第三方库能否保证一直维护更新，第三方库也不会给予我们这样的保证。比如现在<code>vue</code>比较热门的组件库<code>element-ui</code>，目前也停止维护了，包括以前的<code>mint-ui</code>也是这样，时代一直在进步，我们所依赖的的东西止步不前，我们是否也要跟着止步不前？如果每次都要更换ui库，迁移成本如何考虑？</li>\n<li>服务稳定性。如果第三方库出于某些因素考虑，不再对我们提供服务呢？这个也是很显现实的问题，就像今年以来，美帝对华为还有其它中国企业强制采取某些制裁手段，这时候有道理也是讲不清的，君子不立危墙之下，我们还是要做到居安思危，有自己的东西才是最稳妥的。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"实践想法\"><a href=\"#实践想法\" class=\"headerlink\" title=\"实践想法\"></a>实践想法</h2><ol>\n<li><p><strong>从0到1</strong>。第一个开源项目，应该要好好准备，采用软件工程的理论以及当前环境项目的发布，过程大概包含<strong>立项</strong>、<strong>需求收集和分析</strong>、<strong>可行性分析</strong>、<strong>功能设计</strong>、<strong>原型设计</strong>、<strong>交互设计</strong>、<strong>功能开发</strong>、<strong>测试</strong>、<strong>功能预演</strong>、<strong>发布</strong>，部分步骤可以直接采用业界已有的成熟方案，虽然是造轮子，但也不是全部都是从0开始，我们不能这么傻ヽ(￣▽￣)ﾉ。</p>\n</li>\n<li><p><strong>同步记录</strong>。打算使用<code>vuepress</code>来记录下这个伟大的过程，同时由于<code>vuepress</code>强大的功能，还可以用来展示开发的功能示例，这简直不能太棒ヾ(ﾟ∀ﾟゞ)！</p>\n</li>\n<li><p><strong>同时部署在github和gitee</strong>。本来打算后面项目部署在<code>github</code>这个全球最大同性交友社区的，但是种种原因限制，访问慢，有时还会被限制，特别是这段时间，因为运营商<code>dns</code>污染，<code>github.io</code>也访问不了，需要修改dns或者自己部署其它域名，确实有点坑，所以还是那句话，居安思危，因此多部署一个<code>gitee</code>。</p>\n</li>\n<li><p><strong>发布到npm</strong>。既然是开源项目，还是得发布到npm上面，虽然用在生产环境的概率比较小，但是一整个完整流程还是要认真走完的。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从该想法萌生之后，自己也查阅很多资料做了一些了解，这样的项目会耗费比较多的时间，后面也许也不会直接用于生产环境，但是如果有一天需要自己去创造轮子或者其它类似功能的时候，这个项目就会发挥很大的作用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>近段时间一直有搞个开源项目的想法，但是却没有什么思路，最后思来想去，再结合近段时间的一些事情和个人在开发中遇到的一些情况，最终决定造一个UI框架轮子，具体的原因跟分析见下面。</p>\n<h2 id=\"造轮子的初衷\"><a href=\"#造轮子的初衷\" class=\"headerlink\" title=\"造轮子的初衷\"></a>造轮子的初衷</h2>","more":"<ol>\n<li><p><strong>深度、持续提升自己</strong>。这是最根本的原因。大多数前端工程师应该和我一样，平时基本都是在写业务代码，这本身没有问题，但是如果我们写业务代码写习惯了，又没有给自己做一个总结性、提升性的东西，就会不断重复做着同一件事而没有提升，就会陷入<strong>内卷化</strong>。所以要如何让自己保持不断提升和进步，这是最根本和最核心的问题。</p>\n</li>\n<li><p><strong>纸上得来终觉浅，绝知此事要躬行</strong>。现在的前端技术日新月异，我们需要学习很多知识，同时我们也看过很多理论知识，我们会发现在和别人聊天的时候能侃侃而谈，但在实践的时候却是手忙脚乱，这是为什么？最重要的原因之一就是缺乏实践。理论知识很重要，是我们核心竞争力之一，但只有把掌握的知识发挥出来，才是真正的有用，不然也只能算是“<strong>纸上谈兵</strong>”。造轮子就是一个很好的实践过程，我们本身所存在的很多问题，都会在实践中不断暴露出来，而我们要做的，就是发现问题-解决问题-发现问题-解决问题。。。如此循环然后总结，复盘。虽然这个过程确实非常耗费时间和精力。</p>\n</li>\n<li><p><strong>居安思危</strong>。很多人会觉得造轮子是一件费力不讨好的事情，现在网上资源那么丰富，github上面开源的项目那么多，直接拿来用就好，为啥还要自己造呢？这种想法一般情况下是对的，但也有存在比较特殊的情况：</p>\n<ol>\n<li>特殊的需求。总会有一些特定、个性化的需求是第三方无法满足的，无论是公司的业务还是个人的项目，最后还是需要我们自己去创造；</li>\n<li>迭代稳定性。我们永远无法保证我们使用的第三方库能否保证一直维护更新，第三方库也不会给予我们这样的保证。比如现在<code>vue</code>比较热门的组件库<code>element-ui</code>，目前也停止维护了，包括以前的<code>mint-ui</code>也是这样，时代一直在进步，我们所依赖的的东西止步不前，我们是否也要跟着止步不前？如果每次都要更换ui库，迁移成本如何考虑？</li>\n<li>服务稳定性。如果第三方库出于某些因素考虑，不再对我们提供服务呢？这个也是很显现实的问题，就像今年以来，美帝对华为还有其它中国企业强制采取某些制裁手段，这时候有道理也是讲不清的，君子不立危墙之下，我们还是要做到居安思危，有自己的东西才是最稳妥的。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"实践想法\"><a href=\"#实践想法\" class=\"headerlink\" title=\"实践想法\"></a>实践想法</h2><ol>\n<li><p><strong>从0到1</strong>。第一个开源项目，应该要好好准备，采用软件工程的理论以及当前环境项目的发布，过程大概包含<strong>立项</strong>、<strong>需求收集和分析</strong>、<strong>可行性分析</strong>、<strong>功能设计</strong>、<strong>原型设计</strong>、<strong>交互设计</strong>、<strong>功能开发</strong>、<strong>测试</strong>、<strong>功能预演</strong>、<strong>发布</strong>，部分步骤可以直接采用业界已有的成熟方案，虽然是造轮子，但也不是全部都是从0开始，我们不能这么傻ヽ(￣▽￣)ﾉ。</p>\n</li>\n<li><p><strong>同步记录</strong>。打算使用<code>vuepress</code>来记录下这个伟大的过程，同时由于<code>vuepress</code>强大的功能，还可以用来展示开发的功能示例，这简直不能太棒ヾ(ﾟ∀ﾟゞ)！</p>\n</li>\n<li><p><strong>同时部署在github和gitee</strong>。本来打算后面项目部署在<code>github</code>这个全球最大同性交友社区的，但是种种原因限制，访问慢，有时还会被限制，特别是这段时间，因为运营商<code>dns</code>污染，<code>github.io</code>也访问不了，需要修改dns或者自己部署其它域名，确实有点坑，所以还是那句话，居安思危，因此多部署一个<code>gitee</code>。</p>\n</li>\n<li><p><strong>发布到npm</strong>。既然是开源项目，还是得发布到npm上面，虽然用在生产环境的概率比较小，但是一整个完整流程还是要认真走完的。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从该想法萌生之后，自己也查阅很多资料做了一些了解，这样的项目会耗费比较多的时间，后面也许也不会直接用于生产环境，但是如果有一天需要自己去创造轮子或者其它类似功能的时候，这个项目就会发挥很大的作用。</p>"},{"title":"浅析HTTP缓存","_content":"\n### 前言\n\n> 浏览器缓存机制有**四个方面**，按照资源获取优先级排列，分别是`Memory Cache`、`Service Worker Cache`、`HTTP Cache`、`Push Cache`。我们经常使用，也比较熟悉的是HTTP Cache。这里单独分析HTTP Cache。\n\n<!-- more -->\n\n### HTTP Cache\n\nHTTP Cache又分为**强缓存**和**协商缓存**，强缓存优先级比较高，未命中强缓存时才走协商缓存。\n\n#### 强缓存\n\n强缓存是通过http头的`expires`和`cache-control`来实现控制。当再发出请求时，浏览器会根据`expires`和`cache-control`来判断是否命中强缓存，若命中直接从缓存中获取资源，而不再与服务端进行通信。\n\n在http1.0版本中，服务器响应时会返回一个缓存过期时间戳字段`expires`，再次发起请求时浏览器通过本地时间与`expires`时间戳对比，来判断缓存是否过期，这种依赖本地时间的方式会存在一个弊端，如果修改了本地时间，或者本地时间与服务端时间不同步，这将达不到我们预期的缓存效果。\n\n因此，在http1.1版本中，引入了`expires`的替代方案：`Cache-Control`。`Cache-Control`能做`expires`做的事，也能做`expires`做不到的事情，目前`expires`还存在是为了做向下兼容。\n\n`Cache-Control`的格式为：\n\n```js\nCache-Control: max-age=3600\n```\n\n在`Cache-Control`中，`max-age`字段表示资源最大缓存时间（秒），上面例子表示在3600秒内该资源都是有效的。`Cache-Control`表示的时间比`expires`时间戳更为准确，同时`Cache-Control`优先级更高，两者存在时以`Cache-Control`为准。\n\n`Cache-Control`还有其它的缓存方式：`no-cache`和`no-store`。\n\n如果给资源设置了`no-cache`，则会绕开浏览器，直接询问服务器该资源是否过期，即走**协商缓存**。`no-store`顾名思义，就比较绝情了，不设置任何缓存，每次发起请求不经过浏览器与服务端缓存，直接想服务器发送请求，并下载完整的响应。\n\n#### 协商缓存\n\n协商缓存，顾名思义就是浏览器与服务器合作的缓存策略，它依赖于浏览器与服务器之间的通信，浏览器需要向服务器询问缓存的相关信息，进而判断是读取本地缓存的资源还是重新发起请求，下载完整的响应。\n\n##### 协商缓存的实现\n\n**Last-Modified**\n\n`Last-Modified`是一个时间戳，在启用协商缓存之后，会在首次请求的时候，随着Response Headers返回\n\n```javascript\nLast-Modified: Wed, 12 Feb 2020 09:21:28 GMT\n```\n\n随后每次请求会带上`If-Modified-Since`时间戳字段，值为上一次Response返回的`Last-Modified`值\n\n```javascript\nIf-Modified-Since: Wed, 12 Feb 2020 09:21:28 GMT\n```\n\n服务器收到这个时间戳之后，会根据该时间戳与服务器的资源的最后修改时间对比，如果时间改变，则返回一个新的完整的响应，并在Response Headers返回新的`Last-Modified`值；如果时间没有变化，则返回一个304状态码，提示资源并未改动，然后重定向到浏览器缓存，Response Headers也不会再返回`Last-Modified`字段，如下图：\n\n![304](/images/304.png)\n\n但是使用`Last-Modified`也会存在弊端：\n\n- 资源文件改动了，但是并没有改变内容，文件的最后修改时间会变化，导致该资源会被重新请求\n- `If-Modified-Since`是以秒为单位做检验，如果改动文件的时间小于1000ms，那么该资源有可能被认为是未改变的，导致无法重新请求\n\n这两种情况反映了一个问题，无法准确感知文件是否发生改变。\n\n为了解决该问题，`Etag`出现了。\n\n`Etag`是服务器为每个资源生成的唯一的**标识字符串**，这个标识字符串是基于文件内容编码的，文件内容不同，对应的 `Etag` 就是不同的，因此`Etag` 能够精准地感知文件的变化。\n\n`Etag` 和 `Last-Modified` 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这个样子\n\n```javascript\nETag: W/\"1q2w-108946715\"\n```\n\n在下一次请求时，会带上与之相同值的字段`if-None-Match`，提供给服务器对比\n\n```javascript\nIf-None-Match: W/\"1q2w-108946715\"\n```\n\n很明显，`Etag`有利也有弊，它的生成需要服务器付出额外的开销，会影响服务器的性能，`Etag`并不能直接代替`Last-Modified`，而是作为补充，它的优先级比`Last-Modified`高，两者共存时，以`Etag`为准。\n\n### HTTP缓存策略\n\n对于上面讲的知识点，要如何对应到实际的开发中呢，这边拿了谷歌官方的一张图：\n\n![缓存策略](/images/缓存策略.png)\n\n这张图片清楚地给我们展示了缓存策略流程。\n\n首先看看资源的可复用性，如果是不可复用的话，很干脆，直接把`Cache-control`设置为`no-store`，不需要任何形式的缓存。\n\n如果是可复用的资源，那么看看是否需要每次都向服务器去验证缓存是否有效，如果需要，则设置`Cache-control`为`no-store`，不需要的，则进行下一步，考虑资源是否可被代理服务器缓存，根据情况设置`private`或`public`；接着考虑资源的过期时间，设置资源的`max-age`；最后一步配置协商缓存，设置`Last-Modified`和`Etag`。\n\n### 结语\n\nHTTP缓存的知识点比较琐碎，很多人过段时间很容易忘记。只有多分析多总结，才能够把握这些知识。","source":"_posts/浅析HTTP缓存.md","raw":"---\n\ntitle: 浅析HTTP缓存\ncategories:\n - 网络\ntags:\n - HTTP\n---\n\n### 前言\n\n> 浏览器缓存机制有**四个方面**，按照资源获取优先级排列，分别是`Memory Cache`、`Service Worker Cache`、`HTTP Cache`、`Push Cache`。我们经常使用，也比较熟悉的是HTTP Cache。这里单独分析HTTP Cache。\n\n<!-- more -->\n\n### HTTP Cache\n\nHTTP Cache又分为**强缓存**和**协商缓存**，强缓存优先级比较高，未命中强缓存时才走协商缓存。\n\n#### 强缓存\n\n强缓存是通过http头的`expires`和`cache-control`来实现控制。当再发出请求时，浏览器会根据`expires`和`cache-control`来判断是否命中强缓存，若命中直接从缓存中获取资源，而不再与服务端进行通信。\n\n在http1.0版本中，服务器响应时会返回一个缓存过期时间戳字段`expires`，再次发起请求时浏览器通过本地时间与`expires`时间戳对比，来判断缓存是否过期，这种依赖本地时间的方式会存在一个弊端，如果修改了本地时间，或者本地时间与服务端时间不同步，这将达不到我们预期的缓存效果。\n\n因此，在http1.1版本中，引入了`expires`的替代方案：`Cache-Control`。`Cache-Control`能做`expires`做的事，也能做`expires`做不到的事情，目前`expires`还存在是为了做向下兼容。\n\n`Cache-Control`的格式为：\n\n```js\nCache-Control: max-age=3600\n```\n\n在`Cache-Control`中，`max-age`字段表示资源最大缓存时间（秒），上面例子表示在3600秒内该资源都是有效的。`Cache-Control`表示的时间比`expires`时间戳更为准确，同时`Cache-Control`优先级更高，两者存在时以`Cache-Control`为准。\n\n`Cache-Control`还有其它的缓存方式：`no-cache`和`no-store`。\n\n如果给资源设置了`no-cache`，则会绕开浏览器，直接询问服务器该资源是否过期，即走**协商缓存**。`no-store`顾名思义，就比较绝情了，不设置任何缓存，每次发起请求不经过浏览器与服务端缓存，直接想服务器发送请求，并下载完整的响应。\n\n#### 协商缓存\n\n协商缓存，顾名思义就是浏览器与服务器合作的缓存策略，它依赖于浏览器与服务器之间的通信，浏览器需要向服务器询问缓存的相关信息，进而判断是读取本地缓存的资源还是重新发起请求，下载完整的响应。\n\n##### 协商缓存的实现\n\n**Last-Modified**\n\n`Last-Modified`是一个时间戳，在启用协商缓存之后，会在首次请求的时候，随着Response Headers返回\n\n```javascript\nLast-Modified: Wed, 12 Feb 2020 09:21:28 GMT\n```\n\n随后每次请求会带上`If-Modified-Since`时间戳字段，值为上一次Response返回的`Last-Modified`值\n\n```javascript\nIf-Modified-Since: Wed, 12 Feb 2020 09:21:28 GMT\n```\n\n服务器收到这个时间戳之后，会根据该时间戳与服务器的资源的最后修改时间对比，如果时间改变，则返回一个新的完整的响应，并在Response Headers返回新的`Last-Modified`值；如果时间没有变化，则返回一个304状态码，提示资源并未改动，然后重定向到浏览器缓存，Response Headers也不会再返回`Last-Modified`字段，如下图：\n\n![304](/images/304.png)\n\n但是使用`Last-Modified`也会存在弊端：\n\n- 资源文件改动了，但是并没有改变内容，文件的最后修改时间会变化，导致该资源会被重新请求\n- `If-Modified-Since`是以秒为单位做检验，如果改动文件的时间小于1000ms，那么该资源有可能被认为是未改变的，导致无法重新请求\n\n这两种情况反映了一个问题，无法准确感知文件是否发生改变。\n\n为了解决该问题，`Etag`出现了。\n\n`Etag`是服务器为每个资源生成的唯一的**标识字符串**，这个标识字符串是基于文件内容编码的，文件内容不同，对应的 `Etag` 就是不同的，因此`Etag` 能够精准地感知文件的变化。\n\n`Etag` 和 `Last-Modified` 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这个样子\n\n```javascript\nETag: W/\"1q2w-108946715\"\n```\n\n在下一次请求时，会带上与之相同值的字段`if-None-Match`，提供给服务器对比\n\n```javascript\nIf-None-Match: W/\"1q2w-108946715\"\n```\n\n很明显，`Etag`有利也有弊，它的生成需要服务器付出额外的开销，会影响服务器的性能，`Etag`并不能直接代替`Last-Modified`，而是作为补充，它的优先级比`Last-Modified`高，两者共存时，以`Etag`为准。\n\n### HTTP缓存策略\n\n对于上面讲的知识点，要如何对应到实际的开发中呢，这边拿了谷歌官方的一张图：\n\n![缓存策略](/images/缓存策略.png)\n\n这张图片清楚地给我们展示了缓存策略流程。\n\n首先看看资源的可复用性，如果是不可复用的话，很干脆，直接把`Cache-control`设置为`no-store`，不需要任何形式的缓存。\n\n如果是可复用的资源，那么看看是否需要每次都向服务器去验证缓存是否有效，如果需要，则设置`Cache-control`为`no-store`，不需要的，则进行下一步，考虑资源是否可被代理服务器缓存，根据情况设置`private`或`public`；接着考虑资源的过期时间，设置资源的`max-age`；最后一步配置协商缓存，设置`Last-Modified`和`Etag`。\n\n### 结语\n\nHTTP缓存的知识点比较琐碎，很多人过段时间很容易忘记。只有多分析多总结，才能够把握这些知识。","slug":"浅析HTTP缓存","published":1,"date":"2020-02-12T16:10:22.432Z","updated":"2020-02-25T23:54:50.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4ma001ohsuhiwq9kazi","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>浏览器缓存机制有<strong>四个方面</strong>，按照资源获取优先级排列，分别是<code>Memory Cache</code>、<code>Service Worker Cache</code>、<code>HTTP Cache</code>、<code>Push Cache</code>。我们经常使用，也比较熟悉的是HTTP Cache。这里单独分析HTTP Cache。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"HTTP-Cache\"><a href=\"#HTTP-Cache\" class=\"headerlink\" title=\"HTTP Cache\"></a>HTTP Cache</h3><p>HTTP Cache又分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存优先级比较高，未命中强缓存时才走协商缓存。</p>\n<h4 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h4><p>强缓存是通过http头的<code>expires</code>和<code>cache-control</code>来实现控制。当再发出请求时，浏览器会根据<code>expires</code>和<code>cache-control</code>来判断是否命中强缓存，若命中直接从缓存中获取资源，而不再与服务端进行通信。</p>\n<p>在http1.0版本中，服务器响应时会返回一个缓存过期时间戳字段<code>expires</code>，再次发起请求时浏览器通过本地时间与<code>expires</code>时间戳对比，来判断缓存是否过期，这种依赖本地时间的方式会存在一个弊端，如果修改了本地时间，或者本地时间与服务端时间不同步，这将达不到我们预期的缓存效果。</p>\n<p>因此，在http1.1版本中，引入了<code>expires</code>的替代方案：<code>Cache-Control</code>。<code>Cache-Control</code>能做<code>expires</code>做的事，也能做<code>expires</code>做不到的事情，目前<code>expires</code>还存在是为了做向下兼容。</p>\n<p><code>Cache-Control</code>的格式为：</p>\n<figure class=\"highlight js hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=<span class=\"hljs-number\">3600</span></span><br></pre></td></tr></table></figure>\n\n<p>在<code>Cache-Control</code>中，<code>max-age</code>字段表示资源最大缓存时间（秒），上面例子表示在3600秒内该资源都是有效的。<code>Cache-Control</code>表示的时间比<code>expires</code>时间戳更为准确，同时<code>Cache-Control</code>优先级更高，两者存在时以<code>Cache-Control</code>为准。</p>\n<p><code>Cache-Control</code>还有其它的缓存方式：<code>no-cache</code>和<code>no-store</code>。</p>\n<p>如果给资源设置了<code>no-cache</code>，则会绕开浏览器，直接询问服务器该资源是否过期，即走<strong>协商缓存</strong>。<code>no-store</code>顾名思义，就比较绝情了，不设置任何缓存，每次发起请求不经过浏览器与服务端缓存，直接想服务器发送请求，并下载完整的响应。</p>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><p>协商缓存，顾名思义就是浏览器与服务器合作的缓存策略，它依赖于浏览器与服务器之间的通信，浏览器需要向服务器询问缓存的相关信息，进而判断是读取本地缓存的资源还是重新发起请求，下载完整的响应。</p>\n<h5 id=\"协商缓存的实现\"><a href=\"#协商缓存的实现\" class=\"headerlink\" title=\"协商缓存的实现\"></a>协商缓存的实现</h5><p><strong>Last-Modified</strong></p>\n<p><code>Last-Modified</code>是一个时间戳，在启用协商缓存之后，会在首次请求的时候，随着Response Headers返回</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last-Modified: Wed, <span class=\"hljs-number\">12</span> Feb <span class=\"hljs-number\">2020</span> <span class=\"hljs-number\">09</span>:<span class=\"hljs-number\">21</span>:<span class=\"hljs-number\">28</span> GMT</span><br></pre></td></tr></table></figure>\n\n<p>随后每次请求会带上<code>If-Modified-Since</code>时间戳字段，值为上一次Response返回的<code>Last-Modified</code>值</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-Modified-Since: Wed, <span class=\"hljs-number\">12</span> Feb <span class=\"hljs-number\">2020</span> <span class=\"hljs-number\">09</span>:<span class=\"hljs-number\">21</span>:<span class=\"hljs-number\">28</span> GMT</span><br></pre></td></tr></table></figure>\n\n<p>服务器收到这个时间戳之后，会根据该时间戳与服务器的资源的最后修改时间对比，如果时间改变，则返回一个新的完整的响应，并在Response Headers返回新的<code>Last-Modified</code>值；如果时间没有变化，则返回一个304状态码，提示资源并未改动，然后重定向到浏览器缓存，Response Headers也不会再返回<code>Last-Modified</code>字段，如下图：</p>\n<p><img src=\"/images/304.png\" alt=\"304\"></p>\n<p>但是使用<code>Last-Modified</code>也会存在弊端：</p>\n<ul>\n<li>资源文件改动了，但是并没有改变内容，文件的最后修改时间会变化，导致该资源会被重新请求</li>\n<li><code>If-Modified-Since</code>是以秒为单位做检验，如果改动文件的时间小于1000ms，那么该资源有可能被认为是未改变的，导致无法重新请求</li>\n</ul>\n<p>这两种情况反映了一个问题，无法准确感知文件是否发生改变。</p>\n<p>为了解决该问题，<code>Etag</code>出现了。</p>\n<p><code>Etag</code>是服务器为每个资源生成的唯一的<strong>标识字符串</strong>，这个标识字符串是基于文件内容编码的，文件内容不同，对应的 <code>Etag</code> 就是不同的，因此<code>Etag</code> 能够精准地感知文件的变化。</p>\n<p><code>Etag</code> 和 <code>Last-Modified</code> 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这个样子</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ETag: W/<span class=\"hljs-string\">\"1q2w-108946715\"</span></span><br></pre></td></tr></table></figure>\n\n<p>在下一次请求时，会带上与之相同值的字段<code>if-None-Match</code>，提供给服务器对比</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-None-Match: W/<span class=\"hljs-string\">\"1q2w-108946715\"</span></span><br></pre></td></tr></table></figure>\n\n<p>很明显，<code>Etag</code>有利也有弊，它的生成需要服务器付出额外的开销，会影响服务器的性能，<code>Etag</code>并不能直接代替<code>Last-Modified</code>，而是作为补充，它的优先级比<code>Last-Modified</code>高，两者共存时，以<code>Etag</code>为准。</p>\n<h3 id=\"HTTP缓存策略\"><a href=\"#HTTP缓存策略\" class=\"headerlink\" title=\"HTTP缓存策略\"></a>HTTP缓存策略</h3><p>对于上面讲的知识点，要如何对应到实际的开发中呢，这边拿了谷歌官方的一张图：</p>\n<p><img src=\"/images/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png\" alt=\"缓存策略\"></p>\n<p>这张图片清楚地给我们展示了缓存策略流程。</p>\n<p>首先看看资源的可复用性，如果是不可复用的话，很干脆，直接把<code>Cache-control</code>设置为<code>no-store</code>，不需要任何形式的缓存。</p>\n<p>如果是可复用的资源，那么看看是否需要每次都向服务器去验证缓存是否有效，如果需要，则设置<code>Cache-control</code>为<code>no-store</code>，不需要的，则进行下一步，考虑资源是否可被代理服务器缓存，根据情况设置<code>private</code>或<code>public</code>；接着考虑资源的过期时间，设置资源的<code>max-age</code>；最后一步配置协商缓存，设置<code>Last-Modified</code>和<code>Etag</code>。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>HTTP缓存的知识点比较琐碎，很多人过段时间很容易忘记。只有多分析多总结，才能够把握这些知识。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>浏览器缓存机制有<strong>四个方面</strong>，按照资源获取优先级排列，分别是<code>Memory Cache</code>、<code>Service Worker Cache</code>、<code>HTTP Cache</code>、<code>Push Cache</code>。我们经常使用，也比较熟悉的是HTTP Cache。这里单独分析HTTP Cache。</p>\n</blockquote>","more":"<h3 id=\"HTTP-Cache\"><a href=\"#HTTP-Cache\" class=\"headerlink\" title=\"HTTP Cache\"></a>HTTP Cache</h3><p>HTTP Cache又分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存优先级比较高，未命中强缓存时才走协商缓存。</p>\n<h4 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h4><p>强缓存是通过http头的<code>expires</code>和<code>cache-control</code>来实现控制。当再发出请求时，浏览器会根据<code>expires</code>和<code>cache-control</code>来判断是否命中强缓存，若命中直接从缓存中获取资源，而不再与服务端进行通信。</p>\n<p>在http1.0版本中，服务器响应时会返回一个缓存过期时间戳字段<code>expires</code>，再次发起请求时浏览器通过本地时间与<code>expires</code>时间戳对比，来判断缓存是否过期，这种依赖本地时间的方式会存在一个弊端，如果修改了本地时间，或者本地时间与服务端时间不同步，这将达不到我们预期的缓存效果。</p>\n<p>因此，在http1.1版本中，引入了<code>expires</code>的替代方案：<code>Cache-Control</code>。<code>Cache-Control</code>能做<code>expires</code>做的事，也能做<code>expires</code>做不到的事情，目前<code>expires</code>还存在是为了做向下兼容。</p>\n<p><code>Cache-Control</code>的格式为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=<span class=\"number\">3600</span></span><br></pre></td></tr></table></figure>\n\n<p>在<code>Cache-Control</code>中，<code>max-age</code>字段表示资源最大缓存时间（秒），上面例子表示在3600秒内该资源都是有效的。<code>Cache-Control</code>表示的时间比<code>expires</code>时间戳更为准确，同时<code>Cache-Control</code>优先级更高，两者存在时以<code>Cache-Control</code>为准。</p>\n<p><code>Cache-Control</code>还有其它的缓存方式：<code>no-cache</code>和<code>no-store</code>。</p>\n<p>如果给资源设置了<code>no-cache</code>，则会绕开浏览器，直接询问服务器该资源是否过期，即走<strong>协商缓存</strong>。<code>no-store</code>顾名思义，就比较绝情了，不设置任何缓存，每次发起请求不经过浏览器与服务端缓存，直接想服务器发送请求，并下载完整的响应。</p>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><p>协商缓存，顾名思义就是浏览器与服务器合作的缓存策略，它依赖于浏览器与服务器之间的通信，浏览器需要向服务器询问缓存的相关信息，进而判断是读取本地缓存的资源还是重新发起请求，下载完整的响应。</p>\n<h5 id=\"协商缓存的实现\"><a href=\"#协商缓存的实现\" class=\"headerlink\" title=\"协商缓存的实现\"></a>协商缓存的实现</h5><p><strong>Last-Modified</strong></p>\n<p><code>Last-Modified</code>是一个时间戳，在启用协商缓存之后，会在首次请求的时候，随着Response Headers返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last-Modified: Wed, <span class=\"number\">12</span> Feb <span class=\"number\">2020</span> <span class=\"number\">09</span>:<span class=\"number\">21</span>:<span class=\"number\">28</span> GMT</span><br></pre></td></tr></table></figure>\n\n<p>随后每次请求会带上<code>If-Modified-Since</code>时间戳字段，值为上一次Response返回的<code>Last-Modified</code>值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-Modified-Since: Wed, <span class=\"number\">12</span> Feb <span class=\"number\">2020</span> <span class=\"number\">09</span>:<span class=\"number\">21</span>:<span class=\"number\">28</span> GMT</span><br></pre></td></tr></table></figure>\n\n<p>服务器收到这个时间戳之后，会根据该时间戳与服务器的资源的最后修改时间对比，如果时间改变，则返回一个新的完整的响应，并在Response Headers返回新的<code>Last-Modified</code>值；如果时间没有变化，则返回一个304状态码，提示资源并未改动，然后重定向到浏览器缓存，Response Headers也不会再返回<code>Last-Modified</code>字段，如下图：</p>\n<p><img src=\"/images/304.png\" alt=\"304\"></p>\n<p>但是使用<code>Last-Modified</code>也会存在弊端：</p>\n<ul>\n<li>资源文件改动了，但是并没有改变内容，文件的最后修改时间会变化，导致该资源会被重新请求</li>\n<li><code>If-Modified-Since</code>是以秒为单位做检验，如果改动文件的时间小于1000ms，那么该资源有可能被认为是未改变的，导致无法重新请求</li>\n</ul>\n<p>这两种情况反映了一个问题，无法准确感知文件是否发生改变。</p>\n<p>为了解决该问题，<code>Etag</code>出现了。</p>\n<p><code>Etag</code>是服务器为每个资源生成的唯一的<strong>标识字符串</strong>，这个标识字符串是基于文件内容编码的，文件内容不同，对应的 <code>Etag</code> 就是不同的，因此<code>Etag</code> 能够精准地感知文件的变化。</p>\n<p><code>Etag</code> 和 <code>Last-Modified</code> 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这个样子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ETag: W/<span class=\"string\">\"1q2w-108946715\"</span></span><br></pre></td></tr></table></figure>\n\n<p>在下一次请求时，会带上与之相同值的字段<code>if-None-Match</code>，提供给服务器对比</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If-None-Match: W/<span class=\"string\">\"1q2w-108946715\"</span></span><br></pre></td></tr></table></figure>\n\n<p>很明显，<code>Etag</code>有利也有弊，它的生成需要服务器付出额外的开销，会影响服务器的性能，<code>Etag</code>并不能直接代替<code>Last-Modified</code>，而是作为补充，它的优先级比<code>Last-Modified</code>高，两者共存时，以<code>Etag</code>为准。</p>\n<h3 id=\"HTTP缓存策略\"><a href=\"#HTTP缓存策略\" class=\"headerlink\" title=\"HTTP缓存策略\"></a>HTTP缓存策略</h3><p>对于上面讲的知识点，要如何对应到实际的开发中呢，这边拿了谷歌官方的一张图：</p>\n<p><img src=\"/images/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png\" alt=\"缓存策略\"></p>\n<p>这张图片清楚地给我们展示了缓存策略流程。</p>\n<p>首先看看资源的可复用性，如果是不可复用的话，很干脆，直接把<code>Cache-control</code>设置为<code>no-store</code>，不需要任何形式的缓存。</p>\n<p>如果是可复用的资源，那么看看是否需要每次都向服务器去验证缓存是否有效，如果需要，则设置<code>Cache-control</code>为<code>no-store</code>，不需要的，则进行下一步，考虑资源是否可被代理服务器缓存，根据情况设置<code>private</code>或<code>public</code>；接着考虑资源的过期时间，设置资源的<code>max-age</code>；最后一步配置协商缓存，设置<code>Last-Modified</code>和<code>Etag</code>。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>HTTP缓存的知识点比较琐碎，很多人过段时间很容易忘记。只有多分析多总结，才能够把握这些知识。</p>"},{"title":"浅析浏览器另外三大缓存","_content":"\n### 前言\n\n> 上一篇分析了浏览器缓存类型之一：HTTP缓存，接下来简单分析一下浏览器另外的三大缓存机制：Memory Cache、Service Worker Cache以及Push Cache。\n\n<!-- more -->\n\n### Memory Cache\n\nMemory Cache是指内存中的缓存，是浏览器尝试命中的优先级最高的缓存，其响应速度也是最快的。\n\n哪些资源会被放进内存缓存呢？这个没有明确的规定，因为内存本身就是有限的，对于内存来讲，很多时候需要考虑内存的即时余量以及资源本身大小，根据日常开发观察的结果，base64格式的图片几乎是被放到内存缓存，而文件体积较小的JS、CSS文件，也有很大的几率可以写进内存缓存，至于体积比较大的，用一句俗话来讲，就是“庙小容不了大佛”，几乎是不可能给写进内存缓存的。\n\n内存缓存的响应速度虽然很快，但是相应的，它的“寿命”是比较短的，当我们关闭tab之后，内存里的数据也将不复存在。\n\n### Service Worker Cache\n\nservice worker运行在worker上下文，因此它无法访问DOM，同时独立于主线程，可以在浏览器幕后帮我们实现消息推送、离线缓存等操作，而借助于service worker实现的缓存，就是离线缓存。\n\n> PS：出于安全考量，Service workers只能由HTTPS承载。\n\nservice worker需要先进行install（安装），之后会一直存在，并且只在active（激活）和working（工作）之间切换，直到我们主动终止。\n\n下面看实践的例子，新建`index.html`和`index.js`两个文件\n\n#### 注册\n\n```html\n<!-- index.html -->\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>service worker test</title>\n</head>\n<body>\n  <script>\n     if ('serviceWorker' in navigator) {\n       window.addEventListener('load', () => {\n         navigator.serviceWorker.register('./index.js', {scope: './'})\n         .then((res) => {\n           console.log(`注册成功`)\n         })\n         .catch(err => {\n           console.log(`注册失败：${err}`)\n         })\n       })\n     } \n  </script>\n</body>\n</html>\n```\n\n第一步，先判断浏览器是否支持`serviceWorker`；\n\n第二步，浏览器若支持，再通过`register`方法注册`index.js`文件，scope指定service worker控制内容的子目录，该参数为可选参数，默认为根目录；\n\n第三步，通过返回的Promise，了解注册成功或失败\n\n#### 安装\n\n```javascript\n// index.js\n\nthis.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('v1').then((cache) => {\n      return cache.addAll([\n        'index.html'\n      ])\n    })\n  )\n})\n```\n\n第一步，通过`install`方法，安装service worker；\n\n第二步，这里要注意的是，从安装到激活这个过程需要一些时间，service worker标准提供一个`waitUntil`方法，当`oninstall`或者`onactivate`触发时被调用，接受一个promise。在这个 promise被成功resolve以前，功能性事件不会分发到service worker；\n\n第三步，我们在`waitUntil`方法里面使用了`cache.open`来创建一个新的缓存v1，它返回一个promise，在被resolved之后调用`addAll`方法来添加要缓存的资源的路径；如果被rejected，service worker不会做任何操作。\n\n#### 运行\n\n通过webstorm打开index.html，可以为我们开启一个本地服务器，运行后可以看到：\n\n注册成功\n\n![注册成功](/images/注册成功.png)\n\n缓存成功\n\n![缓存成功](/images/缓存成功.png)\n\n#### 使用缓存\n\n我们成功添加缓存之后，接下来就是要使用缓存。\n\nService Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以通过监听fetch事件来处理我们的操作。\n\n```javascript\n// index.js\n\nthis.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n  )\n})\n```\n\n第一步，监听fetch事件；\n\n第二步，通过`respondWith`方法劫持请求；\n\n第三步，可以自定义我们的操作，当然最简单粗暴的就是直接返回我们缓存的资源\n\n再刷新浏览器，可以看到，index.html来自于service worker cache\n\n![使用serviceWorker缓存](/images/使用serviceWorker缓存.png)\n\n### Push Cache\n\npush cache（推送缓存）是比较新颖的东西，属于HTTP/2，当前面几种缓存没有命中的时候，才会询问推送缓存。\n\n具体的可以查看Jake Archibald大神的[HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)\n\n文章中有部分结论：\n\n- Push Cache 是缓存的最后一道防线。浏览器只有在 前面说到的几种缓存均未命中的情况下才会去询问 Push Cache；\n- Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放；\n- 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache；\n- Push Cache 中的缓存只能被使用一次\n\n### 结语\n\n浏览器的缓存知识博大精深，就算不断在工作中和学习中实践，也只能说理解皮毛。而理解浏览器缓存，也仅仅是我们对页面性能优化的第一步，还有更多的操作等着我们。","source":"_posts/浅析浏览器另外三大缓存.md","raw":"---\ntitle: 浅析浏览器另外三大缓存\ncategories:\n - 网络\ntags:\n - 缓存\n---\n\n### 前言\n\n> 上一篇分析了浏览器缓存类型之一：HTTP缓存，接下来简单分析一下浏览器另外的三大缓存机制：Memory Cache、Service Worker Cache以及Push Cache。\n\n<!-- more -->\n\n### Memory Cache\n\nMemory Cache是指内存中的缓存，是浏览器尝试命中的优先级最高的缓存，其响应速度也是最快的。\n\n哪些资源会被放进内存缓存呢？这个没有明确的规定，因为内存本身就是有限的，对于内存来讲，很多时候需要考虑内存的即时余量以及资源本身大小，根据日常开发观察的结果，base64格式的图片几乎是被放到内存缓存，而文件体积较小的JS、CSS文件，也有很大的几率可以写进内存缓存，至于体积比较大的，用一句俗话来讲，就是“庙小容不了大佛”，几乎是不可能给写进内存缓存的。\n\n内存缓存的响应速度虽然很快，但是相应的，它的“寿命”是比较短的，当我们关闭tab之后，内存里的数据也将不复存在。\n\n### Service Worker Cache\n\nservice worker运行在worker上下文，因此它无法访问DOM，同时独立于主线程，可以在浏览器幕后帮我们实现消息推送、离线缓存等操作，而借助于service worker实现的缓存，就是离线缓存。\n\n> PS：出于安全考量，Service workers只能由HTTPS承载。\n\nservice worker需要先进行install（安装），之后会一直存在，并且只在active（激活）和working（工作）之间切换，直到我们主动终止。\n\n下面看实践的例子，新建`index.html`和`index.js`两个文件\n\n#### 注册\n\n```html\n<!-- index.html -->\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>service worker test</title>\n</head>\n<body>\n  <script>\n     if ('serviceWorker' in navigator) {\n       window.addEventListener('load', () => {\n         navigator.serviceWorker.register('./index.js', {scope: './'})\n         .then((res) => {\n           console.log(`注册成功`)\n         })\n         .catch(err => {\n           console.log(`注册失败：${err}`)\n         })\n       })\n     } \n  </script>\n</body>\n</html>\n```\n\n第一步，先判断浏览器是否支持`serviceWorker`；\n\n第二步，浏览器若支持，再通过`register`方法注册`index.js`文件，scope指定service worker控制内容的子目录，该参数为可选参数，默认为根目录；\n\n第三步，通过返回的Promise，了解注册成功或失败\n\n#### 安装\n\n```javascript\n// index.js\n\nthis.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('v1').then((cache) => {\n      return cache.addAll([\n        'index.html'\n      ])\n    })\n  )\n})\n```\n\n第一步，通过`install`方法，安装service worker；\n\n第二步，这里要注意的是，从安装到激活这个过程需要一些时间，service worker标准提供一个`waitUntil`方法，当`oninstall`或者`onactivate`触发时被调用，接受一个promise。在这个 promise被成功resolve以前，功能性事件不会分发到service worker；\n\n第三步，我们在`waitUntil`方法里面使用了`cache.open`来创建一个新的缓存v1，它返回一个promise，在被resolved之后调用`addAll`方法来添加要缓存的资源的路径；如果被rejected，service worker不会做任何操作。\n\n#### 运行\n\n通过webstorm打开index.html，可以为我们开启一个本地服务器，运行后可以看到：\n\n注册成功\n\n![注册成功](/images/注册成功.png)\n\n缓存成功\n\n![缓存成功](/images/缓存成功.png)\n\n#### 使用缓存\n\n我们成功添加缓存之后，接下来就是要使用缓存。\n\nService Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以通过监听fetch事件来处理我们的操作。\n\n```javascript\n// index.js\n\nthis.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n  )\n})\n```\n\n第一步，监听fetch事件；\n\n第二步，通过`respondWith`方法劫持请求；\n\n第三步，可以自定义我们的操作，当然最简单粗暴的就是直接返回我们缓存的资源\n\n再刷新浏览器，可以看到，index.html来自于service worker cache\n\n![使用serviceWorker缓存](/images/使用serviceWorker缓存.png)\n\n### Push Cache\n\npush cache（推送缓存）是比较新颖的东西，属于HTTP/2，当前面几种缓存没有命中的时候，才会询问推送缓存。\n\n具体的可以查看Jake Archibald大神的[HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)\n\n文章中有部分结论：\n\n- Push Cache 是缓存的最后一道防线。浏览器只有在 前面说到的几种缓存均未命中的情况下才会去询问 Push Cache；\n- Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放；\n- 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache；\n- Push Cache 中的缓存只能被使用一次\n\n### 结语\n\n浏览器的缓存知识博大精深，就算不断在工作中和学习中实践，也只能说理解皮毛。而理解浏览器缓存，也仅仅是我们对页面性能优化的第一步，还有更多的操作等着我们。","slug":"浅析浏览器另外三大缓存","published":1,"date":"2020-02-18T09:56:49.303Z","updated":"2020-02-20T06:04:13.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4mc001shsuh4ynmnigg","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>上一篇分析了浏览器缓存类型之一：HTTP缓存，接下来简单分析一下浏览器另外的三大缓存机制：Memory Cache、Service Worker Cache以及Push Cache。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"Memory-Cache\"><a href=\"#Memory-Cache\" class=\"headerlink\" title=\"Memory Cache\"></a>Memory Cache</h3><p>Memory Cache是指内存中的缓存，是浏览器尝试命中的优先级最高的缓存，其响应速度也是最快的。</p>\n<p>哪些资源会被放进内存缓存呢？这个没有明确的规定，因为内存本身就是有限的，对于内存来讲，很多时候需要考虑内存的即时余量以及资源本身大小，根据日常开发观察的结果，base64格式的图片几乎是被放到内存缓存，而文件体积较小的JS、CSS文件，也有很大的几率可以写进内存缓存，至于体积比较大的，用一句俗话来讲，就是“庙小容不了大佛”，几乎是不可能给写进内存缓存的。</p>\n<p>内存缓存的响应速度虽然很快，但是相应的，它的“寿命”是比较短的，当我们关闭tab之后，内存里的数据也将不复存在。</p>\n<h3 id=\"Service-Worker-Cache\"><a href=\"#Service-Worker-Cache\" class=\"headerlink\" title=\"Service Worker Cache\"></a>Service Worker Cache</h3><p>service worker运行在worker上下文，因此它无法访问DOM，同时独立于主线程，可以在浏览器幕后帮我们实现消息推送、离线缓存等操作，而借助于service worker实现的缓存，就是离线缓存。</p>\n<blockquote>\n<p>PS：出于安全考量，Service workers只能由HTTPS承载。</p>\n</blockquote>\n<p>service worker需要先进行install（安装），之后会一直存在，并且只在active（激活）和working（工作）之间切换，直到我们主动终止。</p>\n<p>下面看实践的例子，新建<code>index.html</code>和<code>index.js</code>两个文件</p>\n<h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><figure class=\"highlight html hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>service worker test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"hljs-javascript\">     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'serviceWorker'</span> <span class=\"hljs-keyword\">in</span> navigator) &#123;</span></span><br><span class=\"line\"><span class=\"hljs-javascript\">       <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'load'</span>, () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"hljs-javascript\">         navigator.serviceWorker.register(<span class=\"hljs-string\">'./index.js'</span>, &#123;<span class=\"hljs-attr\">scope</span>: <span class=\"hljs-string\">'./'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"hljs-javascript\">         .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"hljs-javascript\">           <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`注册成功`</span>)</span></span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\"><span class=\"hljs-javascript\">         .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"hljs-javascript\">           <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`注册失败：<span class=\"hljs-subst\">$&#123;err&#125;</span>`</span>)</span></span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第一步，先判断浏览器是否支持<code>serviceWorker</code>；</p>\n<p>第二步，浏览器若支持，再通过<code>register</code>方法注册<code>index.js</code>文件，scope指定service worker控制内容的子目录，该参数为可选参数，默认为根目录；</p>\n<p>第三步，通过返回的Promise，了解注册成功或失败</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">this</span>.addEventListener(<span class=\"hljs-string\">'install'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    caches.open(<span class=\"hljs-string\">'v1'</span>).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">cache</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> cache.addAll([</span><br><span class=\"line\">        <span class=\"hljs-string\">'index.html'</span></span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>第一步，通过<code>install</code>方法，安装service worker；</p>\n<p>第二步，这里要注意的是，从安装到激活这个过程需要一些时间，service worker标准提供一个<code>waitUntil</code>方法，当<code>oninstall</code>或者<code>onactivate</code>触发时被调用，接受一个promise。在这个 promise被成功resolve以前，功能性事件不会分发到service worker；</p>\n<p>第三步，我们在<code>waitUntil</code>方法里面使用了<code>cache.open</code>来创建一个新的缓存v1，它返回一个promise，在被resolved之后调用<code>addAll</code>方法来添加要缓存的资源的路径；如果被rejected，service worker不会做任何操作。</p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>通过webstorm打开index.html，可以为我们开启一个本地服务器，运行后可以看到：</p>\n<p>注册成功</p>\n<p><img src=\"/images/%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F.png\" alt=\"注册成功\"></p>\n<p>缓存成功</p>\n<p><img src=\"/images/%E7%BC%93%E5%AD%98%E6%88%90%E5%8A%9F.png\" alt=\"缓存成功\"></p>\n<h4 id=\"使用缓存\"><a href=\"#使用缓存\" class=\"headerlink\" title=\"使用缓存\"></a>使用缓存</h4><p>我们成功添加缓存之后，接下来就是要使用缓存。</p>\n<p>Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以通过监听fetch事件来处理我们的操作。</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">this</span>.addEventListener(<span class=\"hljs-string\">'fetch'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    caches.match(event.request)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>第一步，监听fetch事件；</p>\n<p>第二步，通过<code>respondWith</code>方法劫持请求；</p>\n<p>第三步，可以自定义我们的操作，当然最简单粗暴的就是直接返回我们缓存的资源</p>\n<p>再刷新浏览器，可以看到，index.html来自于service worker cache</p>\n<p><img src=\"/images/%E4%BD%BF%E7%94%A8serviceWorker%E7%BC%93%E5%AD%98.png\" alt=\"使用serviceWorker缓存\"></p>\n<h3 id=\"Push-Cache\"><a href=\"#Push-Cache\" class=\"headerlink\" title=\"Push Cache\"></a>Push Cache</h3><p>push cache（推送缓存）是比较新颖的东西，属于HTTP/2，当前面几种缓存没有命中的时候，才会询问推送缓存。</p>\n<p>具体的可以查看Jake Archibald大神的<a href=\"https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/\" target=\"_blank\" rel=\"noopener\">HTTP/2 push is tougher than I thought</a></p>\n<p>文章中有部分结论：</p>\n<ul>\n<li>Push Cache 是缓存的最后一道防线。浏览器只有在 前面说到的几种缓存均未命中的情况下才会去询问 Push Cache；</li>\n<li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放；</li>\n<li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache；</li>\n<li>Push Cache 中的缓存只能被使用一次</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>浏览器的缓存知识博大精深，就算不断在工作中和学习中实践，也只能说理解皮毛。而理解浏览器缓存，也仅仅是我们对页面性能优化的第一步，还有更多的操作等着我们。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>上一篇分析了浏览器缓存类型之一：HTTP缓存，接下来简单分析一下浏览器另外的三大缓存机制：Memory Cache、Service Worker Cache以及Push Cache。</p>\n</blockquote>","more":"<h3 id=\"Memory-Cache\"><a href=\"#Memory-Cache\" class=\"headerlink\" title=\"Memory Cache\"></a>Memory Cache</h3><p>Memory Cache是指内存中的缓存，是浏览器尝试命中的优先级最高的缓存，其响应速度也是最快的。</p>\n<p>哪些资源会被放进内存缓存呢？这个没有明确的规定，因为内存本身就是有限的，对于内存来讲，很多时候需要考虑内存的即时余量以及资源本身大小，根据日常开发观察的结果，base64格式的图片几乎是被放到内存缓存，而文件体积较小的JS、CSS文件，也有很大的几率可以写进内存缓存，至于体积比较大的，用一句俗话来讲，就是“庙小容不了大佛”，几乎是不可能给写进内存缓存的。</p>\n<p>内存缓存的响应速度虽然很快，但是相应的，它的“寿命”是比较短的，当我们关闭tab之后，内存里的数据也将不复存在。</p>\n<h3 id=\"Service-Worker-Cache\"><a href=\"#Service-Worker-Cache\" class=\"headerlink\" title=\"Service Worker Cache\"></a>Service Worker Cache</h3><p>service worker运行在worker上下文，因此它无法访问DOM，同时独立于主线程，可以在浏览器幕后帮我们实现消息推送、离线缓存等操作，而借助于service worker实现的缓存，就是离线缓存。</p>\n<blockquote>\n<p>PS：出于安全考量，Service workers只能由HTTPS承载。</p>\n</blockquote>\n<p>service worker需要先进行install（安装），之后会一直存在，并且只在active（激活）和working（工作）之间切换，直到我们主动终止。</p>\n<p>下面看实践的例子，新建<code>index.html</code>和<code>index.js</code>两个文件</p>\n<h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- index.html --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>service worker test<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">     <span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">       <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">         navigator.serviceWorker.register(<span class=\"string\">'./index.js'</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">'./'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">         .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"built_in\">console</span>.log(<span class=\"string\">`注册成功`</span>)</span></span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\"><span class=\"javascript\">         .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">           <span class=\"built_in\">console</span>.log(<span class=\"string\">`注册失败：<span class=\"subst\">$&#123;err&#125;</span>`</span>)</span></span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第一步，先判断浏览器是否支持<code>serviceWorker</code>；</p>\n<p>第二步，浏览器若支持，再通过<code>register</code>方法注册<code>index.js</code>文件，scope指定service worker控制内容的子目录，该参数为可选参数，默认为根目录；</p>\n<p>第三步，通过返回的Promise，了解注册成功或失败</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.addEventListener(<span class=\"string\">'install'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  event.waitUntil(</span><br><span class=\"line\">    caches.open(<span class=\"string\">'v1'</span>).then(<span class=\"function\">(<span class=\"params\">cache</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.addAll([</span><br><span class=\"line\">        <span class=\"string\">'index.html'</span></span><br><span class=\"line\">      ])</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>第一步，通过<code>install</code>方法，安装service worker；</p>\n<p>第二步，这里要注意的是，从安装到激活这个过程需要一些时间，service worker标准提供一个<code>waitUntil</code>方法，当<code>oninstall</code>或者<code>onactivate</code>触发时被调用，接受一个promise。在这个 promise被成功resolve以前，功能性事件不会分发到service worker；</p>\n<p>第三步，我们在<code>waitUntil</code>方法里面使用了<code>cache.open</code>来创建一个新的缓存v1，它返回一个promise，在被resolved之后调用<code>addAll</code>方法来添加要缓存的资源的路径；如果被rejected，service worker不会做任何操作。</p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><p>通过webstorm打开index.html，可以为我们开启一个本地服务器，运行后可以看到：</p>\n<p>注册成功</p>\n<p><img src=\"/images/%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F.png\" alt=\"注册成功\"></p>\n<p>缓存成功</p>\n<p><img src=\"/images/%E7%BC%93%E5%AD%98%E6%88%90%E5%8A%9F.png\" alt=\"缓存成功\"></p>\n<h4 id=\"使用缓存\"><a href=\"#使用缓存\" class=\"headerlink\" title=\"使用缓存\"></a>使用缓存</h4><p>我们成功添加缓存之后，接下来就是要使用缓存。</p>\n<p>Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以通过监听fetch事件来处理我们的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.addEventListener(<span class=\"string\">'fetch'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  event.respondWith(</span><br><span class=\"line\">    caches.match(event.request)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>第一步，监听fetch事件；</p>\n<p>第二步，通过<code>respondWith</code>方法劫持请求；</p>\n<p>第三步，可以自定义我们的操作，当然最简单粗暴的就是直接返回我们缓存的资源</p>\n<p>再刷新浏览器，可以看到，index.html来自于service worker cache</p>\n<p><img src=\"/images/%E4%BD%BF%E7%94%A8serviceWorker%E7%BC%93%E5%AD%98.png\" alt=\"使用serviceWorker缓存\"></p>\n<h3 id=\"Push-Cache\"><a href=\"#Push-Cache\" class=\"headerlink\" title=\"Push Cache\"></a>Push Cache</h3><p>push cache（推送缓存）是比较新颖的东西，属于HTTP/2，当前面几种缓存没有命中的时候，才会询问推送缓存。</p>\n<p>具体的可以查看Jake Archibald大神的<a href=\"https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/\" target=\"_blank\" rel=\"noopener\">HTTP/2 push is tougher than I thought</a></p>\n<p>文章中有部分结论：</p>\n<ul>\n<li>Push Cache 是缓存的最后一道防线。浏览器只有在 前面说到的几种缓存均未命中的情况下才会去询问 Push Cache；</li>\n<li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放；</li>\n<li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache；</li>\n<li>Push Cache 中的缓存只能被使用一次</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>浏览器的缓存知识博大精深，就算不断在工作中和学习中实践，也只能说理解皮毛。而理解浏览器缓存，也仅仅是我们对页面性能优化的第一步，还有更多的操作等着我们。</p>"},{"title":"致敬英雄，主流网站置灰的探索","_content":"\n2020年4月4号，清明节，全国下降半旗，北京时间十点整，全国默哀3分钟，停止一切娱乐性活动，致敬为国、为民而逝世的英雄。\n\n国内的很多主流网站，为致敬英雄将网站全站置灰。如：\n\n<!-- more -->\n\n![爱奇艺](/images/致敬英雄iqiyi.png)\n\n![b站](/images/致敬英雄bilibili.png)\n\n这种置灰包括了图片、按钮、文字等，那是怎样实现的呢？\n\n一种思路是通过对每个元素都加上统一的样式，但是这种成本太高，而且要做到没有遗漏，是一件比较费精力的事情。\n\n另一种思路是通过主题样式设置，即设置为灰色主题，但是我们知道，主题样式会有对应的配色设计，像这种置灰是单一的，直接全体置灰，没有一些配色显示突出的设计。\n\n上面两种方案是可以实现的，只是不符合我们程序猿简洁、高效的理念。\n\n那有没有一种方案，靠一个属性，一个方法直接设置，就能对全站起到这样一个效果呢？如果有的话，毫无疑问这种方案是最省时省力的。\n\n带着这种疑问，我们利用开发者工具，看了几个主流网站的代码，貌似还真的有一个属性可以实现我们的想法\n\n```css\n// b站\nhtml.gray {\n    -webkit-filter: grayscale(.95);\n}\n\n// CSDN博客\nhtml {\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: grayscale(100%);\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n```\n\n把这些个样式勾选掉，网站果然就恢复了原来的配色，看来这种置灰操作，确实可以由属性来操控，而且跟`filter`属性脱不了干系。\n\n搜下[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter)，可以看到对`filter`的解释：\n\n> CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。\n\n也就是说，这个属性可以用来做滤镜操作。\n\n这里展示一下所有属性设置的代码，建议前往[官网](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter)查看更详细的操作和解释\n\n```css\n/* URL to SVG filter */\nfilter: url(\"filters.svg#filter-id\");\n\n/* <filter-function> values */\nfilter: blur(5px);\nfilter: brightness(0.4);\nfilter: contrast(200%);\nfilter: drop-shadow(16px 16px 20px blue);\nfilter: grayscale(50%);\nfilter: hue-rotate(90deg);\nfilter: invert(75%);\nfilter: opacity(25%);\nfilter: saturate(30%);\nfilter: sepia(60%);\n\n/* Multiple filters */\nfilter: contrast(175%) brightness(3%);\n\n/* Global values */\nfilter: inherit;\nfilter: initial;\nfilter: unset;\n```\n\n这里再引用官方的一个例子，设置高斯模糊\n\n```css\nfilter: blur(radius)\n```\n\n给图像设置高斯模糊。radius 一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；如果没有设定值，则默认是 0；这个参数可设置绝对像素值，但不接受百分比值。效果如下：\n\n![高斯模糊效果](/images/高斯模糊.png)\n\n再看看我们置灰用到的`grayscale`，它表示将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。\n\n这样其实我们通过设置值来确定灰度的比例，就可以实现置灰的效果，而想要全栈置灰，则将该样式添加到`html`元素上。\n\n为了更好的兼容性，可以加上各主流浏览器的私有前缀，即CSDN的写法\n\n```css\nhtml {\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: grayscale(100%);\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n```\n\n灰色给了一种很浓的沉重感，昨天的心情也确实很沉重。\n\n最后，愿英魂安息，山河无恙，人间皆安。\n\n","source":"_posts/致敬英雄，主流网站置灰的探索.md","raw":"---\ntitle: 致敬英雄，主流网站置灰的探索\ncategories:\n - 前端\ntags:\n - CSS\n\n---\n\n2020年4月4号，清明节，全国下降半旗，北京时间十点整，全国默哀3分钟，停止一切娱乐性活动，致敬为国、为民而逝世的英雄。\n\n国内的很多主流网站，为致敬英雄将网站全站置灰。如：\n\n<!-- more -->\n\n![爱奇艺](/images/致敬英雄iqiyi.png)\n\n![b站](/images/致敬英雄bilibili.png)\n\n这种置灰包括了图片、按钮、文字等，那是怎样实现的呢？\n\n一种思路是通过对每个元素都加上统一的样式，但是这种成本太高，而且要做到没有遗漏，是一件比较费精力的事情。\n\n另一种思路是通过主题样式设置，即设置为灰色主题，但是我们知道，主题样式会有对应的配色设计，像这种置灰是单一的，直接全体置灰，没有一些配色显示突出的设计。\n\n上面两种方案是可以实现的，只是不符合我们程序猿简洁、高效的理念。\n\n那有没有一种方案，靠一个属性，一个方法直接设置，就能对全站起到这样一个效果呢？如果有的话，毫无疑问这种方案是最省时省力的。\n\n带着这种疑问，我们利用开发者工具，看了几个主流网站的代码，貌似还真的有一个属性可以实现我们的想法\n\n```css\n// b站\nhtml.gray {\n    -webkit-filter: grayscale(.95);\n}\n\n// CSDN博客\nhtml {\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: grayscale(100%);\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n```\n\n把这些个样式勾选掉，网站果然就恢复了原来的配色，看来这种置灰操作，确实可以由属性来操控，而且跟`filter`属性脱不了干系。\n\n搜下[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter)，可以看到对`filter`的解释：\n\n> CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。\n\n也就是说，这个属性可以用来做滤镜操作。\n\n这里展示一下所有属性设置的代码，建议前往[官网](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter)查看更详细的操作和解释\n\n```css\n/* URL to SVG filter */\nfilter: url(\"filters.svg#filter-id\");\n\n/* <filter-function> values */\nfilter: blur(5px);\nfilter: brightness(0.4);\nfilter: contrast(200%);\nfilter: drop-shadow(16px 16px 20px blue);\nfilter: grayscale(50%);\nfilter: hue-rotate(90deg);\nfilter: invert(75%);\nfilter: opacity(25%);\nfilter: saturate(30%);\nfilter: sepia(60%);\n\n/* Multiple filters */\nfilter: contrast(175%) brightness(3%);\n\n/* Global values */\nfilter: inherit;\nfilter: initial;\nfilter: unset;\n```\n\n这里再引用官方的一个例子，设置高斯模糊\n\n```css\nfilter: blur(radius)\n```\n\n给图像设置高斯模糊。radius 一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；如果没有设定值，则默认是 0；这个参数可设置绝对像素值，但不接受百分比值。效果如下：\n\n![高斯模糊效果](/images/高斯模糊.png)\n\n再看看我们置灰用到的`grayscale`，它表示将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。\n\n这样其实我们通过设置值来确定灰度的比例，就可以实现置灰的效果，而想要全栈置灰，则将该样式添加到`html`元素上。\n\n为了更好的兼容性，可以加上各主流浏览器的私有前缀，即CSDN的写法\n\n```css\nhtml {\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: grayscale(100%);\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n```\n\n灰色给了一种很浓的沉重感，昨天的心情也确实很沉重。\n\n最后，愿英魂安息，山河无恙，人间皆安。\n\n","slug":"致敬英雄，主流网站置灰的探索","published":1,"date":"2020-04-05T14:20:47.115Z","updated":"2020-04-06T13:52:51.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4mg001whsuhk3rfnmt3","content":"<p>2020年4月4号，清明节，全国下降半旗，北京时间十点整，全国默哀3分钟，停止一切娱乐性活动，致敬为国、为民而逝世的英雄。</p>\n<p>国内的很多主流网站，为致敬英雄将网站全站置灰。如：</p>\n<a id=\"more\"></a>\n\n<p><img src=\"/images/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84iqiyi.png\" alt=\"爱奇艺\"></p>\n<p><img src=\"/images/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84bilibili.png\" alt=\"b站\"></p>\n<p>这种置灰包括了图片、按钮、文字等，那是怎样实现的呢？</p>\n<p>一种思路是通过对每个元素都加上统一的样式，但是这种成本太高，而且要做到没有遗漏，是一件比较费精力的事情。</p>\n<p>另一种思路是通过主题样式设置，即设置为灰色主题，但是我们知道，主题样式会有对应的配色设计，像这种置灰是单一的，直接全体置灰，没有一些配色显示突出的设计。</p>\n<p>上面两种方案是可以实现的，只是不符合我们程序猿简洁、高效的理念。</p>\n<p>那有没有一种方案，靠一个属性，一个方法直接设置，就能对全站起到这样一个效果呢？如果有的话，毫无疑问这种方案是最省时省力的。</p>\n<p>带着这种疑问，我们利用开发者工具，看了几个主流网站的代码，貌似还真的有一个属性可以实现我们的想法</p>\n<figure class=\"highlight css hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b站</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">html</span><span class=\"hljs-selector-class\">.gray</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-webkit-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(.95);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// CSDN博客</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">html</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-webkit-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-moz-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-ms-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-o-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">filter</span>: progid:DXImageTransform.Microsoft.<span class=\"hljs-built_in\">BasicImage</span>(grayscale=1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这些个样式勾选掉，网站果然就恢复了原来的配色，看来这种置灰操作，确实可以由属性来操控，而且跟<code>filter</code>属性脱不了干系。</p>\n<p>搜下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter\" target=\"_blank\" rel=\"noopener\">MDN</a>，可以看到对<code>filter</code>的解释：</p>\n<blockquote>\n<p>CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>\n</blockquote>\n<p>也就是说，这个属性可以用来做滤镜操作。</p>\n<p>这里展示一下所有属性设置的代码，建议前往<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter\" target=\"_blank\" rel=\"noopener\">官网</a>查看更详细的操作和解释</p>\n<figure class=\"highlight css hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/* URL to SVG filter */</span></span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">url</span>(\"<span class=\"hljs-selector-tag\">filters</span><span class=\"hljs-selector-class\">.svg</span><span class=\"hljs-selector-id\">#filter-id</span>\");</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/* &lt;filter-function&gt; values */</span></span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">blur</span>(5<span class=\"hljs-selector-tag\">px</span>);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">brightness</span>(0<span class=\"hljs-selector-class\">.4</span>);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">contrast</span>(200%);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">drop-shadow</span>(16<span class=\"hljs-selector-tag\">px</span> 16<span class=\"hljs-selector-tag\">px</span> 20<span class=\"hljs-selector-tag\">px</span> <span class=\"hljs-selector-tag\">blue</span>);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">grayscale</span>(50%);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">hue-rotate</span>(90<span class=\"hljs-selector-tag\">deg</span>);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">invert</span>(75%);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">opacity</span>(25%);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">saturate</span>(30%);</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">sepia</span>(60%);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/* Multiple filters */</span></span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">contrast</span>(175%) <span class=\"hljs-selector-tag\">brightness</span>(3%);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/* Global values */</span></span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">inherit</span>;</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">initial</span>;</span><br><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">unset</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里再引用官方的一个例子，设置高斯模糊</p>\n<figure class=\"highlight css hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-selector-tag\">filter</span>: <span class=\"hljs-selector-tag\">blur</span>(<span class=\"hljs-selector-tag\">radius</span>)</span><br></pre></td></tr></table></figure>\n\n<p>给图像设置高斯模糊。radius 一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；如果没有设定值，则默认是 0；这个参数可设置绝对像素值，但不接受百分比值。效果如下：</p>\n<p><img src=\"/images/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A.png\" alt=\"高斯模糊效果\"></p>\n<p>再看看我们置灰用到的<code>grayscale</code>，它表示将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。</p>\n<p>这样其实我们通过设置值来确定灰度的比例，就可以实现置灰的效果，而想要全栈置灰，则将该样式添加到<code>html</code>元素上。</p>\n<p>为了更好的兼容性，可以加上各主流浏览器的私有前缀，即CSDN的写法</p>\n<figure class=\"highlight css hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-selector-tag\">html</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-webkit-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-moz-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-ms-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">-o-filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">filter</span>: <span class=\"hljs-built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"hljs-attribute\">filter</span>: progid:DXImageTransform.Microsoft.<span class=\"hljs-built_in\">BasicImage</span>(grayscale=1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>灰色给了一种很浓的沉重感，昨天的心情也确实很沉重。</p>\n<p>最后，愿英魂安息，山河无恙，人间皆安。</p>\n","site":{"data":{}},"excerpt":"<p>2020年4月4号，清明节，全国下降半旗，北京时间十点整，全国默哀3分钟，停止一切娱乐性活动，致敬为国、为民而逝世的英雄。</p>\n<p>国内的很多主流网站，为致敬英雄将网站全站置灰。如：</p>","more":"<p><img src=\"/images/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84iqiyi.png\" alt=\"爱奇艺\"></p>\n<p><img src=\"/images/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84bilibili.png\" alt=\"b站\"></p>\n<p>这种置灰包括了图片、按钮、文字等，那是怎样实现的呢？</p>\n<p>一种思路是通过对每个元素都加上统一的样式，但是这种成本太高，而且要做到没有遗漏，是一件比较费精力的事情。</p>\n<p>另一种思路是通过主题样式设置，即设置为灰色主题，但是我们知道，主题样式会有对应的配色设计，像这种置灰是单一的，直接全体置灰，没有一些配色显示突出的设计。</p>\n<p>上面两种方案是可以实现的，只是不符合我们程序猿简洁、高效的理念。</p>\n<p>那有没有一种方案，靠一个属性，一个方法直接设置，就能对全站起到这样一个效果呢？如果有的话，毫无疑问这种方案是最省时省力的。</p>\n<p>带着这种疑问，我们利用开发者工具，看了几个主流网站的代码，貌似还真的有一个属性可以实现我们的想法</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b站</span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-class\">.gray</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">grayscale</span>(.95);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// CSDN博客</span><br><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">-moz-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">-ms-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">-o-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: progid:DXImageTransform.Microsoft.<span class=\"built_in\">BasicImage</span>(grayscale=1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把这些个样式勾选掉，网站果然就恢复了原来的配色，看来这种置灰操作，确实可以由属性来操控，而且跟<code>filter</code>属性脱不了干系。</p>\n<p>搜下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter\" target=\"_blank\" rel=\"noopener\">MDN</a>，可以看到对<code>filter</code>的解释：</p>\n<blockquote>\n<p>CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>\n</blockquote>\n<p>也就是说，这个属性可以用来做滤镜操作。</p>\n<p>这里展示一下所有属性设置的代码，建议前往<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter\" target=\"_blank\" rel=\"noopener\">官网</a>查看更详细的操作和解释</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* URL to SVG filter */</span></span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">url</span>(\"<span class=\"selector-tag\">filters</span><span class=\"selector-class\">.svg</span><span class=\"selector-id\">#filter-id</span>\");</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* &lt;filter-function&gt; values */</span></span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">blur</span>(5<span class=\"selector-tag\">px</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">brightness</span>(0<span class=\"selector-class\">.4</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">contrast</span>(200%);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">drop-shadow</span>(16<span class=\"selector-tag\">px</span> 16<span class=\"selector-tag\">px</span> 20<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">blue</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">grayscale</span>(50%);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">hue-rotate</span>(90<span class=\"selector-tag\">deg</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">invert</span>(75%);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">opacity</span>(25%);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">saturate</span>(30%);</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">sepia</span>(60%);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Multiple filters */</span></span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">contrast</span>(175%) <span class=\"selector-tag\">brightness</span>(3%);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Global values */</span></span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">inherit</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">initial</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">unset</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里再引用官方的一个例子，设置高斯模糊</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">filter</span>: <span class=\"selector-tag\">blur</span>(<span class=\"selector-tag\">radius</span>)</span><br></pre></td></tr></table></figure>\n\n<p>给图像设置高斯模糊。radius 一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；如果没有设定值，则默认是 0；这个参数可设置绝对像素值，但不接受百分比值。效果如下：</p>\n<p><img src=\"/images/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A.png\" alt=\"高斯模糊效果\"></p>\n<p>再看看我们置灰用到的<code>grayscale</code>，它表示将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。</p>\n<p>这样其实我们通过设置值来确定灰度的比例，就可以实现置灰的效果，而想要全栈置灰，则将该样式添加到<code>html</code>元素上。</p>\n<p>为了更好的兼容性，可以加上各主流浏览器的私有前缀，即CSDN的写法</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">-moz-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">-ms-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">-o-filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: <span class=\"built_in\">grayscale</span>(100%);</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: progid:DXImageTransform.Microsoft.<span class=\"built_in\">BasicImage</span>(grayscale=1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>灰色给了一种很浓的沉重感，昨天的心情也确实很沉重。</p>\n<p>最后，愿英魂安息，山河无恙，人间皆安。</p>"},{"title":"风一吹不回来","_content":"\n前几天和一个大学朋友聊起近况，他也是潮汕人，也喜欢喝茶，也喜欢看动漫，我们有很多共同的话题可以聊，当然最后话题还是回到了工作当中，我们感叹工作的压力，感慨毕业后经历的酸甜苦辣，然后不约而同地怀念起那段大学时光：一起上下课，在宿舍一起喝茶，周末还能早起在宿舍楼下打羽毛球。。。\n\n是的，人总会怀念从前的时光，而被我们怀念的那段时光里的我们，却在忙于感慨其它事情，就像未来的某个时间里，我会怀念和感慨现在。人就是一个矛盾体，经常不懂得珍惜眼前的风景，然后又揣着患得患失的怀念继续走下去。\n\n<!-- more -->\n\n“听过许多大道理，依旧过不好这一生”，懂得很多道理，但是依旧处于矛盾、迷茫之中，这或许是人的本质，人非圣贤孰能无过，人就是人，人非神，非仙，自然没有完美一说。如果世上存在一个完美的人，那么他应该很孤独，很悲凉吧，处于世而离于世， 眼光所到之处，皆为荒凉，身处世界之巅，而不胜寒。\n\n还讨论，如果可以回到过去，回到我们怀念的时光， 把每一刻都过到理想中的样子 ，那么我们还会像现在一样去怀念从前吗？显然不会。错过的就是错过，失去的就是失去，因为遗憾，我们才会铭记，当我们每段经历都过得很自然很平淡的时候，我们还会铭刻于心，去怀念吗？\n\n感想了那么多，最后，我还是愿揣着怀念，珍惜当下，一步一脚印地赏完春夏秋冬。","source":"_posts/风一吹不回来.md","raw":"---\ntitle: 风一吹不回来\ncategories:\n - 生活\ntags:\n - 感想\n---\n\n前几天和一个大学朋友聊起近况，他也是潮汕人，也喜欢喝茶，也喜欢看动漫，我们有很多共同的话题可以聊，当然最后话题还是回到了工作当中，我们感叹工作的压力，感慨毕业后经历的酸甜苦辣，然后不约而同地怀念起那段大学时光：一起上下课，在宿舍一起喝茶，周末还能早起在宿舍楼下打羽毛球。。。\n\n是的，人总会怀念从前的时光，而被我们怀念的那段时光里的我们，却在忙于感慨其它事情，就像未来的某个时间里，我会怀念和感慨现在。人就是一个矛盾体，经常不懂得珍惜眼前的风景，然后又揣着患得患失的怀念继续走下去。\n\n<!-- more -->\n\n“听过许多大道理，依旧过不好这一生”，懂得很多道理，但是依旧处于矛盾、迷茫之中，这或许是人的本质，人非圣贤孰能无过，人就是人，人非神，非仙，自然没有完美一说。如果世上存在一个完美的人，那么他应该很孤独，很悲凉吧，处于世而离于世， 眼光所到之处，皆为荒凉，身处世界之巅，而不胜寒。\n\n还讨论，如果可以回到过去，回到我们怀念的时光， 把每一刻都过到理想中的样子 ，那么我们还会像现在一样去怀念从前吗？显然不会。错过的就是错过，失去的就是失去，因为遗憾，我们才会铭记，当我们每段经历都过得很自然很平淡的时候，我们还会铭刻于心，去怀念吗？\n\n感想了那么多，最后，我还是愿揣着怀念，珍惜当下，一步一脚印地赏完春夏秋冬。","slug":"风一吹不回来","published":1,"date":"2019-11-06T16:08:31.459Z","updated":"2019-11-06T16:10:22.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4mj0020hsuhlmaq8v3s","content":"<p>前几天和一个大学朋友聊起近况，他也是潮汕人，也喜欢喝茶，也喜欢看动漫，我们有很多共同的话题可以聊，当然最后话题还是回到了工作当中，我们感叹工作的压力，感慨毕业后经历的酸甜苦辣，然后不约而同地怀念起那段大学时光：一起上下课，在宿舍一起喝茶，周末还能早起在宿舍楼下打羽毛球。。。</p>\n<p>是的，人总会怀念从前的时光，而被我们怀念的那段时光里的我们，却在忙于感慨其它事情，就像未来的某个时间里，我会怀念和感慨现在。人就是一个矛盾体，经常不懂得珍惜眼前的风景，然后又揣着患得患失的怀念继续走下去。</p>\n<a id=\"more\"></a>\n\n<p>“听过许多大道理，依旧过不好这一生”，懂得很多道理，但是依旧处于矛盾、迷茫之中，这或许是人的本质，人非圣贤孰能无过，人就是人，人非神，非仙，自然没有完美一说。如果世上存在一个完美的人，那么他应该很孤独，很悲凉吧，处于世而离于世， 眼光所到之处，皆为荒凉，身处世界之巅，而不胜寒。</p>\n<p>还讨论，如果可以回到过去，回到我们怀念的时光， 把每一刻都过到理想中的样子 ，那么我们还会像现在一样去怀念从前吗？显然不会。错过的就是错过，失去的就是失去，因为遗憾，我们才会铭记，当我们每段经历都过得很自然很平淡的时候，我们还会铭刻于心，去怀念吗？</p>\n<p>感想了那么多，最后，我还是愿揣着怀念，珍惜当下，一步一脚印地赏完春夏秋冬。</p>\n","site":{"data":{}},"excerpt":"<p>前几天和一个大学朋友聊起近况，他也是潮汕人，也喜欢喝茶，也喜欢看动漫，我们有很多共同的话题可以聊，当然最后话题还是回到了工作当中，我们感叹工作的压力，感慨毕业后经历的酸甜苦辣，然后不约而同地怀念起那段大学时光：一起上下课，在宿舍一起喝茶，周末还能早起在宿舍楼下打羽毛球。。。</p>\n<p>是的，人总会怀念从前的时光，而被我们怀念的那段时光里的我们，却在忙于感慨其它事情，就像未来的某个时间里，我会怀念和感慨现在。人就是一个矛盾体，经常不懂得珍惜眼前的风景，然后又揣着患得患失的怀念继续走下去。</p>","more":"<p>“听过许多大道理，依旧过不好这一生”，懂得很多道理，但是依旧处于矛盾、迷茫之中，这或许是人的本质，人非圣贤孰能无过，人就是人，人非神，非仙，自然没有完美一说。如果世上存在一个完美的人，那么他应该很孤独，很悲凉吧，处于世而离于世， 眼光所到之处，皆为荒凉，身处世界之巅，而不胜寒。</p>\n<p>还讨论，如果可以回到过去，回到我们怀念的时光， 把每一刻都过到理想中的样子 ，那么我们还会像现在一样去怀念从前吗？显然不会。错过的就是错过，失去的就是失去，因为遗憾，我们才会铭记，当我们每段经历都过得很自然很平淡的时候，我们还会铭刻于心，去怀念吗？</p>\n<p>感想了那么多，最后，我还是愿揣着怀念，珍惜当下，一步一脚印地赏完春夏秋冬。</p>"},{"title":"ES6 -- Proxy","_content":"\n### 前言\n\n本文总结了`Proxy`代理的陷阱函数和对应的`Reflect`接口默认行为函数的用法。因为目前用的最多的技术栈是`Vue`，而`Vue3.0`版本其中关于响应式原理的核心是`Proxy`，因此有必要对`Proxy`做进一步的理解和总结。\n\n### set\n\n拦截对象：设置属性值行为。成功返回`true`，失败返回`false`。\n\n默认行为实现：`Reflect.set()`\n\n<!-- more -->\n\n接收参数：\n\n1. **trapTarget**：设置属性的对象（代理的目标对象）\n2. **key**：属性的键\n3. **value**：属性的值\n4. **receiver**：操作发生的对象（通常指代理对象）\n\n### get\n\n拦截对象：获取属性值行为。\n\n默认行为实现：`Reflect.get()`\n\n接收参数：\n\n1. **trapTarget**：获取属性的对象（代理的目标对象）\n2. **key**：属性的键\n3. **receiver**：操作发生的对象（通常指代理对象）\n\n骚操作：属性不存在时可明确抛出错误，而不是返回`undefined`\n\n```javascript\nlet target = {}\nlet proxyTar = new Proxy(target, {\n    get (trapTarget, key, receiver) {\n        if (!(key in receiver)) {\n            throw new TypeError(`property ${key} is not exist`)\n        }\n        return Reflect.get(trapTarget, key, receiver)\n    }\n})\n```\n\n\n\n### has\n\n拦截对象：`in`操作符。成功返回`true`，失败返回`false`。\n\n默认行为实现：`Reflect.has()`\n\n接收参数：\n\n1. **trapTarget**：读取属性的对象\n2. **key**：需要检查的属性的键\n\n骚操作：通过返回`false`，隐藏属性\n\n```javascript\nlet target = {\n    name: '小叮当',\n    _age: 18\n}\nlet proxyTar = new Proxy(target, {\n    has (trapTarget, key) {\n        // 隐藏_age属性\n        if (key === '_age') {\n            return false\n        }\n        return Reflect.has(trapTarget, key)\n    }\n})\n```\n\n\n\n### deleteProperty\n\n拦截对象：`delete`操作符。成功返回`true`，失败返回`false`。\n\n默认行为实现：`Reflect.deleteProperty()`\n\n接收参数：\n\n1. **trapTarget**：删除属性的对象\n2. **key**：需要删除的属性的键\n\n骚操作：通过返回`false`，设置属性不可删除\n\n```javascript\nlet target = {\n    name: '小叮当',\n    age: 18,\n    idCard: '75423546574xxx'\n}\nlet proxyTar = new Proxy(target, {\n    deleteProperty (trapTarget, key) {\n        // idCard属性不可删除\n        if (key === 'idCard') {\n            return false\n        }\n        return Reflect.deleteProperty(trapTarget, key)\n    }\n})\n```\n\n\n\n### getPrototypeOf\n\n拦截对象：`Object.getPrototypeOf()`。返回值必须是一个对象或者是`null`，其它类型返回值会引发错误。\n\n默认行为实现：`Reflect.getPrototypeOf()`\n\n接收参数：\n\n1. **trapTarget**：需要获取原型的对象\n\n骚操作：可通过返回`null`来隐藏对象原型\n\n### setPrototypeOf\n\n拦截对象：`Object.setPrototypeOf()`。操作不成功时应返回`false`以让`Object.setPrototypeOf()`抛出错误，若返回不为`false`，则认为操作成功。\n\n默认行为实现：`Reflect.setPrototypeOf()`\n\n接受参数：\n\n1. **trapTarget**：需要设置原型的对象\n2. **proto**：被用作原型的对象\n\n骚操作：可通过返回`false`使对象原型不可被设置\n\n**为何存在`Reflect.getPrototypeOf()`、`Reflect.setPrototypeOf()`与`Object.getPrototypeOf()`、`Object.setPrototypeOf()`两组方法？**\n\n两组方法作用虽然相似，但还是存在一些比较显著的差别：\n\n1. 前者属于JS引擎底层操作，后者属于高级操作；\n2. `Reflect.getPrototypeOf()`接收的参数不是对象时会抛出错误；而`Object.getPrototypeOf()`操作前会先将参数转换为对象；\n3. `Reflect.setPrototypeOf()`会返回布尔值`true`或`false`表示成功或失败，`Object.setPrototypeOf()`操作失败时会报错，成功时会将第一个参数作为返回值；\n\n因此，Object两个原型操作方法并不适合用来实现代理陷阱的默认行为。\n\n### 对象可扩展性的陷阱函数\n\n### preventExtensions\n\n拦截对象：`Object.preventExtensions()`。返回`true`或`false`表示操作成功或失败。\n\n默认行为实现：`Reflect.preventExtensions()`。\n\n接收参数：\n\n1. **trapTarget**：设置不可扩展的对象\n\n### isExtensible\n\n拦截对象：`Object.isExtensible()`。返回`true`或`false`表示操作成功或失败。\n\n默认行为实现：`Reflect.isExtensible()`。\n\n接收参数：\n\n1. **trapTarget**：设置可扩展的对象\n\n**为何存在`Reflect.preventExtensions()`、`Reflect.isExtensible()`与`Object.preventExtensions()`、`Object.isExtensible()`两组方法？**\n\n两组方法几乎一致，但有一些差别：\n\n1. 接收的参数不为对象时，`Object.isExtensible()`是返回`false`，而`Reflect.isExtensible()`会抛出错误；\n2. `Object.preventExtensions()`不管参数是否是对象，都会将参数值作为自身返回值，而`Reflect.preventExtensions() `方法则会在参数不是对象时抛出错误，在参数为对象时返回`true`或`false`表示操作成功或失败；\n3. 底层功能的方法与对应的高层方法相比，会进行更为严格的校验；\n\n### 属性描述符的陷阱函数\n\n### definedProperty\n\n拦截对象：`Object.defineProperty()`，返回`true`或`false`表示操作成功或失败。\n\n默认行为实现：`Reflect.defineProperty()`。\n\n接收参数：\n\n1. **tarpTarget**：被定义属性的对象\n2. **key**：属性的键\n3. **descriptor**：为该属性准备的描述符对象\n\n骚操作：可通过主动返回`false`让`Object.defineProperty()`抛出错误失败，也可通过返回`true`而不调用`Reflect.defineProperty()`来让`Object.defineProperty()`静默失败。\n\n### getOwnPropertyDescriptor\n\n拦截对象：`Object.getOwnPropertyDescriptor()`，返回对应的描述符。\n\n默认行为实现：`Reflect.getOwnPropertyDescriptor()`。\n\n接收参数：\n\n1. **tarpTarget**：被检索属性的对象\n2. **key**：属性的键\n\n**为何存在`Reflect.defineProperty()`、`Reflect.getOwnPropertyDescriptor()`与`Object.defineProperty()`、`Object.getOwnPropertyDescriptor()`两组方法？**\n\n两组方法几乎一致，但也有一些差别：\n\n1. `Object.defineProperty()`返回第一个参数值，而`Reflect.defineProperty()`返回`true`或`false`;\n2. 第一个参数不是对象时，`Object.getOwnPropertyDescriptor()`会将第一个参数转为对象，而`Reflect.getOwnPropertyDescriptor()`会抛出错误；\n\n### ownKeys\n\n拦截对象：内部方法`[[OwnPropertyKeys]]`，返回一个数组重写该行为。数组被用于四个方法：`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Object.assign()`，也能影响到`for-in`循环。不是返回数组或类数组对象，会抛出错误。\n\n默认行为实现：`Reflect.ownKeys()`，返回一个由全部自有属性的键构成的数组，无论键的类型是**字符串**还是**符号**。\n\n接收参数：\n\n1. **trapTarget**：获取属性的目标对象\n\n骚操作：可通过设置，不返回比如拥有下划线的属性（一般被定义为私有属性）\n\n```javascript\nlet target = {\n    name: 'target',\n    _name: 'private_target' // 私有属性\n}\nlet proxyTarget = new Proxy(target, {\n    ownKeys (trapTarget) {\n        return Reflect.ownKeys(trapTarget).filter(key => {\n            // 可返回符号类型、字符类型且不包含下划线的属性\n            return typeOf key !== 'string' || key[0] !== '_'\n        })\n    }\n})\n```\n\n\n\n### apply和construct\n\n拦截对象：内部方法`[[Call]]`和`[[Construct]]`，前者会在函数被直接调用时执行，而后者会在函数被使用`new`运算符调用时执行。\n\napply陷阱函数(`Reflect.apply()`同样)接收参数：\n\n1. **trapTarget** ：被执行的函数（即代理的目标对象）；\n2. **thisArg** ：调用过程中函数内部的 this 值；\n3. **argumentsList** ：被传递给函数的参数数组。\n\nconstruct陷阱函数接收参数：\n\n1. **trapTarget** ：被执行的函数（即代理的目标对象）；\n2. **argumentsList** ：被传递给函数的参数数组。\n\n`Reflect.construct()`除了上述两个参数，还有第三个可选参数`newTarget`，此参数指定了函数内部`new.target`的值。\n\n骚操作：可以验证函数的类型；还可以不使用`new`来调用构造器；还可以限制函数只能通过`new`来调用等等。。。\n\n### 撤销代理\n\n一般代理创建之后不会被解绑，如果想要创建一个可被撤销的代理，可通过`Proxy.revocable()`方法，该方法跟`Proxy`构造器一样接收两个参数：\n\n1. **trapTarget**：被代理的目标对象\n2. **handler**：代理处理器\n\n然后会返回一个包含以下属性的对象：\n\n1. **proxy**：可被撤销的代理对象\n2. **revoke**：用于撤销代理的函数\n\n通过调用`revoke()`，就无法再对`proxy`进行更多的操作，任何跟`proxy`的交互都会触发陷阱函数，从而抛出错误。\n\n","source":"_posts/ES6----Proxy.md","raw":"---\n\ntitle: ES6 -- Proxy\ncategories:\n - 前端\ntags:\n - 总结\n---\n\n### 前言\n\n本文总结了`Proxy`代理的陷阱函数和对应的`Reflect`接口默认行为函数的用法。因为目前用的最多的技术栈是`Vue`，而`Vue3.0`版本其中关于响应式原理的核心是`Proxy`，因此有必要对`Proxy`做进一步的理解和总结。\n\n### set\n\n拦截对象：设置属性值行为。成功返回`true`，失败返回`false`。\n\n默认行为实现：`Reflect.set()`\n\n<!-- more -->\n\n接收参数：\n\n1. **trapTarget**：设置属性的对象（代理的目标对象）\n2. **key**：属性的键\n3. **value**：属性的值\n4. **receiver**：操作发生的对象（通常指代理对象）\n\n### get\n\n拦截对象：获取属性值行为。\n\n默认行为实现：`Reflect.get()`\n\n接收参数：\n\n1. **trapTarget**：获取属性的对象（代理的目标对象）\n2. **key**：属性的键\n3. **receiver**：操作发生的对象（通常指代理对象）\n\n骚操作：属性不存在时可明确抛出错误，而不是返回`undefined`\n\n```javascript\nlet target = {}\nlet proxyTar = new Proxy(target, {\n    get (trapTarget, key, receiver) {\n        if (!(key in receiver)) {\n            throw new TypeError(`property ${key} is not exist`)\n        }\n        return Reflect.get(trapTarget, key, receiver)\n    }\n})\n```\n\n\n\n### has\n\n拦截对象：`in`操作符。成功返回`true`，失败返回`false`。\n\n默认行为实现：`Reflect.has()`\n\n接收参数：\n\n1. **trapTarget**：读取属性的对象\n2. **key**：需要检查的属性的键\n\n骚操作：通过返回`false`，隐藏属性\n\n```javascript\nlet target = {\n    name: '小叮当',\n    _age: 18\n}\nlet proxyTar = new Proxy(target, {\n    has (trapTarget, key) {\n        // 隐藏_age属性\n        if (key === '_age') {\n            return false\n        }\n        return Reflect.has(trapTarget, key)\n    }\n})\n```\n\n\n\n### deleteProperty\n\n拦截对象：`delete`操作符。成功返回`true`，失败返回`false`。\n\n默认行为实现：`Reflect.deleteProperty()`\n\n接收参数：\n\n1. **trapTarget**：删除属性的对象\n2. **key**：需要删除的属性的键\n\n骚操作：通过返回`false`，设置属性不可删除\n\n```javascript\nlet target = {\n    name: '小叮当',\n    age: 18,\n    idCard: '75423546574xxx'\n}\nlet proxyTar = new Proxy(target, {\n    deleteProperty (trapTarget, key) {\n        // idCard属性不可删除\n        if (key === 'idCard') {\n            return false\n        }\n        return Reflect.deleteProperty(trapTarget, key)\n    }\n})\n```\n\n\n\n### getPrototypeOf\n\n拦截对象：`Object.getPrototypeOf()`。返回值必须是一个对象或者是`null`，其它类型返回值会引发错误。\n\n默认行为实现：`Reflect.getPrototypeOf()`\n\n接收参数：\n\n1. **trapTarget**：需要获取原型的对象\n\n骚操作：可通过返回`null`来隐藏对象原型\n\n### setPrototypeOf\n\n拦截对象：`Object.setPrototypeOf()`。操作不成功时应返回`false`以让`Object.setPrototypeOf()`抛出错误，若返回不为`false`，则认为操作成功。\n\n默认行为实现：`Reflect.setPrototypeOf()`\n\n接受参数：\n\n1. **trapTarget**：需要设置原型的对象\n2. **proto**：被用作原型的对象\n\n骚操作：可通过返回`false`使对象原型不可被设置\n\n**为何存在`Reflect.getPrototypeOf()`、`Reflect.setPrototypeOf()`与`Object.getPrototypeOf()`、`Object.setPrototypeOf()`两组方法？**\n\n两组方法作用虽然相似，但还是存在一些比较显著的差别：\n\n1. 前者属于JS引擎底层操作，后者属于高级操作；\n2. `Reflect.getPrototypeOf()`接收的参数不是对象时会抛出错误；而`Object.getPrototypeOf()`操作前会先将参数转换为对象；\n3. `Reflect.setPrototypeOf()`会返回布尔值`true`或`false`表示成功或失败，`Object.setPrototypeOf()`操作失败时会报错，成功时会将第一个参数作为返回值；\n\n因此，Object两个原型操作方法并不适合用来实现代理陷阱的默认行为。\n\n### 对象可扩展性的陷阱函数\n\n### preventExtensions\n\n拦截对象：`Object.preventExtensions()`。返回`true`或`false`表示操作成功或失败。\n\n默认行为实现：`Reflect.preventExtensions()`。\n\n接收参数：\n\n1. **trapTarget**：设置不可扩展的对象\n\n### isExtensible\n\n拦截对象：`Object.isExtensible()`。返回`true`或`false`表示操作成功或失败。\n\n默认行为实现：`Reflect.isExtensible()`。\n\n接收参数：\n\n1. **trapTarget**：设置可扩展的对象\n\n**为何存在`Reflect.preventExtensions()`、`Reflect.isExtensible()`与`Object.preventExtensions()`、`Object.isExtensible()`两组方法？**\n\n两组方法几乎一致，但有一些差别：\n\n1. 接收的参数不为对象时，`Object.isExtensible()`是返回`false`，而`Reflect.isExtensible()`会抛出错误；\n2. `Object.preventExtensions()`不管参数是否是对象，都会将参数值作为自身返回值，而`Reflect.preventExtensions() `方法则会在参数不是对象时抛出错误，在参数为对象时返回`true`或`false`表示操作成功或失败；\n3. 底层功能的方法与对应的高层方法相比，会进行更为严格的校验；\n\n### 属性描述符的陷阱函数\n\n### definedProperty\n\n拦截对象：`Object.defineProperty()`，返回`true`或`false`表示操作成功或失败。\n\n默认行为实现：`Reflect.defineProperty()`。\n\n接收参数：\n\n1. **tarpTarget**：被定义属性的对象\n2. **key**：属性的键\n3. **descriptor**：为该属性准备的描述符对象\n\n骚操作：可通过主动返回`false`让`Object.defineProperty()`抛出错误失败，也可通过返回`true`而不调用`Reflect.defineProperty()`来让`Object.defineProperty()`静默失败。\n\n### getOwnPropertyDescriptor\n\n拦截对象：`Object.getOwnPropertyDescriptor()`，返回对应的描述符。\n\n默认行为实现：`Reflect.getOwnPropertyDescriptor()`。\n\n接收参数：\n\n1. **tarpTarget**：被检索属性的对象\n2. **key**：属性的键\n\n**为何存在`Reflect.defineProperty()`、`Reflect.getOwnPropertyDescriptor()`与`Object.defineProperty()`、`Object.getOwnPropertyDescriptor()`两组方法？**\n\n两组方法几乎一致，但也有一些差别：\n\n1. `Object.defineProperty()`返回第一个参数值，而`Reflect.defineProperty()`返回`true`或`false`;\n2. 第一个参数不是对象时，`Object.getOwnPropertyDescriptor()`会将第一个参数转为对象，而`Reflect.getOwnPropertyDescriptor()`会抛出错误；\n\n### ownKeys\n\n拦截对象：内部方法`[[OwnPropertyKeys]]`，返回一个数组重写该行为。数组被用于四个方法：`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Object.assign()`，也能影响到`for-in`循环。不是返回数组或类数组对象，会抛出错误。\n\n默认行为实现：`Reflect.ownKeys()`，返回一个由全部自有属性的键构成的数组，无论键的类型是**字符串**还是**符号**。\n\n接收参数：\n\n1. **trapTarget**：获取属性的目标对象\n\n骚操作：可通过设置，不返回比如拥有下划线的属性（一般被定义为私有属性）\n\n```javascript\nlet target = {\n    name: 'target',\n    _name: 'private_target' // 私有属性\n}\nlet proxyTarget = new Proxy(target, {\n    ownKeys (trapTarget) {\n        return Reflect.ownKeys(trapTarget).filter(key => {\n            // 可返回符号类型、字符类型且不包含下划线的属性\n            return typeOf key !== 'string' || key[0] !== '_'\n        })\n    }\n})\n```\n\n\n\n### apply和construct\n\n拦截对象：内部方法`[[Call]]`和`[[Construct]]`，前者会在函数被直接调用时执行，而后者会在函数被使用`new`运算符调用时执行。\n\napply陷阱函数(`Reflect.apply()`同样)接收参数：\n\n1. **trapTarget** ：被执行的函数（即代理的目标对象）；\n2. **thisArg** ：调用过程中函数内部的 this 值；\n3. **argumentsList** ：被传递给函数的参数数组。\n\nconstruct陷阱函数接收参数：\n\n1. **trapTarget** ：被执行的函数（即代理的目标对象）；\n2. **argumentsList** ：被传递给函数的参数数组。\n\n`Reflect.construct()`除了上述两个参数，还有第三个可选参数`newTarget`，此参数指定了函数内部`new.target`的值。\n\n骚操作：可以验证函数的类型；还可以不使用`new`来调用构造器；还可以限制函数只能通过`new`来调用等等。。。\n\n### 撤销代理\n\n一般代理创建之后不会被解绑，如果想要创建一个可被撤销的代理，可通过`Proxy.revocable()`方法，该方法跟`Proxy`构造器一样接收两个参数：\n\n1. **trapTarget**：被代理的目标对象\n2. **handler**：代理处理器\n\n然后会返回一个包含以下属性的对象：\n\n1. **proxy**：可被撤销的代理对象\n2. **revoke**：用于撤销代理的函数\n\n通过调用`revoke()`，就无法再对`proxy`进行更多的操作，任何跟`proxy`的交互都会触发陷阱函数，从而抛出错误。\n\n","slug":"ES6----Proxy","published":1,"date":"2020-01-01T12:51:56.617Z","updated":"2020-01-21T03:23:59.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4n1002phsuhx6r9wysy","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文总结了<code>Proxy</code>代理的陷阱函数和对应的<code>Reflect</code>接口默认行为函数的用法。因为目前用的最多的技术栈是<code>Vue</code>，而<code>Vue3.0</code>版本其中关于响应式原理的核心是<code>Proxy</code>，因此有必要对<code>Proxy</code>做进一步的理解和总结。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>拦截对象：设置属性值行为。成功返回<code>true</code>，失败返回<code>false</code>。</p>\n<p>默认行为实现：<code>Reflect.set()</code></p>\n<a id=\"more\"></a>\n\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：设置属性的对象（代理的目标对象）</li>\n<li><strong>key</strong>：属性的键</li>\n<li><strong>value</strong>：属性的值</li>\n<li><strong>receiver</strong>：操作发生的对象（通常指代理对象）</li>\n</ol>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><p>拦截对象：获取属性值行为。</p>\n<p>默认行为实现：<code>Reflect.get()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：获取属性的对象（代理的目标对象）</li>\n<li><strong>key</strong>：属性的键</li>\n<li><strong>receiver</strong>：操作发生的对象（通常指代理对象）</li>\n</ol>\n<p>骚操作：属性不存在时可明确抛出错误，而不是返回<code>undefined</code></p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> target = &#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> proxyTar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">get</span> (trapTarget, key, receiver) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (!(key <span class=\"hljs-keyword\">in</span> receiver)) &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">`property <span class=\"hljs-subst\">$&#123;key&#125;</span> is not exist`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.get(trapTarget, key, receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has\"></a>has</h3><p>拦截对象：<code>in</code>操作符。成功返回<code>true</code>，失败返回<code>false</code>。</p>\n<p>默认行为实现：<code>Reflect.has()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：读取属性的对象</li>\n<li><strong>key</strong>：需要检查的属性的键</li>\n</ol>\n<p>骚操作：通过返回<code>false</code>，隐藏属性</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> target = &#123;</span><br><span class=\"line\">    name: <span class=\"hljs-string\">'小叮当'</span>,</span><br><span class=\"line\">    _age: <span class=\"hljs-number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> proxyTar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    has (trapTarget, key) &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// 隐藏_age属性</span></span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">'_age'</span>) &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.has(trapTarget, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"deleteProperty\"><a href=\"#deleteProperty\" class=\"headerlink\" title=\"deleteProperty\"></a>deleteProperty</h3><p>拦截对象：<code>delete</code>操作符。成功返回<code>true</code>，失败返回<code>false</code>。</p>\n<p>默认行为实现：<code>Reflect.deleteProperty()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：删除属性的对象</li>\n<li><strong>key</strong>：需要删除的属性的键</li>\n</ol>\n<p>骚操作：通过返回<code>false</code>，设置属性不可删除</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> target = &#123;</span><br><span class=\"line\">    name: <span class=\"hljs-string\">'小叮当'</span>,</span><br><span class=\"line\">    age: <span class=\"hljs-number\">18</span>,</span><br><span class=\"line\">    idCard: <span class=\"hljs-string\">'75423546574xxx'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> proxyTar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    deleteProperty (trapTarget, key) &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// idCard属性不可删除</span></span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (key === <span class=\"hljs-string\">'idCard'</span>) &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.deleteProperty(trapTarget, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getPrototypeOf\"><a href=\"#getPrototypeOf\" class=\"headerlink\" title=\"getPrototypeOf\"></a>getPrototypeOf</h3><p>拦截对象：<code>Object.getPrototypeOf()</code>。返回值必须是一个对象或者是<code>null</code>，其它类型返回值会引发错误。</p>\n<p>默认行为实现：<code>Reflect.getPrototypeOf()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：需要获取原型的对象</li>\n</ol>\n<p>骚操作：可通过返回<code>null</code>来隐藏对象原型</p>\n<h3 id=\"setPrototypeOf\"><a href=\"#setPrototypeOf\" class=\"headerlink\" title=\"setPrototypeOf\"></a>setPrototypeOf</h3><p>拦截对象：<code>Object.setPrototypeOf()</code>。操作不成功时应返回<code>false</code>以让<code>Object.setPrototypeOf()</code>抛出错误，若返回不为<code>false</code>，则认为操作成功。</p>\n<p>默认行为实现：<code>Reflect.setPrototypeOf()</code></p>\n<p>接受参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：需要设置原型的对象</li>\n<li><strong>proto</strong>：被用作原型的对象</li>\n</ol>\n<p>骚操作：可通过返回<code>false</code>使对象原型不可被设置</p>\n<p><strong>为何存在<code>Reflect.getPrototypeOf()</code>、<code>Reflect.setPrototypeOf()</code>与<code>Object.getPrototypeOf()</code>、<code>Object.setPrototypeOf()</code>两组方法？</strong></p>\n<p>两组方法作用虽然相似，但还是存在一些比较显著的差别：</p>\n<ol>\n<li>前者属于JS引擎底层操作，后者属于高级操作；</li>\n<li><code>Reflect.getPrototypeOf()</code>接收的参数不是对象时会抛出错误；而<code>Object.getPrototypeOf()</code>操作前会先将参数转换为对象；</li>\n<li><code>Reflect.setPrototypeOf()</code>会返回布尔值<code>true</code>或<code>false</code>表示成功或失败，<code>Object.setPrototypeOf()</code>操作失败时会报错，成功时会将第一个参数作为返回值；</li>\n</ol>\n<p>因此，Object两个原型操作方法并不适合用来实现代理陷阱的默认行为。</p>\n<h3 id=\"对象可扩展性的陷阱函数\"><a href=\"#对象可扩展性的陷阱函数\" class=\"headerlink\" title=\"对象可扩展性的陷阱函数\"></a>对象可扩展性的陷阱函数</h3><h3 id=\"preventExtensions\"><a href=\"#preventExtensions\" class=\"headerlink\" title=\"preventExtensions\"></a>preventExtensions</h3><p>拦截对象：<code>Object.preventExtensions()</code>。返回<code>true</code>或<code>false</code>表示操作成功或失败。</p>\n<p>默认行为实现：<code>Reflect.preventExtensions()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：设置不可扩展的对象</li>\n</ol>\n<h3 id=\"isExtensible\"><a href=\"#isExtensible\" class=\"headerlink\" title=\"isExtensible\"></a>isExtensible</h3><p>拦截对象：<code>Object.isExtensible()</code>。返回<code>true</code>或<code>false</code>表示操作成功或失败。</p>\n<p>默认行为实现：<code>Reflect.isExtensible()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：设置可扩展的对象</li>\n</ol>\n<p><strong>为何存在<code>Reflect.preventExtensions()</code>、<code>Reflect.isExtensible()</code>与<code>Object.preventExtensions()</code>、<code>Object.isExtensible()</code>两组方法？</strong></p>\n<p>两组方法几乎一致，但有一些差别：</p>\n<ol>\n<li>接收的参数不为对象时，<code>Object.isExtensible()</code>是返回<code>false</code>，而<code>Reflect.isExtensible()</code>会抛出错误；</li>\n<li><code>Object.preventExtensions()</code>不管参数是否是对象，都会将参数值作为自身返回值，而<code>Reflect.preventExtensions()</code>方法则会在参数不是对象时抛出错误，在参数为对象时返回<code>true</code>或<code>false</code>表示操作成功或失败；</li>\n<li>底层功能的方法与对应的高层方法相比，会进行更为严格的校验；</li>\n</ol>\n<h3 id=\"属性描述符的陷阱函数\"><a href=\"#属性描述符的陷阱函数\" class=\"headerlink\" title=\"属性描述符的陷阱函数\"></a>属性描述符的陷阱函数</h3><h3 id=\"definedProperty\"><a href=\"#definedProperty\" class=\"headerlink\" title=\"definedProperty\"></a>definedProperty</h3><p>拦截对象：<code>Object.defineProperty()</code>，返回<code>true</code>或<code>false</code>表示操作成功或失败。</p>\n<p>默认行为实现：<code>Reflect.defineProperty()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>tarpTarget</strong>：被定义属性的对象</li>\n<li><strong>key</strong>：属性的键</li>\n<li><strong>descriptor</strong>：为该属性准备的描述符对象</li>\n</ol>\n<p>骚操作：可通过主动返回<code>false</code>让<code>Object.defineProperty()</code>抛出错误失败，也可通过返回<code>true</code>而不调用<code>Reflect.defineProperty()</code>来让<code>Object.defineProperty()</code>静默失败。</p>\n<h3 id=\"getOwnPropertyDescriptor\"><a href=\"#getOwnPropertyDescriptor\" class=\"headerlink\" title=\"getOwnPropertyDescriptor\"></a>getOwnPropertyDescriptor</h3><p>拦截对象：<code>Object.getOwnPropertyDescriptor()</code>，返回对应的描述符。</p>\n<p>默认行为实现：<code>Reflect.getOwnPropertyDescriptor()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>tarpTarget</strong>：被检索属性的对象</li>\n<li><strong>key</strong>：属性的键</li>\n</ol>\n<p><strong>为何存在<code>Reflect.defineProperty()</code>、<code>Reflect.getOwnPropertyDescriptor()</code>与<code>Object.defineProperty()</code>、<code>Object.getOwnPropertyDescriptor()</code>两组方法？</strong></p>\n<p>两组方法几乎一致，但也有一些差别：</p>\n<ol>\n<li><code>Object.defineProperty()</code>返回第一个参数值，而<code>Reflect.defineProperty()</code>返回<code>true</code>或<code>false</code>;</li>\n<li>第一个参数不是对象时，<code>Object.getOwnPropertyDescriptor()</code>会将第一个参数转为对象，而<code>Reflect.getOwnPropertyDescriptor()</code>会抛出错误；</li>\n</ol>\n<h3 id=\"ownKeys\"><a href=\"#ownKeys\" class=\"headerlink\" title=\"ownKeys\"></a>ownKeys</h3><p>拦截对象：内部方法<code>[[OwnPropertyKeys]]</code>，返回一个数组重写该行为。数组被用于四个方法：<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>、<code>Object.assign()</code>，也能影响到<code>for-in</code>循环。不是返回数组或类数组对象，会抛出错误。</p>\n<p>默认行为实现：<code>Reflect.ownKeys()</code>，返回一个由全部自有属性的键构成的数组，无论键的类型是<strong>字符串</strong>还是<strong>符号</strong>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：获取属性的目标对象</li>\n</ol>\n<p>骚操作：可通过设置，不返回比如拥有下划线的属性（一般被定义为私有属性）</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> target = &#123;</span><br><span class=\"line\">    name: <span class=\"hljs-string\">'target'</span>,</span><br><span class=\"line\">    _name: <span class=\"hljs-string\">'private_target'</span> <span class=\"hljs-comment\">// 私有属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> proxyTarget = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    ownKeys (trapTarget) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.ownKeys(trapTarget).filter(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"hljs-comment\">// 可返回符号类型、字符类型且不包含下划线的属性</span></span><br><span class=\"line\">            <span class=\"hljs-keyword\">return</span> typeOf key !== <span class=\"hljs-string\">'string'</span> || key[<span class=\"hljs-number\">0</span>] !== <span class=\"hljs-string\">'_'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"apply和construct\"><a href=\"#apply和construct\" class=\"headerlink\" title=\"apply和construct\"></a>apply和construct</h3><p>拦截对象：内部方法<code>[[Call]]</code>和<code>[[Construct]]</code>，前者会在函数被直接调用时执行，而后者会在函数被使用<code>new</code>运算符调用时执行。</p>\n<p>apply陷阱函数(<code>Reflect.apply()</code>同样)接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong> ：被执行的函数（即代理的目标对象）；</li>\n<li><strong>thisArg</strong> ：调用过程中函数内部的 this 值；</li>\n<li><strong>argumentsList</strong> ：被传递给函数的参数数组。</li>\n</ol>\n<p>construct陷阱函数接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong> ：被执行的函数（即代理的目标对象）；</li>\n<li><strong>argumentsList</strong> ：被传递给函数的参数数组。</li>\n</ol>\n<p><code>Reflect.construct()</code>除了上述两个参数，还有第三个可选参数<code>newTarget</code>，此参数指定了函数内部<code>new.target</code>的值。</p>\n<p>骚操作：可以验证函数的类型；还可以不使用<code>new</code>来调用构造器；还可以限制函数只能通过<code>new</code>来调用等等。。。</p>\n<h3 id=\"撤销代理\"><a href=\"#撤销代理\" class=\"headerlink\" title=\"撤销代理\"></a>撤销代理</h3><p>一般代理创建之后不会被解绑，如果想要创建一个可被撤销的代理，可通过<code>Proxy.revocable()</code>方法，该方法跟<code>Proxy</code>构造器一样接收两个参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：被代理的目标对象</li>\n<li><strong>handler</strong>：代理处理器</li>\n</ol>\n<p>然后会返回一个包含以下属性的对象：</p>\n<ol>\n<li><strong>proxy</strong>：可被撤销的代理对象</li>\n<li><strong>revoke</strong>：用于撤销代理的函数</li>\n</ol>\n<p>通过调用<code>revoke()</code>，就无法再对<code>proxy</code>进行更多的操作，任何跟<code>proxy</code>的交互都会触发陷阱函数，从而抛出错误。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文总结了<code>Proxy</code>代理的陷阱函数和对应的<code>Reflect</code>接口默认行为函数的用法。因为目前用的最多的技术栈是<code>Vue</code>，而<code>Vue3.0</code>版本其中关于响应式原理的核心是<code>Proxy</code>，因此有必要对<code>Proxy</code>做进一步的理解和总结。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>拦截对象：设置属性值行为。成功返回<code>true</code>，失败返回<code>false</code>。</p>\n<p>默认行为实现：<code>Reflect.set()</code></p>","more":"<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：设置属性的对象（代理的目标对象）</li>\n<li><strong>key</strong>：属性的键</li>\n<li><strong>value</strong>：属性的值</li>\n<li><strong>receiver</strong>：操作发生的对象（通常指代理对象）</li>\n</ol>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><p>拦截对象：获取属性值行为。</p>\n<p>默认行为实现：<code>Reflect.get()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：获取属性的对象（代理的目标对象）</li>\n<li><strong>key</strong>：属性的键</li>\n<li><strong>receiver</strong>：操作发生的对象（通常指代理对象）</li>\n</ol>\n<p>骚操作：属性不存在时可明确抛出错误，而不是返回<code>undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyTar = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> (trapTarget, key, receiver) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(key <span class=\"keyword\">in</span> receiver)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">`property <span class=\"subst\">$&#123;key&#125;</span> is not exist`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(trapTarget, key, receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has\"></a>has</h3><p>拦截对象：<code>in</code>操作符。成功返回<code>true</code>，失败返回<code>false</code>。</p>\n<p>默认行为实现：<code>Reflect.has()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：读取属性的对象</li>\n<li><strong>key</strong>：需要检查的属性的键</li>\n</ol>\n<p>骚操作：通过返回<code>false</code>，隐藏属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'小叮当'</span>,</span><br><span class=\"line\">    _age: <span class=\"number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyTar = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    has (trapTarget, key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 隐藏_age属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key === <span class=\"string\">'_age'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.has(trapTarget, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"deleteProperty\"><a href=\"#deleteProperty\" class=\"headerlink\" title=\"deleteProperty\"></a>deleteProperty</h3><p>拦截对象：<code>delete</code>操作符。成功返回<code>true</code>，失败返回<code>false</code>。</p>\n<p>默认行为实现：<code>Reflect.deleteProperty()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：删除属性的对象</li>\n<li><strong>key</strong>：需要删除的属性的键</li>\n</ol>\n<p>骚操作：通过返回<code>false</code>，设置属性不可删除</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'小叮当'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">18</span>,</span><br><span class=\"line\">    idCard: <span class=\"string\">'75423546574xxx'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyTar = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    deleteProperty (trapTarget, key) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// idCard属性不可删除</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key === <span class=\"string\">'idCard'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.deleteProperty(trapTarget, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getPrototypeOf\"><a href=\"#getPrototypeOf\" class=\"headerlink\" title=\"getPrototypeOf\"></a>getPrototypeOf</h3><p>拦截对象：<code>Object.getPrototypeOf()</code>。返回值必须是一个对象或者是<code>null</code>，其它类型返回值会引发错误。</p>\n<p>默认行为实现：<code>Reflect.getPrototypeOf()</code></p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：需要获取原型的对象</li>\n</ol>\n<p>骚操作：可通过返回<code>null</code>来隐藏对象原型</p>\n<h3 id=\"setPrototypeOf\"><a href=\"#setPrototypeOf\" class=\"headerlink\" title=\"setPrototypeOf\"></a>setPrototypeOf</h3><p>拦截对象：<code>Object.setPrototypeOf()</code>。操作不成功时应返回<code>false</code>以让<code>Object.setPrototypeOf()</code>抛出错误，若返回不为<code>false</code>，则认为操作成功。</p>\n<p>默认行为实现：<code>Reflect.setPrototypeOf()</code></p>\n<p>接受参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：需要设置原型的对象</li>\n<li><strong>proto</strong>：被用作原型的对象</li>\n</ol>\n<p>骚操作：可通过返回<code>false</code>使对象原型不可被设置</p>\n<p><strong>为何存在<code>Reflect.getPrototypeOf()</code>、<code>Reflect.setPrototypeOf()</code>与<code>Object.getPrototypeOf()</code>、<code>Object.setPrototypeOf()</code>两组方法？</strong></p>\n<p>两组方法作用虽然相似，但还是存在一些比较显著的差别：</p>\n<ol>\n<li>前者属于JS引擎底层操作，后者属于高级操作；</li>\n<li><code>Reflect.getPrototypeOf()</code>接收的参数不是对象时会抛出错误；而<code>Object.getPrototypeOf()</code>操作前会先将参数转换为对象；</li>\n<li><code>Reflect.setPrototypeOf()</code>会返回布尔值<code>true</code>或<code>false</code>表示成功或失败，<code>Object.setPrototypeOf()</code>操作失败时会报错，成功时会将第一个参数作为返回值；</li>\n</ol>\n<p>因此，Object两个原型操作方法并不适合用来实现代理陷阱的默认行为。</p>\n<h3 id=\"对象可扩展性的陷阱函数\"><a href=\"#对象可扩展性的陷阱函数\" class=\"headerlink\" title=\"对象可扩展性的陷阱函数\"></a>对象可扩展性的陷阱函数</h3><h3 id=\"preventExtensions\"><a href=\"#preventExtensions\" class=\"headerlink\" title=\"preventExtensions\"></a>preventExtensions</h3><p>拦截对象：<code>Object.preventExtensions()</code>。返回<code>true</code>或<code>false</code>表示操作成功或失败。</p>\n<p>默认行为实现：<code>Reflect.preventExtensions()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：设置不可扩展的对象</li>\n</ol>\n<h3 id=\"isExtensible\"><a href=\"#isExtensible\" class=\"headerlink\" title=\"isExtensible\"></a>isExtensible</h3><p>拦截对象：<code>Object.isExtensible()</code>。返回<code>true</code>或<code>false</code>表示操作成功或失败。</p>\n<p>默认行为实现：<code>Reflect.isExtensible()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：设置可扩展的对象</li>\n</ol>\n<p><strong>为何存在<code>Reflect.preventExtensions()</code>、<code>Reflect.isExtensible()</code>与<code>Object.preventExtensions()</code>、<code>Object.isExtensible()</code>两组方法？</strong></p>\n<p>两组方法几乎一致，但有一些差别：</p>\n<ol>\n<li>接收的参数不为对象时，<code>Object.isExtensible()</code>是返回<code>false</code>，而<code>Reflect.isExtensible()</code>会抛出错误；</li>\n<li><code>Object.preventExtensions()</code>不管参数是否是对象，都会将参数值作为自身返回值，而<code>Reflect.preventExtensions()</code>方法则会在参数不是对象时抛出错误，在参数为对象时返回<code>true</code>或<code>false</code>表示操作成功或失败；</li>\n<li>底层功能的方法与对应的高层方法相比，会进行更为严格的校验；</li>\n</ol>\n<h3 id=\"属性描述符的陷阱函数\"><a href=\"#属性描述符的陷阱函数\" class=\"headerlink\" title=\"属性描述符的陷阱函数\"></a>属性描述符的陷阱函数</h3><h3 id=\"definedProperty\"><a href=\"#definedProperty\" class=\"headerlink\" title=\"definedProperty\"></a>definedProperty</h3><p>拦截对象：<code>Object.defineProperty()</code>，返回<code>true</code>或<code>false</code>表示操作成功或失败。</p>\n<p>默认行为实现：<code>Reflect.defineProperty()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>tarpTarget</strong>：被定义属性的对象</li>\n<li><strong>key</strong>：属性的键</li>\n<li><strong>descriptor</strong>：为该属性准备的描述符对象</li>\n</ol>\n<p>骚操作：可通过主动返回<code>false</code>让<code>Object.defineProperty()</code>抛出错误失败，也可通过返回<code>true</code>而不调用<code>Reflect.defineProperty()</code>来让<code>Object.defineProperty()</code>静默失败。</p>\n<h3 id=\"getOwnPropertyDescriptor\"><a href=\"#getOwnPropertyDescriptor\" class=\"headerlink\" title=\"getOwnPropertyDescriptor\"></a>getOwnPropertyDescriptor</h3><p>拦截对象：<code>Object.getOwnPropertyDescriptor()</code>，返回对应的描述符。</p>\n<p>默认行为实现：<code>Reflect.getOwnPropertyDescriptor()</code>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>tarpTarget</strong>：被检索属性的对象</li>\n<li><strong>key</strong>：属性的键</li>\n</ol>\n<p><strong>为何存在<code>Reflect.defineProperty()</code>、<code>Reflect.getOwnPropertyDescriptor()</code>与<code>Object.defineProperty()</code>、<code>Object.getOwnPropertyDescriptor()</code>两组方法？</strong></p>\n<p>两组方法几乎一致，但也有一些差别：</p>\n<ol>\n<li><code>Object.defineProperty()</code>返回第一个参数值，而<code>Reflect.defineProperty()</code>返回<code>true</code>或<code>false</code>;</li>\n<li>第一个参数不是对象时，<code>Object.getOwnPropertyDescriptor()</code>会将第一个参数转为对象，而<code>Reflect.getOwnPropertyDescriptor()</code>会抛出错误；</li>\n</ol>\n<h3 id=\"ownKeys\"><a href=\"#ownKeys\" class=\"headerlink\" title=\"ownKeys\"></a>ownKeys</h3><p>拦截对象：内部方法<code>[[OwnPropertyKeys]]</code>，返回一个数组重写该行为。数组被用于四个方法：<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>、<code>Object.assign()</code>，也能影响到<code>for-in</code>循环。不是返回数组或类数组对象，会抛出错误。</p>\n<p>默认行为实现：<code>Reflect.ownKeys()</code>，返回一个由全部自有属性的键构成的数组，无论键的类型是<strong>字符串</strong>还是<strong>符号</strong>。</p>\n<p>接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：获取属性的目标对象</li>\n</ol>\n<p>骚操作：可通过设置，不返回比如拥有下划线的属性（一般被定义为私有属性）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> target = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'target'</span>,</span><br><span class=\"line\">    _name: <span class=\"string\">'private_target'</span> <span class=\"comment\">// 私有属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyTarget = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">    ownKeys (trapTarget) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.ownKeys(trapTarget).filter(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可返回符号类型、字符类型且不包含下划线的属性</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> typeOf key !== <span class=\"string\">'string'</span> || key[<span class=\"number\">0</span>] !== <span class=\"string\">'_'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"apply和construct\"><a href=\"#apply和construct\" class=\"headerlink\" title=\"apply和construct\"></a>apply和construct</h3><p>拦截对象：内部方法<code>[[Call]]</code>和<code>[[Construct]]</code>，前者会在函数被直接调用时执行，而后者会在函数被使用<code>new</code>运算符调用时执行。</p>\n<p>apply陷阱函数(<code>Reflect.apply()</code>同样)接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong> ：被执行的函数（即代理的目标对象）；</li>\n<li><strong>thisArg</strong> ：调用过程中函数内部的 this 值；</li>\n<li><strong>argumentsList</strong> ：被传递给函数的参数数组。</li>\n</ol>\n<p>construct陷阱函数接收参数：</p>\n<ol>\n<li><strong>trapTarget</strong> ：被执行的函数（即代理的目标对象）；</li>\n<li><strong>argumentsList</strong> ：被传递给函数的参数数组。</li>\n</ol>\n<p><code>Reflect.construct()</code>除了上述两个参数，还有第三个可选参数<code>newTarget</code>，此参数指定了函数内部<code>new.target</code>的值。</p>\n<p>骚操作：可以验证函数的类型；还可以不使用<code>new</code>来调用构造器；还可以限制函数只能通过<code>new</code>来调用等等。。。</p>\n<h3 id=\"撤销代理\"><a href=\"#撤销代理\" class=\"headerlink\" title=\"撤销代理\"></a>撤销代理</h3><p>一般代理创建之后不会被解绑，如果想要创建一个可被撤销的代理，可通过<code>Proxy.revocable()</code>方法，该方法跟<code>Proxy</code>构造器一样接收两个参数：</p>\n<ol>\n<li><strong>trapTarget</strong>：被代理的目标对象</li>\n<li><strong>handler</strong>：代理处理器</li>\n</ol>\n<p>然后会返回一个包含以下属性的对象：</p>\n<ol>\n<li><strong>proxy</strong>：可被撤销的代理对象</li>\n<li><strong>revoke</strong>：用于撤销代理的函数</li>\n</ol>\n<p>通过调用<code>revoke()</code>，就无法再对<code>proxy</code>进行更多的操作，任何跟<code>proxy</code>的交互都会触发陷阱函数，从而抛出错误。</p>"},{"title":"前端幸福感是如何炼成的（下）","_content":"\n## 前言\n\n> 上一篇总结了前端对外沟通输出以及外在幸福感的炼成，这一篇主要是对内在幸福感的总结\n\n内在的幸福感影响因素有很多，总结最主要有以下几类：\n\n- 重复业务多，键盘只用ctrl+cv，空有搬砖感，毫无成就感\n- 搬砖搬得多，稍微来加点挑战性的，逻辑绕不过，就说顶不住\n- 面对技术的高速迭代，无从下手，茫然失措，最后迷失方向脱离前端坑路\n\n总结出问题，那就可以很容易找到解决方法了\n\n<!-- more -->\n\n## 减少重复工作，提高编码质量\n\n大家在工作中肯定会经常遇到重复的、或者功能类似的业务，一般的操作估计就是一顿cv，疯狂复制粘贴，完事。但是这种就是单纯的体力活，久而久之，就会觉得枯燥乏味，没新鲜感、成就感，慢慢就会对工作失去热情。\n\n这种情况，简而言之，在多处地方出现的代码，能被copy来使用的，就要想一下是否可以抽离逻辑，封装复用。而封装一般分为两种情况，**配置**和**组件**\n\n### 配置\n\n#### CSS\n\n我们开发某一个端的应用时，经常会有一两种主题色，页面结构会有常用的布局样式，按钮等等也会有常用的样式，对于这些常用的样式，我们可以通过写成统一的css变量和类，放在一个tools文件来实现样式复用，这里采用`less`预处理器\n\n```less\n// tools.less\n\n// 主题类\n@happy-theme: orange;\n@sad-theme: gray;\n@danger-theme: red;\n\n// 布局类\n.flex-align {\n    display: flex;\n    align-items: center;\n}\n.flex-between {\n    display: flex;\n    justify-content: between;\n    align-items: center;\n}\n.flex-center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\n```vue\n// test.vue\n\n<template>\n\t<!-- 将div设置成flex居中布局 -->\n\t<div class=\"test-div flex-center\"></div>\n</template>\t\n<style lang=\"less\">\n\t@import 'tools.less';\n    // 将div背景颜色设置成happy主题\n    .test-div {\n        background: @happy-theme;\n    }\n</style>\n```\n\n可以看到，引入了该工具文件实现样式复用，后续如果需求有更改，需要更换样式主题的，也只需在一个地方更改即可\n\n#### JS\n\n通常我们调用后端接口的时候，后端会根据不同情况来返回不同的响应res code，比如`0001`表示请求成功，正常返回数据，`0002`表示请求成功，无数据，`1000`表示请求失败等，显然这里也可以做成配置\n\n```javascript\nconst CODELIST = [\n    '0001': 'suc',\n    '0002': 'no data',\n    '1000': 'error'\n]\n\naxios.get('/getData', {params: {}}).then(res => {\n    if (CODELIST[res.code] === 'suc') {\n        ...\n    } else if (CODELIST[res.code] === 'no data') {\n        ...\n    } else {\n        ...\n    }\n})\n```\n\n将返回码映射成文件，与不同项目不同团队对接的时候，也只是修改映射表就搞定了~\n\n### 组件\n\n说到组件大家应该也都不陌生了，组件化思想现在更是用得多姿多彩，那么重合的功能业务，我们就可以封装成组件，供不同的页面使用\n\n比如后台管理端页面，常见的结构就是表单查询+工具栏菜单+表格列表+分页，如果有10个页面（真实情况往往不止），我们是不是要创建10遍重合度90%以上的代码？这个时候要考虑能不能抽离逻辑，做成一个组件，然后往这个组件传参数，来让它实现不同的功能。[esay-page组件源码]( https://github.com/Ysom/component-tools/tree/master/easy-page )\n\n```vue\n// parent.vue\n<template>\n\t<easy-page ref=\"easyPage\" :formData=\"form\" :columns=\"column\"\n               :layout=\"['form', 'toolbar', 'table', 'pagination']\" \n               :getApi=\"getApi\">\n    </easy-page>\t\n</template>\n\n<script>\n\texport default {\n        const columns = [\n        \t{label: '序号', prop: 'index'},\n        \t{label: '姓名', prop: 'name'}\n        ]\n        data () {\n            return {\n                form: {},\n                columns,\n                getApi: '/getData'\n            }\n        }\n    }\n</script>\n```\n\n通过这样一个组件，就可以实现简单的表单查询+工具栏+表格+分页，通过参数也可以控制页面结构。\n\n还有类似上传功能，element-ui等UI库已经帮我们实现了很多，但是业务往往没有那么简单，我们需要基于已经实现的功能去进行二次封装\n\n```vue\n// easy-upload.vue\n<template>\n\t<el-upload></el-upload>\n</template>\n\n<script>\n\texport default {\n        props: {\n            // 二次封装需要的参数\n        },\n        data () {\n            return {}\n        }\n    }\n</script>\n```\n\n```vue\n// parent.vue\n<template>\n\t<easy-upload :setting=\"setting\"></easy-upload>\n</template>\n\n<script>\nimport EasyUpload from 'easy-upload.vue'\nexport default {\n\tdata () {\n\t\treturn {\n\t\t\tsetting: {} // 自定义配置\n\t\t}\n\t}\n}\n</script>\n```\n\n\n\n一次封装，就能在多处进行灵活性更强的使用，而在二次封装的过程中一些逻辑处理，可比搬砖有趣多了\n\n## 学习数据结构，拓展思维\n\n很多前端同事都会在google、百度、知乎等提问，“**前端是否应该学习数据结构**”，“**前端学算法有用吗**”等等问题，我觉得问这种问题，是还没从根本上理解代码存在的意义，每一个开发工程师都是通过代码跟机器打交道的，而数据结构就是数据、代码的一种结构化，是数据组织方法，不学数据结构，不学算法，怎么跟机器进行更深层次的交流？跟机器交流好比跟人沟通，好的语言组织能让我们事半功半，适合的数据结构也能让性能更加优越。\n\n说到底，我们的业务都是基于各种不同的数据结构来完成的，只不过有一些平时写的逻辑较简单，会忽略了其实也是用到数据结构来实现的，不学数据结构，不学算法，不会知道可以用双端队列来做回文字符串检查，不会知道可以用循环链表来实现小时候爱玩的“击鼓传花”游戏，不会知道撤销、回滚是怎么实现。\n\n回到总结，数据结构不是学不学的问题，是要往多深学，起码最基本的`栈`、`队列`、`链表`、`树`、`图`等都要了解，至于深度，就取决你对自己的要求以及工作中的需求\n\n##  阅读源码，提高逻辑\n\n提高幸福感的另一件事，就是阅读源码了。可能有人会问，啥，阅读源码幸福？不是很痛苦？是的，源码一开始看确实很痛苦，尤其是优秀的项目一般架构比较复杂，想看也不知从何下手，但是我们可以见招拆招，从部分模块看起，比如`vue`中，可以看双向绑定，可以看响应式设计等等，从某个模块看起，能有效降低源码阅读难度。\n\n而且一个优秀的框架、库是经过了时间和用户的考验，阅读源码也是我们近距离接触大神的途径，我们可以从源码中看出大神他们的设计思想，思考方法，开发逻辑等等，我们自己创造不了牛逼框架，还学习不了？\n\n## 关注行情，了解趋势\n\n> 当今这个时代，努力奔跑只能保持原地不动，而停滞不前就会逐步落后\n\n前端的发展大家有目共睹，可谓是日新月异，这个时候的我们，只能多多关注技术发展，来扩充自己的眼界，不然别人问起什么是大前端，什么时候是前端微服务，我们都是一脸懵逼，眼界将会决定我们在这条路上能走多远，走多久，如果没有幸福感，没有兴趣支撑我们前进，心越空，越容易被焦虑感填满，我们很容易就会被洪流冲走，心中有方向，前进才不会迷失。\n\n## 定时review，做一个“铲屎官”\n\n最后要讲的一点，不管开发的时候对自己写的代码有多熟悉，都要写上注释，这是为后面自己或者同事review的时候做好前置工作。还有就是要定时对自己的代码做review，或者让朋友、同事帮我们review，因为不管啥时候，我们回过头来看自己的代码，都有一种在看shi的感觉，对吧？而review的过程，就是一个铲屎的过程，手握review铲，哪里有shi铲哪里，老板再也不用担心我巨坑了！一边review一边骂自己当时为啥那么sb，写出这么shi的代码，一边优化提高自己的能力，所以，review可以帮我们更好地认识自己，也能更好地提高自己~\n\n## 结语\n\n本篇从几个方面做了提升内在幸福感的总结，也是这一年多来的心得体会，可能总结不是很到位，会有很多遗漏，但就像上面说的，当我以后回过头来看这篇文章的时候，我是在review，是在优化，我还是在继续提升。\n\n","source":"_posts/前端幸福感是如何炼成的（下）.md","raw":"---\ntitle: 前端幸福感是如何炼成的（下）\ncategories:\n - 前端\ntags:\n - 总结\n---\n\n## 前言\n\n> 上一篇总结了前端对外沟通输出以及外在幸福感的炼成，这一篇主要是对内在幸福感的总结\n\n内在的幸福感影响因素有很多，总结最主要有以下几类：\n\n- 重复业务多，键盘只用ctrl+cv，空有搬砖感，毫无成就感\n- 搬砖搬得多，稍微来加点挑战性的，逻辑绕不过，就说顶不住\n- 面对技术的高速迭代，无从下手，茫然失措，最后迷失方向脱离前端坑路\n\n总结出问题，那就可以很容易找到解决方法了\n\n<!-- more -->\n\n## 减少重复工作，提高编码质量\n\n大家在工作中肯定会经常遇到重复的、或者功能类似的业务，一般的操作估计就是一顿cv，疯狂复制粘贴，完事。但是这种就是单纯的体力活，久而久之，就会觉得枯燥乏味，没新鲜感、成就感，慢慢就会对工作失去热情。\n\n这种情况，简而言之，在多处地方出现的代码，能被copy来使用的，就要想一下是否可以抽离逻辑，封装复用。而封装一般分为两种情况，**配置**和**组件**\n\n### 配置\n\n#### CSS\n\n我们开发某一个端的应用时，经常会有一两种主题色，页面结构会有常用的布局样式，按钮等等也会有常用的样式，对于这些常用的样式，我们可以通过写成统一的css变量和类，放在一个tools文件来实现样式复用，这里采用`less`预处理器\n\n```less\n// tools.less\n\n// 主题类\n@happy-theme: orange;\n@sad-theme: gray;\n@danger-theme: red;\n\n// 布局类\n.flex-align {\n    display: flex;\n    align-items: center;\n}\n.flex-between {\n    display: flex;\n    justify-content: between;\n    align-items: center;\n}\n.flex-center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\n```vue\n// test.vue\n\n<template>\n\t<!-- 将div设置成flex居中布局 -->\n\t<div class=\"test-div flex-center\"></div>\n</template>\t\n<style lang=\"less\">\n\t@import 'tools.less';\n    // 将div背景颜色设置成happy主题\n    .test-div {\n        background: @happy-theme;\n    }\n</style>\n```\n\n可以看到，引入了该工具文件实现样式复用，后续如果需求有更改，需要更换样式主题的，也只需在一个地方更改即可\n\n#### JS\n\n通常我们调用后端接口的时候，后端会根据不同情况来返回不同的响应res code，比如`0001`表示请求成功，正常返回数据，`0002`表示请求成功，无数据，`1000`表示请求失败等，显然这里也可以做成配置\n\n```javascript\nconst CODELIST = [\n    '0001': 'suc',\n    '0002': 'no data',\n    '1000': 'error'\n]\n\naxios.get('/getData', {params: {}}).then(res => {\n    if (CODELIST[res.code] === 'suc') {\n        ...\n    } else if (CODELIST[res.code] === 'no data') {\n        ...\n    } else {\n        ...\n    }\n})\n```\n\n将返回码映射成文件，与不同项目不同团队对接的时候，也只是修改映射表就搞定了~\n\n### 组件\n\n说到组件大家应该也都不陌生了，组件化思想现在更是用得多姿多彩，那么重合的功能业务，我们就可以封装成组件，供不同的页面使用\n\n比如后台管理端页面，常见的结构就是表单查询+工具栏菜单+表格列表+分页，如果有10个页面（真实情况往往不止），我们是不是要创建10遍重合度90%以上的代码？这个时候要考虑能不能抽离逻辑，做成一个组件，然后往这个组件传参数，来让它实现不同的功能。[esay-page组件源码]( https://github.com/Ysom/component-tools/tree/master/easy-page )\n\n```vue\n// parent.vue\n<template>\n\t<easy-page ref=\"easyPage\" :formData=\"form\" :columns=\"column\"\n               :layout=\"['form', 'toolbar', 'table', 'pagination']\" \n               :getApi=\"getApi\">\n    </easy-page>\t\n</template>\n\n<script>\n\texport default {\n        const columns = [\n        \t{label: '序号', prop: 'index'},\n        \t{label: '姓名', prop: 'name'}\n        ]\n        data () {\n            return {\n                form: {},\n                columns,\n                getApi: '/getData'\n            }\n        }\n    }\n</script>\n```\n\n通过这样一个组件，就可以实现简单的表单查询+工具栏+表格+分页，通过参数也可以控制页面结构。\n\n还有类似上传功能，element-ui等UI库已经帮我们实现了很多，但是业务往往没有那么简单，我们需要基于已经实现的功能去进行二次封装\n\n```vue\n// easy-upload.vue\n<template>\n\t<el-upload></el-upload>\n</template>\n\n<script>\n\texport default {\n        props: {\n            // 二次封装需要的参数\n        },\n        data () {\n            return {}\n        }\n    }\n</script>\n```\n\n```vue\n// parent.vue\n<template>\n\t<easy-upload :setting=\"setting\"></easy-upload>\n</template>\n\n<script>\nimport EasyUpload from 'easy-upload.vue'\nexport default {\n\tdata () {\n\t\treturn {\n\t\t\tsetting: {} // 自定义配置\n\t\t}\n\t}\n}\n</script>\n```\n\n\n\n一次封装，就能在多处进行灵活性更强的使用，而在二次封装的过程中一些逻辑处理，可比搬砖有趣多了\n\n## 学习数据结构，拓展思维\n\n很多前端同事都会在google、百度、知乎等提问，“**前端是否应该学习数据结构**”，“**前端学算法有用吗**”等等问题，我觉得问这种问题，是还没从根本上理解代码存在的意义，每一个开发工程师都是通过代码跟机器打交道的，而数据结构就是数据、代码的一种结构化，是数据组织方法，不学数据结构，不学算法，怎么跟机器进行更深层次的交流？跟机器交流好比跟人沟通，好的语言组织能让我们事半功半，适合的数据结构也能让性能更加优越。\n\n说到底，我们的业务都是基于各种不同的数据结构来完成的，只不过有一些平时写的逻辑较简单，会忽略了其实也是用到数据结构来实现的，不学数据结构，不学算法，不会知道可以用双端队列来做回文字符串检查，不会知道可以用循环链表来实现小时候爱玩的“击鼓传花”游戏，不会知道撤销、回滚是怎么实现。\n\n回到总结，数据结构不是学不学的问题，是要往多深学，起码最基本的`栈`、`队列`、`链表`、`树`、`图`等都要了解，至于深度，就取决你对自己的要求以及工作中的需求\n\n##  阅读源码，提高逻辑\n\n提高幸福感的另一件事，就是阅读源码了。可能有人会问，啥，阅读源码幸福？不是很痛苦？是的，源码一开始看确实很痛苦，尤其是优秀的项目一般架构比较复杂，想看也不知从何下手，但是我们可以见招拆招，从部分模块看起，比如`vue`中，可以看双向绑定，可以看响应式设计等等，从某个模块看起，能有效降低源码阅读难度。\n\n而且一个优秀的框架、库是经过了时间和用户的考验，阅读源码也是我们近距离接触大神的途径，我们可以从源码中看出大神他们的设计思想，思考方法，开发逻辑等等，我们自己创造不了牛逼框架，还学习不了？\n\n## 关注行情，了解趋势\n\n> 当今这个时代，努力奔跑只能保持原地不动，而停滞不前就会逐步落后\n\n前端的发展大家有目共睹，可谓是日新月异，这个时候的我们，只能多多关注技术发展，来扩充自己的眼界，不然别人问起什么是大前端，什么时候是前端微服务，我们都是一脸懵逼，眼界将会决定我们在这条路上能走多远，走多久，如果没有幸福感，没有兴趣支撑我们前进，心越空，越容易被焦虑感填满，我们很容易就会被洪流冲走，心中有方向，前进才不会迷失。\n\n## 定时review，做一个“铲屎官”\n\n最后要讲的一点，不管开发的时候对自己写的代码有多熟悉，都要写上注释，这是为后面自己或者同事review的时候做好前置工作。还有就是要定时对自己的代码做review，或者让朋友、同事帮我们review，因为不管啥时候，我们回过头来看自己的代码，都有一种在看shi的感觉，对吧？而review的过程，就是一个铲屎的过程，手握review铲，哪里有shi铲哪里，老板再也不用担心我巨坑了！一边review一边骂自己当时为啥那么sb，写出这么shi的代码，一边优化提高自己的能力，所以，review可以帮我们更好地认识自己，也能更好地提高自己~\n\n## 结语\n\n本篇从几个方面做了提升内在幸福感的总结，也是这一年多来的心得体会，可能总结不是很到位，会有很多遗漏，但就像上面说的，当我以后回过头来看这篇文章的时候，我是在review，是在优化，我还是在继续提升。\n\n","slug":"前端幸福感是如何炼成的（下）","published":1,"date":"2019-11-17T14:49:39.319Z","updated":"2019-11-19T03:01:48.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4n2002qhsuh1rsxcnsy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>上一篇总结了前端对外沟通输出以及外在幸福感的炼成，这一篇主要是对内在幸福感的总结</p>\n</blockquote>\n<p>内在的幸福感影响因素有很多，总结最主要有以下几类：</p>\n<ul>\n<li>重复业务多，键盘只用ctrl+cv，空有搬砖感，毫无成就感</li>\n<li>搬砖搬得多，稍微来加点挑战性的，逻辑绕不过，就说顶不住</li>\n<li>面对技术的高速迭代，无从下手，茫然失措，最后迷失方向脱离前端坑路</li>\n</ul>\n<p>总结出问题，那就可以很容易找到解决方法了</p>\n<a id=\"more\"></a>\n\n<h2 id=\"减少重复工作，提高编码质量\"><a href=\"#减少重复工作，提高编码质量\" class=\"headerlink\" title=\"减少重复工作，提高编码质量\"></a>减少重复工作，提高编码质量</h2><p>大家在工作中肯定会经常遇到重复的、或者功能类似的业务，一般的操作估计就是一顿cv，疯狂复制粘贴，完事。但是这种就是单纯的体力活，久而久之，就会觉得枯燥乏味，没新鲜感、成就感，慢慢就会对工作失去热情。</p>\n<p>这种情况，简而言之，在多处地方出现的代码，能被copy来使用的，就要想一下是否可以抽离逻辑，封装复用。而封装一般分为两种情况，<strong>配置</strong>和<strong>组件</strong></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h4><p>我们开发某一个端的应用时，经常会有一两种主题色，页面结构会有常用的布局样式，按钮等等也会有常用的样式，对于这些常用的样式，我们可以通过写成统一的css变量和类，放在一个tools文件来实现样式复用，这里采用<code>less</code>预处理器</p>\n<figure class=\"highlight less hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// tools.less</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 主题类</span></span><br><span class=\"line\"><span class=\"hljs-variable\">@happy-theme:</span> orange;</span><br><span class=\"line\"><span class=\"hljs-variable\">@sad-theme:</span> gray;</span><br><span class=\"line\"><span class=\"hljs-variable\">@danger-theme:</span> red;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 布局类</span></span><br><span class=\"line\"><span class=\"hljs-selector-class\">.flex-align</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-selector-class\">.flex-between</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">justify-content</span>: between;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-selector-class\">.flex-center</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"hljs-attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// test.vue</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;!-- 将div设置成flex居中布局 --&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;test-div flex-center&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;\t</span><br><span class=\"line\">&lt;style lang=&quot;less&quot;&gt;</span><br><span class=\"line\">\t@import &apos;tools.less&apos;;</span><br><span class=\"line\">    // 将div背景颜色设置成happy主题</span><br><span class=\"line\">    .test-div &#123;</span><br><span class=\"line\">        background: @happy-theme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引入了该工具文件实现样式复用，后续如果需求有更改，需要更换样式主题的，也只需在一个地方更改即可</p>\n<h4 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h4><p>通常我们调用后端接口的时候，后端会根据不同情况来返回不同的响应res code，比如<code>0001</code>表示请求成功，正常返回数据，<code>0002</code>表示请求成功，无数据，<code>1000</code>表示请求失败等，显然这里也可以做成配置</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> CODELIST = [</span><br><span class=\"line\">    <span class=\"hljs-string\">'0001'</span>: <span class=\"hljs-string\">'suc'</span>,</span><br><span class=\"line\">    <span class=\"hljs-string\">'0002'</span>: <span class=\"hljs-string\">'no data'</span>,</span><br><span class=\"line\">    <span class=\"hljs-string\">'1000'</span>: <span class=\"hljs-string\">'error'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">axios.get(<span class=\"hljs-string\">'/getData'</span>, &#123;<span class=\"hljs-attr\">params</span>: &#123;&#125;&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (CODELIST[res.code] === <span class=\"hljs-string\">'suc'</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (CODELIST[res.code] === <span class=\"hljs-string\">'no data'</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>将返回码映射成文件，与不同项目不同团队对接的时候，也只是修改映射表就搞定了~</p>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>说到组件大家应该也都不陌生了，组件化思想现在更是用得多姿多彩，那么重合的功能业务，我们就可以封装成组件，供不同的页面使用</p>\n<p>比如后台管理端页面，常见的结构就是表单查询+工具栏菜单+表格列表+分页，如果有10个页面（真实情况往往不止），我们是不是要创建10遍重合度90%以上的代码？这个时候要考虑能不能抽离逻辑，做成一个组件，然后往这个组件传参数，来让它实现不同的功能。<a href=\"https://github.com/Ysom/component-tools/tree/master/easy-page\" target=\"_blank\" rel=\"noopener\">esay-page组件源码</a></p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// parent.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;easy-page ref=&quot;easyPage&quot; :formData=&quot;form&quot; :columns=&quot;column&quot;</span><br><span class=\"line\">               :layout=&quot;[&apos;form&apos;, &apos;toolbar&apos;, &apos;table&apos;, &apos;pagination&apos;]&quot; </span><br><span class=\"line\">               :getApi=&quot;getApi&quot;&gt;</span><br><span class=\"line\">    &lt;/easy-page&gt;\t</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\texport default &#123;</span><br><span class=\"line\">        const columns = [</span><br><span class=\"line\">        \t&#123;label: &apos;序号&apos;, prop: &apos;index&apos;&#125;,</span><br><span class=\"line\">        \t&#123;label: &apos;姓名&apos;, prop: &apos;name&apos;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                form: &#123;&#125;,</span><br><span class=\"line\">                columns,</span><br><span class=\"line\">                getApi: &apos;/getData&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>通过这样一个组件，就可以实现简单的表单查询+工具栏+表格+分页，通过参数也可以控制页面结构。</p>\n<p>还有类似上传功能，element-ui等UI库已经帮我们实现了很多，但是业务往往没有那么简单，我们需要基于已经实现的功能去进行二次封装</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// easy-upload.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;el-upload&gt;&lt;/el-upload&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\texport default &#123;</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            // 二次封装需要的参数</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            return &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// parent.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;easy-upload :setting=&quot;setting&quot;&gt;&lt;/easy-upload&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import EasyUpload from &apos;easy-upload.vue&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tdata () &#123;</span><br><span class=\"line\">\t\treturn &#123;</span><br><span class=\"line\">\t\t\tsetting: &#123;&#125; // 自定义配置</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一次封装，就能在多处进行灵活性更强的使用，而在二次封装的过程中一些逻辑处理，可比搬砖有趣多了</p>\n<h2 id=\"学习数据结构，拓展思维\"><a href=\"#学习数据结构，拓展思维\" class=\"headerlink\" title=\"学习数据结构，拓展思维\"></a>学习数据结构，拓展思维</h2><p>很多前端同事都会在google、百度、知乎等提问，“<strong>前端是否应该学习数据结构</strong>”，“<strong>前端学算法有用吗</strong>”等等问题，我觉得问这种问题，是还没从根本上理解代码存在的意义，每一个开发工程师都是通过代码跟机器打交道的，而数据结构就是数据、代码的一种结构化，是数据组织方法，不学数据结构，不学算法，怎么跟机器进行更深层次的交流？跟机器交流好比跟人沟通，好的语言组织能让我们事半功半，适合的数据结构也能让性能更加优越。</p>\n<p>说到底，我们的业务都是基于各种不同的数据结构来完成的，只不过有一些平时写的逻辑较简单，会忽略了其实也是用到数据结构来实现的，不学数据结构，不学算法，不会知道可以用双端队列来做回文字符串检查，不会知道可以用循环链表来实现小时候爱玩的“击鼓传花”游戏，不会知道撤销、回滚是怎么实现。</p>\n<p>回到总结，数据结构不是学不学的问题，是要往多深学，起码最基本的<code>栈</code>、<code>队列</code>、<code>链表</code>、<code>树</code>、<code>图</code>等都要了解，至于深度，就取决你对自己的要求以及工作中的需求</p>\n<h2 id=\"阅读源码，提高逻辑\"><a href=\"#阅读源码，提高逻辑\" class=\"headerlink\" title=\"阅读源码，提高逻辑\"></a>阅读源码，提高逻辑</h2><p>提高幸福感的另一件事，就是阅读源码了。可能有人会问，啥，阅读源码幸福？不是很痛苦？是的，源码一开始看确实很痛苦，尤其是优秀的项目一般架构比较复杂，想看也不知从何下手，但是我们可以见招拆招，从部分模块看起，比如<code>vue</code>中，可以看双向绑定，可以看响应式设计等等，从某个模块看起，能有效降低源码阅读难度。</p>\n<p>而且一个优秀的框架、库是经过了时间和用户的考验，阅读源码也是我们近距离接触大神的途径，我们可以从源码中看出大神他们的设计思想，思考方法，开发逻辑等等，我们自己创造不了牛逼框架，还学习不了？</p>\n<h2 id=\"关注行情，了解趋势\"><a href=\"#关注行情，了解趋势\" class=\"headerlink\" title=\"关注行情，了解趋势\"></a>关注行情，了解趋势</h2><blockquote>\n<p>当今这个时代，努力奔跑只能保持原地不动，而停滞不前就会逐步落后</p>\n</blockquote>\n<p>前端的发展大家有目共睹，可谓是日新月异，这个时候的我们，只能多多关注技术发展，来扩充自己的眼界，不然别人问起什么是大前端，什么时候是前端微服务，我们都是一脸懵逼，眼界将会决定我们在这条路上能走多远，走多久，如果没有幸福感，没有兴趣支撑我们前进，心越空，越容易被焦虑感填满，我们很容易就会被洪流冲走，心中有方向，前进才不会迷失。</p>\n<h2 id=\"定时review，做一个“铲屎官”\"><a href=\"#定时review，做一个“铲屎官”\" class=\"headerlink\" title=\"定时review，做一个“铲屎官”\"></a>定时review，做一个“铲屎官”</h2><p>最后要讲的一点，不管开发的时候对自己写的代码有多熟悉，都要写上注释，这是为后面自己或者同事review的时候做好前置工作。还有就是要定时对自己的代码做review，或者让朋友、同事帮我们review，因为不管啥时候，我们回过头来看自己的代码，都有一种在看shi的感觉，对吧？而review的过程，就是一个铲屎的过程，手握review铲，哪里有shi铲哪里，老板再也不用担心我巨坑了！一边review一边骂自己当时为啥那么sb，写出这么shi的代码，一边优化提高自己的能力，所以，review可以帮我们更好地认识自己，也能更好地提高自己~</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本篇从几个方面做了提升内在幸福感的总结，也是这一年多来的心得体会，可能总结不是很到位，会有很多遗漏，但就像上面说的，当我以后回过头来看这篇文章的时候，我是在review，是在优化，我还是在继续提升。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>上一篇总结了前端对外沟通输出以及外在幸福感的炼成，这一篇主要是对内在幸福感的总结</p>\n</blockquote>\n<p>内在的幸福感影响因素有很多，总结最主要有以下几类：</p>\n<ul>\n<li>重复业务多，键盘只用ctrl+cv，空有搬砖感，毫无成就感</li>\n<li>搬砖搬得多，稍微来加点挑战性的，逻辑绕不过，就说顶不住</li>\n<li>面对技术的高速迭代，无从下手，茫然失措，最后迷失方向脱离前端坑路</li>\n</ul>\n<p>总结出问题，那就可以很容易找到解决方法了</p>","more":"<h2 id=\"减少重复工作，提高编码质量\"><a href=\"#减少重复工作，提高编码质量\" class=\"headerlink\" title=\"减少重复工作，提高编码质量\"></a>减少重复工作，提高编码质量</h2><p>大家在工作中肯定会经常遇到重复的、或者功能类似的业务，一般的操作估计就是一顿cv，疯狂复制粘贴，完事。但是这种就是单纯的体力活，久而久之，就会觉得枯燥乏味，没新鲜感、成就感，慢慢就会对工作失去热情。</p>\n<p>这种情况，简而言之，在多处地方出现的代码，能被copy来使用的，就要想一下是否可以抽离逻辑，封装复用。而封装一般分为两种情况，<strong>配置</strong>和<strong>组件</strong></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h4><p>我们开发某一个端的应用时，经常会有一两种主题色，页面结构会有常用的布局样式，按钮等等也会有常用的样式，对于这些常用的样式，我们可以通过写成统一的css变量和类，放在一个tools文件来实现样式复用，这里采用<code>less</code>预处理器</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tools.less</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主题类</span></span><br><span class=\"line\"><span class=\"variable\">@happy-theme:</span> orange;</span><br><span class=\"line\"><span class=\"variable\">@sad-theme:</span> gray;</span><br><span class=\"line\"><span class=\"variable\">@danger-theme:</span> red;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 布局类</span></span><br><span class=\"line\"><span class=\"selector-class\">.flex-align</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.flex-between</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: between;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.flex-center</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// test.vue</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;!-- 将div设置成flex居中布局 --&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;test-div flex-center&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;\t</span><br><span class=\"line\">&lt;style lang=&quot;less&quot;&gt;</span><br><span class=\"line\">\t@import &apos;tools.less&apos;;</span><br><span class=\"line\">    // 将div背景颜色设置成happy主题</span><br><span class=\"line\">    .test-div &#123;</span><br><span class=\"line\">        background: @happy-theme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引入了该工具文件实现样式复用，后续如果需求有更改，需要更换样式主题的，也只需在一个地方更改即可</p>\n<h4 id=\"JS\"><a href=\"#JS\" class=\"headerlink\" title=\"JS\"></a>JS</h4><p>通常我们调用后端接口的时候，后端会根据不同情况来返回不同的响应res code，比如<code>0001</code>表示请求成功，正常返回数据，<code>0002</code>表示请求成功，无数据，<code>1000</code>表示请求失败等，显然这里也可以做成配置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CODELIST = [</span><br><span class=\"line\">    <span class=\"string\">'0001'</span>: <span class=\"string\">'suc'</span>,</span><br><span class=\"line\">    <span class=\"string\">'0002'</span>: <span class=\"string\">'no data'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1000'</span>: <span class=\"string\">'error'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">axios.get(<span class=\"string\">'/getData'</span>, &#123;<span class=\"attr\">params</span>: &#123;&#125;&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CODELIST[res.code] === <span class=\"string\">'suc'</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (CODELIST[res.code] === <span class=\"string\">'no data'</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>将返回码映射成文件，与不同项目不同团队对接的时候，也只是修改映射表就搞定了~</p>\n<h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><p>说到组件大家应该也都不陌生了，组件化思想现在更是用得多姿多彩，那么重合的功能业务，我们就可以封装成组件，供不同的页面使用</p>\n<p>比如后台管理端页面，常见的结构就是表单查询+工具栏菜单+表格列表+分页，如果有10个页面（真实情况往往不止），我们是不是要创建10遍重合度90%以上的代码？这个时候要考虑能不能抽离逻辑，做成一个组件，然后往这个组件传参数，来让它实现不同的功能。<a href=\"https://github.com/Ysom/component-tools/tree/master/easy-page\" target=\"_blank\" rel=\"noopener\">esay-page组件源码</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// parent.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;easy-page ref=&quot;easyPage&quot; :formData=&quot;form&quot; :columns=&quot;column&quot;</span><br><span class=\"line\">               :layout=&quot;[&apos;form&apos;, &apos;toolbar&apos;, &apos;table&apos;, &apos;pagination&apos;]&quot; </span><br><span class=\"line\">               :getApi=&quot;getApi&quot;&gt;</span><br><span class=\"line\">    &lt;/easy-page&gt;\t</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\texport default &#123;</span><br><span class=\"line\">        const columns = [</span><br><span class=\"line\">        \t&#123;label: &apos;序号&apos;, prop: &apos;index&apos;&#125;,</span><br><span class=\"line\">        \t&#123;label: &apos;姓名&apos;, prop: &apos;name&apos;&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                form: &#123;&#125;,</span><br><span class=\"line\">                columns,</span><br><span class=\"line\">                getApi: &apos;/getData&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>通过这样一个组件，就可以实现简单的表单查询+工具栏+表格+分页，通过参数也可以控制页面结构。</p>\n<p>还有类似上传功能，element-ui等UI库已经帮我们实现了很多，但是业务往往没有那么简单，我们需要基于已经实现的功能去进行二次封装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// easy-upload.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;el-upload&gt;&lt;/el-upload&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">\texport default &#123;</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            // 二次封装需要的参数</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            return &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// parent.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;easy-upload :setting=&quot;setting&quot;&gt;&lt;/easy-upload&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import EasyUpload from &apos;easy-upload.vue&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tdata () &#123;</span><br><span class=\"line\">\t\treturn &#123;</span><br><span class=\"line\">\t\t\tsetting: &#123;&#125; // 自定义配置</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一次封装，就能在多处进行灵活性更强的使用，而在二次封装的过程中一些逻辑处理，可比搬砖有趣多了</p>\n<h2 id=\"学习数据结构，拓展思维\"><a href=\"#学习数据结构，拓展思维\" class=\"headerlink\" title=\"学习数据结构，拓展思维\"></a>学习数据结构，拓展思维</h2><p>很多前端同事都会在google、百度、知乎等提问，“<strong>前端是否应该学习数据结构</strong>”，“<strong>前端学算法有用吗</strong>”等等问题，我觉得问这种问题，是还没从根本上理解代码存在的意义，每一个开发工程师都是通过代码跟机器打交道的，而数据结构就是数据、代码的一种结构化，是数据组织方法，不学数据结构，不学算法，怎么跟机器进行更深层次的交流？跟机器交流好比跟人沟通，好的语言组织能让我们事半功半，适合的数据结构也能让性能更加优越。</p>\n<p>说到底，我们的业务都是基于各种不同的数据结构来完成的，只不过有一些平时写的逻辑较简单，会忽略了其实也是用到数据结构来实现的，不学数据结构，不学算法，不会知道可以用双端队列来做回文字符串检查，不会知道可以用循环链表来实现小时候爱玩的“击鼓传花”游戏，不会知道撤销、回滚是怎么实现。</p>\n<p>回到总结，数据结构不是学不学的问题，是要往多深学，起码最基本的<code>栈</code>、<code>队列</code>、<code>链表</code>、<code>树</code>、<code>图</code>等都要了解，至于深度，就取决你对自己的要求以及工作中的需求</p>\n<h2 id=\"阅读源码，提高逻辑\"><a href=\"#阅读源码，提高逻辑\" class=\"headerlink\" title=\"阅读源码，提高逻辑\"></a>阅读源码，提高逻辑</h2><p>提高幸福感的另一件事，就是阅读源码了。可能有人会问，啥，阅读源码幸福？不是很痛苦？是的，源码一开始看确实很痛苦，尤其是优秀的项目一般架构比较复杂，想看也不知从何下手，但是我们可以见招拆招，从部分模块看起，比如<code>vue</code>中，可以看双向绑定，可以看响应式设计等等，从某个模块看起，能有效降低源码阅读难度。</p>\n<p>而且一个优秀的框架、库是经过了时间和用户的考验，阅读源码也是我们近距离接触大神的途径，我们可以从源码中看出大神他们的设计思想，思考方法，开发逻辑等等，我们自己创造不了牛逼框架，还学习不了？</p>\n<h2 id=\"关注行情，了解趋势\"><a href=\"#关注行情，了解趋势\" class=\"headerlink\" title=\"关注行情，了解趋势\"></a>关注行情，了解趋势</h2><blockquote>\n<p>当今这个时代，努力奔跑只能保持原地不动，而停滞不前就会逐步落后</p>\n</blockquote>\n<p>前端的发展大家有目共睹，可谓是日新月异，这个时候的我们，只能多多关注技术发展，来扩充自己的眼界，不然别人问起什么是大前端，什么时候是前端微服务，我们都是一脸懵逼，眼界将会决定我们在这条路上能走多远，走多久，如果没有幸福感，没有兴趣支撑我们前进，心越空，越容易被焦虑感填满，我们很容易就会被洪流冲走，心中有方向，前进才不会迷失。</p>\n<h2 id=\"定时review，做一个“铲屎官”\"><a href=\"#定时review，做一个“铲屎官”\" class=\"headerlink\" title=\"定时review，做一个“铲屎官”\"></a>定时review，做一个“铲屎官”</h2><p>最后要讲的一点，不管开发的时候对自己写的代码有多熟悉，都要写上注释，这是为后面自己或者同事review的时候做好前置工作。还有就是要定时对自己的代码做review，或者让朋友、同事帮我们review，因为不管啥时候，我们回过头来看自己的代码，都有一种在看shi的感觉，对吧？而review的过程，就是一个铲屎的过程，手握review铲，哪里有shi铲哪里，老板再也不用担心我巨坑了！一边review一边骂自己当时为啥那么sb，写出这么shi的代码，一边优化提高自己的能力，所以，review可以帮我们更好地认识自己，也能更好地提高自己~</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本篇从几个方面做了提升内在幸福感的总结，也是这一年多来的心得体会，可能总结不是很到位，会有很多遗漏，但就像上面说的，当我以后回过头来看这篇文章的时候，我是在review，是在优化，我还是在继续提升。</p>"},{"title":"响应式原理-vue2.x版（上）","_content":"\n> 10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用**ES5**的`Object.defineProperty`，而新版本3.0则是使用**ES6**的`proxy`\n\n\n\n## 2.x实现原理\n\n在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理：\n\n1. 将一个对象作为data选项（组件是data函数返回对象）\n\n2. 遍历data里面所有的属性，通过`Object.defineProperty`将属性转为**getter/setter**\n\n3. 每个组件都有一个`watcher`，它用来记录接触过的属性，并将其收集为依赖，当依赖的**setter**变更时，通知`watcher`，使与其有关联的组件更新\n\n4. 异步更新\n\n## 初始化data\n\n首先对**data**进行初始化`initData`，代码路径`/src/core/instance/state.js`\n\n<!-- more -->\n\n```javascript\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${key}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) {\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */)\n}\n```\n\ndata的初始化主要做两件事：\n\n1. 对data的所有属性遍历，先检查属性是否已定义为**method**或**prop**，否则通过一个**proxy函数**（不是ES6的proxy），把`vm._data.xxx`代理到`vm.xxx`\n2. 调用**observe**实现对data的监测，把data变成响应式\n\n下面先看自定义的代理函数proxy\n\n### 代理函数proxy\n\n```javascript\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n}\n\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n\n```\n\nproxy函数的作用是通过`Object.defineProperty`，将`target[sourceKey][key]`的读写变成`target[key]`的读写。而`vm._prop.xxx`、`vm._data.xxx`可以访问到`props`、`data`里面的属性，因此通过proxy函数之后，`vm._prop.xxx`、`vm._data.xxx`就变成`vm.xxx`的读写了，这也是为什么props的属性和data的属性一样，可以通过`vm.xxx`来访问。\n\n### observe\n\n**observe**的作用是监测数据的变化，代码路径`/src/core/observer/index.js`\n\n```javascript\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob: Observer | void\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n    ob.vmCount++\n  }\n  return ob\n}\n```\n\n### Observer\n\n代码路径`/src/core/observer/index.js`\n\n```javascript\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nexport class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that have this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    // 实例化Dep对象\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 将自身属性添加到value对象的__ob__属性  \n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n```\n\n在**Observer**的构造函数里，先实例化一个`Dep`对象，用`def`函数（defineProperty的迷你版），将自身实例添加到value对象的`__ob__`属性，接下来判断value是数组还是对象，如果是数组，则调用`observeArray`，如果是对象，则调用`walk`函数。\n\n接下来看一下`defineReactive`这个函数，代码路径`/src/core/observer/index.js`\n\n### defineReactive\n\n```javascript\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  // 实例化Dep对象\n  const dep = new Dep()\n  // 获取对象属性描述符\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n```\n\n从代码可以看到，**defineReactive**先实例化一个`Dep`对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用`observe`方法，确保每个属性都能被监测到，最后通过`defineProperty`给属性加上用于**收集依赖**的`getter`和**派发更新**的`setter`。\n\n到了这里，**data**的初始化已经完成，后面接着对**收集依赖**和**派发更新**做分析。\n\n\n\n","source":"_posts/响应式原理-2.x版本（上）.md","raw":"---\ntitle: 响应式原理-vue2.x版（上）\ncategories:\n - 前端\ntags:\n - 源码\n - vue\n---\n\n> 10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用**ES5**的`Object.defineProperty`，而新版本3.0则是使用**ES6**的`proxy`\n\n\n\n## 2.x实现原理\n\n在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理：\n\n1. 将一个对象作为data选项（组件是data函数返回对象）\n\n2. 遍历data里面所有的属性，通过`Object.defineProperty`将属性转为**getter/setter**\n\n3. 每个组件都有一个`watcher`，它用来记录接触过的属性，并将其收集为依赖，当依赖的**setter**变更时，通知`watcher`，使与其有关联的组件更新\n\n4. 异步更新\n\n## 初始化data\n\n首先对**data**进行初始化`initData`，代码路径`/src/core/instance/state.js`\n\n<!-- more -->\n\n```javascript\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  const methods = vm.$options.methods\n  let i = keys.length\n  while (i--) {\n    const key = keys[i]\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a data property.`,\n          vm\n        )\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${key}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else if (!isReserved(key)) {\n      proxy(vm, `_data`, key)\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */)\n}\n```\n\ndata的初始化主要做两件事：\n\n1. 对data的所有属性遍历，先检查属性是否已定义为**method**或**prop**，否则通过一个**proxy函数**（不是ES6的proxy），把`vm._data.xxx`代理到`vm.xxx`\n2. 调用**observe**实现对data的监测，把data变成响应式\n\n下面先看自定义的代理函数proxy\n\n### 代理函数proxy\n\n```javascript\nconst sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n}\n\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n\n```\n\nproxy函数的作用是通过`Object.defineProperty`，将`target[sourceKey][key]`的读写变成`target[key]`的读写。而`vm._prop.xxx`、`vm._data.xxx`可以访问到`props`、`data`里面的属性，因此通过proxy函数之后，`vm._prop.xxx`、`vm._data.xxx`就变成`vm.xxx`的读写了，这也是为什么props的属性和data的属性一样，可以通过`vm.xxx`来访问。\n\n### observe\n\n**observe**的作用是监测数据的变化，代码路径`/src/core/observer/index.js`\n\n```javascript\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob: Observer | void\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n    ob.vmCount++\n  }\n  return ob\n}\n```\n\n### Observer\n\n代码路径`/src/core/observer/index.js`\n\n```javascript\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nexport class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that have this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    // 实例化Dep对象\n    this.dep = new Dep()\n    this.vmCount = 0\n    // 将自身属性添加到value对象的__ob__属性  \n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n```\n\n在**Observer**的构造函数里，先实例化一个`Dep`对象，用`def`函数（defineProperty的迷你版），将自身实例添加到value对象的`__ob__`属性，接下来判断value是数组还是对象，如果是数组，则调用`observeArray`，如果是对象，则调用`walk`函数。\n\n接下来看一下`defineReactive`这个函数，代码路径`/src/core/observer/index.js`\n\n### defineReactive\n\n```javascript\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  // 实例化Dep对象\n  const dep = new Dep()\n  // 获取对象属性描述符\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n```\n\n从代码可以看到，**defineReactive**先实例化一个`Dep`对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用`observe`方法，确保每个属性都能被监测到，最后通过`defineProperty`给属性加上用于**收集依赖**的`getter`和**派发更新**的`setter`。\n\n到了这里，**data**的初始化已经完成，后面接着对**收集依赖**和**派发更新**做分析。\n\n\n\n","slug":"响应式原理-2.x版本（上）","published":1,"date":"2019-10-11T02:24:10.505Z","updated":"2019-10-12T06:30:18.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4n4002shsuhez2slld4","content":"<blockquote>\n<p>10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用<strong>ES5</strong>的<code>Object.defineProperty</code>，而新版本3.0则是使用<strong>ES6</strong>的<code>proxy</code></p>\n</blockquote>\n<h2 id=\"2-x实现原理\"><a href=\"#2-x实现原理\" class=\"headerlink\" title=\"2.x实现原理\"></a>2.x实现原理</h2><p>在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理：</p>\n<ol>\n<li><p>将一个对象作为data选项（组件是data函数返回对象）</p>\n</li>\n<li><p>遍历data里面所有的属性，通过<code>Object.defineProperty</code>将属性转为<strong>getter/setter</strong></p>\n</li>\n<li><p>每个组件都有一个<code>watcher</code>，它用来记录接触过的属性，并将其收集为依赖，当依赖的<strong>setter</strong>变更时，通知<code>watcher</code>，使与其有关联的组件更新</p>\n</li>\n<li><p>异步更新</p>\n</li>\n</ol>\n<h2 id=\"初始化data\"><a href=\"#初始化data\" class=\"headerlink\" title=\"初始化data\"></a>初始化data</h2><p>首先对<strong>data</strong>进行初始化<code>initData</code>，代码路径<code>/src/core/instance/state.js</code></p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initData</span> (<span class=\"hljs-params\">vm: Component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> data = vm.$options.data</span><br><span class=\"line\">  data = vm._data = <span class=\"hljs-keyword\">typeof</span> data === <span class=\"hljs-string\">'function'</span></span><br><span class=\"line\">    ? getData(data, vm)</span><br><span class=\"line\">    : data || &#123;&#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!isPlainObject(data)) &#123;</span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span> &amp;&amp; warn(</span><br><span class=\"line\">      <span class=\"hljs-string\">'data functions should return an object:\\n'</span> +</span><br><span class=\"line\">      <span class=\"hljs-string\">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class=\"line\">      vm</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// proxy data on instance</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-built_in\">Object</span>.keys(data)</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> props = vm.$options.props</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> methods = vm.$options.methods</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> i = keys.length</span><br><span class=\"line\">  <span class=\"hljs-keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> key = keys[i]</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"hljs-string\">`Method \"<span class=\"hljs-subst\">$&#123;key&#125;</span>\" has already been defined as a data property.`</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class=\"line\">      process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span> &amp;&amp; warn(</span><br><span class=\"line\">        <span class=\"hljs-string\">`The data property \"<span class=\"hljs-subst\">$&#123;key&#125;</span>\" is already declared as a prop. `</span> +</span><br><span class=\"line\">        <span class=\"hljs-string\">`Use prop default value instead.`</span>,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!isReserved(key)) &#123;</span><br><span class=\"line\">      proxy(vm, <span class=\"hljs-string\">`_data`</span>, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// observe data</span></span><br><span class=\"line\">  observe(data, <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\">/* asRootData */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>data的初始化主要做两件事：</p>\n<ol>\n<li>对data的所有属性遍历，先检查属性是否已定义为<strong>method</strong>或<strong>prop</strong>，否则通过一个<strong>proxy函数</strong>（不是ES6的proxy），把<code>vm._data.xxx</code>代理到<code>vm.xxx</code></li>\n<li>调用<strong>observe</strong>实现对data的监测，把data变成响应式</li>\n</ol>\n<p>下面先看自定义的代理函数proxy</p>\n<h3 id=\"代理函数proxy\"><a href=\"#代理函数proxy\" class=\"headerlink\" title=\"代理函数proxy\"></a>代理函数proxy</h3><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> sharedPropertyDefinition = &#123;</span><br><span class=\"line\">  enumerable: <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">  configurable: <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">  <span class=\"hljs-keyword\">get</span>: noop,</span><br><span class=\"line\">  <span class=\"hljs-keyword\">set</span>: noop</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class=\"line\">  sharedPropertyDefinition.get = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">proxyGetter</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>[sourceKey][key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sharedPropertyDefinition.set = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">proxySetter</span> (<span class=\"hljs-params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>[sourceKey][key] = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>proxy函数的作用是通过<code>Object.defineProperty</code>，将<code>target[sourceKey][key]</code>的读写变成<code>target[key]</code>的读写。而<code>vm._prop.xxx</code>、<code>vm._data.xxx</code>可以访问到<code>props</code>、<code>data</code>里面的属性，因此通过proxy函数之后，<code>vm._prop.xxx</code>、<code>vm._data.xxx</code>就变成<code>vm.xxx</code>的读写了，这也是为什么props的属性和data的属性一样，可以通过<code>vm.xxx</code>来访问。</p>\n<h3 id=\"observe\"><a href=\"#observe\" class=\"headerlink\" title=\"observe\"></a>observe</h3><p><strong>observe</strong>的作用是监测数据的变化，代码路径<code>/src/core/observer/index.js</code></p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">observe</span> (<span class=\"hljs-params\">value: any, asRootData: ?boolean</span>): <span class=\"hljs-title\">Observer</span> | <span class=\"hljs-title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (!isObject(value) || value <span class=\"hljs-keyword\">instanceof</span> VNode) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> ob: Observer | <span class=\"hljs-keyword\">void</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (hasOwn(value, <span class=\"hljs-string\">'__ob__'</span>) &amp;&amp; value.__ob__ <span class=\"hljs-keyword\">instanceof</span> Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (</span><br><span class=\"line\">    shouldObserve &amp;&amp;</span><br><span class=\"line\">    !isServerRendering() &amp;&amp;</span><br><span class=\"line\">    (<span class=\"hljs-built_in\">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class=\"line\">    <span class=\"hljs-built_in\">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class=\"line\">    !value._isVue</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = <span class=\"hljs-keyword\">new</span> Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\">    ob.vmCount++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h3><p>代码路径<code>/src/core/observer/index.js</code></p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * Observer class that is attached to each observed</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * object. Once attached, the observer converts the target</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * object's property keys into getter/setters that</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * collect dependencies and dispatch updates.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\">  vmCount: number; <span class=\"hljs-comment\">// number of vms that have this object as root $data</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">constructor</span> (value: any) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 实例化Dep对象</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.dep = <span class=\"hljs-keyword\">new</span> Dep()</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.vmCount = <span class=\"hljs-number\">0</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// 将自身属性添加到value对象的__ob__属性  </span></span><br><span class=\"line\">    def(value, <span class=\"hljs-string\">'__ob__'</span>, <span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (hasProto) &#123;</span><br><span class=\"line\">        protoAugment(value, arrayMethods)</span><br><span class=\"line\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.observeArray(value)</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * Walk through all properties and convert them into</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * getter/setters. This method should only be called when</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * value type is Object.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   */</span></span><br><span class=\"line\">  walk (obj: <span class=\"hljs-built_in\">Object</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * Observe a list of Array items.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   */</span></span><br><span class=\"line\">  observeArray (items: <span class=\"hljs-built_in\">Array</span>&lt;any&gt;) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<strong>Observer</strong>的构造函数里，先实例化一个<code>Dep</code>对象，用<code>def</code>函数（defineProperty的迷你版），将自身实例添加到value对象的<code>__ob__</code>属性，接下来判断value是数组还是对象，如果是数组，则调用<code>observeArray</code>，如果是对象，则调用<code>walk</code>函数。</p>\n<p>接下来看一下<code>defineReactive</code>这个函数，代码路径<code>/src/core/observer/index.js</code></p>\n<h3 id=\"defineReactive\"><a href=\"#defineReactive\" class=\"headerlink\" title=\"defineReactive\"></a>defineReactive</h3><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * Define a reactive property on an Object.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineReactive</span> (<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  obj: Object,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  key: string,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  val: any,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  customSetter?: ?Function,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  shallow?: boolean</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 实例化Dep对象</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> Dep()</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 获取对象属性描述符</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> property = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (property &amp;&amp; property.configurable === <span class=\"hljs-literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// cater for pre-defined getter/setters</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> getter = property &amp;&amp; property.get</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> setter = property &amp;&amp; property.set</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> ((!getter || setter) &amp;&amp; <span class=\"hljs-built_in\">arguments</span>.length === <span class=\"hljs-number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">    <span class=\"hljs-keyword\">get</span>: function reactiveGetter () &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"hljs-keyword\">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"hljs-comment\">/* eslint-disable no-self-compare */</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-comment\">/* eslint-enable no-self-compare */</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// #7981: for accessor properties without setter</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (getter &amp;&amp; !setter) <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (setter) &#123;</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码可以看到，<strong>defineReactive</strong>先实例化一个<code>Dep</code>对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用<code>observe</code>方法，确保每个属性都能被监测到，最后通过<code>defineProperty</code>给属性加上用于<strong>收集依赖</strong>的<code>getter</code>和<strong>派发更新</strong>的<code>setter</code>。</p>\n<p>到了这里，<strong>data</strong>的初始化已经完成，后面接着对<strong>收集依赖</strong>和<strong>派发更新</strong>做分析。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用<strong>ES5</strong>的<code>Object.defineProperty</code>，而新版本3.0则是使用<strong>ES6</strong>的<code>proxy</code></p>\n</blockquote>\n<h2 id=\"2-x实现原理\"><a href=\"#2-x实现原理\" class=\"headerlink\" title=\"2.x实现原理\"></a>2.x实现原理</h2><p>在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理：</p>\n<ol>\n<li><p>将一个对象作为data选项（组件是data函数返回对象）</p>\n</li>\n<li><p>遍历data里面所有的属性，通过<code>Object.defineProperty</code>将属性转为<strong>getter/setter</strong></p>\n</li>\n<li><p>每个组件都有一个<code>watcher</code>，它用来记录接触过的属性，并将其收集为依赖，当依赖的<strong>setter</strong>变更时，通知<code>watcher</code>，使与其有关联的组件更新</p>\n</li>\n<li><p>异步更新</p>\n</li>\n</ol>\n<h2 id=\"初始化data\"><a href=\"#初始化data\" class=\"headerlink\" title=\"初始化data\"></a>初始化data</h2><p>首先对<strong>data</strong>进行初始化<code>initData</code>，代码路径<code>/src/core/instance/state.js</code></p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initData</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = vm.$options.data</span><br><span class=\"line\">  data = vm._data = <span class=\"keyword\">typeof</span> data === <span class=\"string\">'function'</span></span><br><span class=\"line\">    ? getData(data, vm)</span><br><span class=\"line\">    : data || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isPlainObject(data)) &#123;</span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; warn(</span><br><span class=\"line\">      <span class=\"string\">'data functions should return an object:\\n'</span> +</span><br><span class=\"line\">      <span class=\"string\">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class=\"line\">      vm</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// proxy data on instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(data)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> props = vm.$options.props</span><br><span class=\"line\">  <span class=\"keyword\">const</span> methods = vm.$options.methods</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = keys.length</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = keys[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">`Method \"<span class=\"subst\">$&#123;key&#125;</span>\" has already been defined as a data property.`</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class=\"line\">      process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; warn(</span><br><span class=\"line\">        <span class=\"string\">`The data property \"<span class=\"subst\">$&#123;key&#125;</span>\" is already declared as a prop. `</span> +</span><br><span class=\"line\">        <span class=\"string\">`Use prop default value instead.`</span>,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isReserved(key)) &#123;</span><br><span class=\"line\">      proxy(vm, <span class=\"string\">`_data`</span>, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// observe data</span></span><br><span class=\"line\">  observe(data, <span class=\"literal\">true</span> <span class=\"comment\">/* asRootData */</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>data的初始化主要做两件事：</p>\n<ol>\n<li>对data的所有属性遍历，先检查属性是否已定义为<strong>method</strong>或<strong>prop</strong>，否则通过一个<strong>proxy函数</strong>（不是ES6的proxy），把<code>vm._data.xxx</code>代理到<code>vm.xxx</code></li>\n<li>调用<strong>observe</strong>实现对data的监测，把data变成响应式</li>\n</ol>\n<p>下面先看自定义的代理函数proxy</p>\n<h3 id=\"代理函数proxy\"><a href=\"#代理函数proxy\" class=\"headerlink\" title=\"代理函数proxy\"></a>代理函数proxy</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sharedPropertyDefinition = &#123;</span><br><span class=\"line\">  enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: noop,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: noop</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class=\"line\">  sharedPropertyDefinition.get = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxyGetter</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>[sourceKey][key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sharedPropertyDefinition.set = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxySetter</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>[sourceKey][key] = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>proxy函数的作用是通过<code>Object.defineProperty</code>，将<code>target[sourceKey][key]</code>的读写变成<code>target[key]</code>的读写。而<code>vm._prop.xxx</code>、<code>vm._data.xxx</code>可以访问到<code>props</code>、<code>data</code>里面的属性，因此通过proxy函数之后，<code>vm._prop.xxx</code>、<code>vm._data.xxx</code>就变成<code>vm.xxx</code>的读写了，这也是为什么props的属性和data的属性一样，可以通过<code>vm.xxx</code>来访问。</p>\n<h3 id=\"observe\"><a href=\"#observe\" class=\"headerlink\" title=\"observe\"></a>observe</h3><p><strong>observe</strong>的作用是监测数据的变化，代码路径<code>/src/core/observer/index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span> (<span class=\"params\">value: any, asRootData: ?boolean</span>): <span class=\"title\">Observer</span> | <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(value) || value <span class=\"keyword\">instanceof</span> VNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ob: Observer | <span class=\"keyword\">void</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasOwn(value, <span class=\"string\">'__ob__'</span>) &amp;&amp; value.__ob__ <span class=\"keyword\">instanceof</span> Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    shouldObserve &amp;&amp;</span><br><span class=\"line\">    !isServerRendering() &amp;&amp;</span><br><span class=\"line\">    (<span class=\"built_in\">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class=\"line\">    !value._isVue</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = <span class=\"keyword\">new</span> Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\">    ob.vmCount++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h3><p>代码路径<code>/src/core/observer/index.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Observer class that is attached to each observed</span></span><br><span class=\"line\"><span class=\"comment\"> * object. Once attached, the observer converts the target</span></span><br><span class=\"line\"><span class=\"comment\"> * object's property keys into getter/setters that</span></span><br><span class=\"line\"><span class=\"comment\"> * collect dependencies and dispatch updates.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\">  vmCount: number; <span class=\"comment\">// number of vms that have this object as root $data</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value: any) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"comment\">// 实例化Dep对象</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vmCount = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 将自身属性添加到value对象的__ob__属性  </span></span><br><span class=\"line\">    def(value, <span class=\"string\">'__ob__'</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (hasProto) &#123;</span><br><span class=\"line\">        protoAugment(value, arrayMethods)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.observeArray(value)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Walk through all properties and convert them into</span></span><br><span class=\"line\"><span class=\"comment\">   * getter/setters. This method should only be called when</span></span><br><span class=\"line\"><span class=\"comment\">   * value type is Object.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  walk (obj: <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Observe a list of Array items.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  observeArray (items: <span class=\"built_in\">Array</span>&lt;any&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<strong>Observer</strong>的构造函数里，先实例化一个<code>Dep</code>对象，用<code>def</code>函数（defineProperty的迷你版），将自身实例添加到value对象的<code>__ob__</code>属性，接下来判断value是数组还是对象，如果是数组，则调用<code>observeArray</code>，如果是对象，则调用<code>walk</code>函数。</p>\n<p>接下来看一下<code>defineReactive</code>这个函数，代码路径<code>/src/core/observer/index.js</code></p>\n<h3 id=\"defineReactive\"><a href=\"#defineReactive\" class=\"headerlink\" title=\"defineReactive\"></a>defineReactive</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Define a reactive property on an Object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  obj: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  val: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  customSetter?: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  shallow?: boolean</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实例化Dep对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep()</span><br><span class=\"line\">  <span class=\"comment\">// 获取对象属性描述符</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> property = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (property &amp;&amp; property.configurable === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// cater for pre-defined getter/setters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getter = property &amp;&amp; property.get</span><br><span class=\"line\">  <span class=\"keyword\">const</span> setter = property &amp;&amp; property.set</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((!getter || setter) &amp;&amp; <span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function reactiveGetter () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"comment\">/* eslint-disable no-self-compare */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">/* eslint-enable no-self-compare */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// #7981: for accessor properties without setter</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (getter &amp;&amp; !setter) <span class=\"keyword\">return</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (setter) &#123;</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码可以看到，<strong>defineReactive</strong>先实例化一个<code>Dep</code>对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用<code>observe</code>方法，确保每个属性都能被监测到，最后通过<code>defineProperty</code>给属性加上用于<strong>收集依赖</strong>的<code>getter</code>和<strong>派发更新</strong>的<code>setter</code>。</p>\n<p>到了这里，<strong>data</strong>的初始化已经完成，后面接着对<strong>收集依赖</strong>和<strong>派发更新</strong>做分析。</p>"},{"title":"响应式原理-2.x版本（下）","_content":"\n上一篇分析了**data**的初始化过程以及做的一些操作，这一篇分析**依赖收集**和**派发更新**。\n\n## 依赖收集\n\n先看下`getter`的代码\n\n<!-- more -->\n\n```javascript\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    // 重点看get这部分  \n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    // ...\n  })\n}\n```\n\n在`getter`的逻辑里面，关键的两步是`const dep = new Dep()`和`dep.depend()`，第一步是实例化一个`Dep`实例，第二步就是实现依赖收集。\n\n先看第一步，`Dep`的实现，代码路径`/src/core/observer/dep.js`\n\n### Dep\n\n```javascript\nimport type Watcher from './watcher'\nimport { remove } from '../util/index'\n\nlet uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n  // 添加观察者\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n  // 移除观察者\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n  // 依赖收集 存在target时添加观察者对象\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n  // 派发更新 省略 下面有用到\n  notify () {\n    // ...\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget (_target: ?Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n```\n\n可以看到，`Dep`是对`subs`数组的操作，而`subs`是`watcher`数组，所以`Dep`其实是对`watchers`的管理。\n\n接着看watcher的逻辑，代码路径`/src/core/observer/watcher.js`\n\n### Watcher\n\n```javascript\nlet uid = 0\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nexport default class Watcher {\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;  \n  // 此处省略一堆类型声明, 具体在源码查看\n  // ...\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.computed = !!options.computed\n      this.sync = !!options.sync\n      this.before = options.before\n    } else {\n      this.deep = this.user = this.computed = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.computed // for computed watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    if (this.computed) {\n      this.value = undefined\n      this.dep = new Dep()\n    } else {\n      this.value = this.get()\n    }\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  get () {\n    // 入栈 缓存Watcher  \n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      // 触发依赖收集\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        // 递归对象或数组 触发getter  \n        traverse(value)\n      }\n      // 出栈 恢复Watcher\n      popTarget()\n      // 清除不需要的依赖 逻辑实现在下面\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n  // 后面省略\n  // ...\n}\n```\n\n从代码可以看到，实例化一个`Watcher`时，会执行`get`函数，通过`pushTarget(this)`将当前`Watcher`入栈，然后又执行`this.getter.call(vm, vm)`，这里的`getter`对应了`updateComponent` 函数，这里会执行一句关键代码`vm._update(vm._render(), hydrating)`，`vm._render()`会访问`vm`上面的数据，这里就会触发所有数据的getter，完成依赖收集。\n\n触发依赖收集之后，根据上面代码里的注释，`vue`还做了三步操作\n\n1. 如果存在`deep`属性，说明存在**深度依赖关系**，采用**递归**进行依赖收集\n2. 执行`popTarget()`出栈，恢复`watcher`成上一状态\n3. 完成新订阅，执行`cleanupDeps()`，清除旧订阅，也就是清除旧依赖\n\n## 派发更新\n\n看下`setter`代码\n\n```javascript\nset: function reactiveSetter (newVal) {\n    const value = getter ? getter.call(obj) : val\n    /* eslint-disable no-self-compare */\n    if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n    }\n    /* eslint-enable no-self-compare */\n    if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n    }\n    // #7981: for accessor properties without setter\n    if (getter && !setter) return\n    if (setter) {\n        setter.call(obj, newVal)\n    } else {\n        val = newVal\n    }\n    // shallow为false时 将新值设置成响应式对象\n    childOb = !shallow && observe(newVal)\n    // 通知订阅者\n    dep.notify()\n}\n```\n\n值发生变化时，会调用`dep`的`notify`方法，看下`Dep`对`notify`的定义\n\n```javascript\n// 派发更新\nnotify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n        subs[i].update()\n    }\n}\n```\n\n这里调用了每个`watcher`的`update`方法\n\n```javascript\nupdate () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n        this.dirty = true\n    // 同步时执行\n    } else if (this.sync) {\n        this.run()\n    // 推送到观察者队列    \n    } else {\n        queueWatcher(this)\n    }\n}\n```\n\n这里关注`run`和`queueWatcher`\n\n### run\n\n```javascript\n// run 定义在watcher里面\n/**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        this.value = value\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n```\n\n`run`的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有`deep`等判断，满足其中之一就进行回调，而在通过`this.get()`拿值的时候，就会触发执行`getter`，这也是响应式数据修改时触发渲染的原因。\n\n### queueWatcher\n\n代码路径 `src/core/observer/scheduler.js` \n\n```javascript\nconst queue: Array<Watcher> = []\nconst activatedChildren: Array<Component> = []\nlet has: { [key: number]: ?true } = {}\nlet circular: { [key: number]: number } = {}\nlet waiting = false\nlet flushing = false\nlet index = 0\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  // 保证每个watcher只会被添加一次\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      // 同步\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue()\n        return\n      }\n      // 在下一个tick 异步执行flushSchedulerQueue\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\n```\n\n`vue`在派发更新的时候使用了**队列**，这样做的好处就是每次数据改变时不会马上触发`watcher`的回调，会先将`watcher`添加到队列里，然后在`nextTick`后执行`flushSchedulerQueue`\n\n### flushSchedulerQueue\n\n代码路径 `src/core/observer/scheduler.js` \n\n```javascript\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow()\n  flushing = true\n  let watcher, id\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  // 队列排序 原因如上注释\n  queue.sort((a, b) => a.id - b.id)\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  // 队列遍历  \n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before()\n    }\n    id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? `in watcher with expression \"${watcher.expression}\"`\n              : `in a component render function.`\n          ),\n          watcher.vm\n        )\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  const activatedQueue = activatedChildren.slice()\n  const updatedQueue = queue.slice()\n\n  resetSchedulerState()\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue)\n  callUpdatedHooks(updatedQueue)\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush')\n  }\n}\n```\n\n`flushSchedulerQueue`在这里做了两件事，**队列排序**和**队列遍历**。\n\n队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。\n\n然后对排序后的队列进行遍历，拿到`watcher`执行`run`方法，`run`已在上面分析。\n\n## 结语\n\n通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了`proxy`来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~\n\n","source":"_posts/响应式原理-2.x版本（下）.md","raw":"---\ntitle: 响应式原理-2.x版本（下）\ncategories:\n - 前端\ntags:\n - 源码\n - vue\n---\n\n上一篇分析了**data**的初始化过程以及做的一些操作，这一篇分析**依赖收集**和**派发更新**。\n\n## 依赖收集\n\n先看下`getter`的代码\n\n<!-- more -->\n\n```javascript\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: ?Function,\n  shallow?: boolean\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    // 重点看get这部分  \n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    // ...\n  })\n}\n```\n\n在`getter`的逻辑里面，关键的两步是`const dep = new Dep()`和`dep.depend()`，第一步是实例化一个`Dep`实例，第二步就是实现依赖收集。\n\n先看第一步，`Dep`的实现，代码路径`/src/core/observer/dep.js`\n\n### Dep\n\n```javascript\nimport type Watcher from './watcher'\nimport { remove } from '../util/index'\n\nlet uid = 0\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n  // 添加观察者\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n  // 移除观察者\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n  // 依赖收集 存在target时添加观察者对象\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n  // 派发更新 省略 下面有用到\n  notify () {\n    // ...\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget (_target: ?Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\n```\n\n可以看到，`Dep`是对`subs`数组的操作，而`subs`是`watcher`数组，所以`Dep`其实是对`watchers`的管理。\n\n接着看watcher的逻辑，代码路径`/src/core/observer/watcher.js`\n\n### Watcher\n\n```javascript\nlet uid = 0\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nexport default class Watcher {\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;  \n  // 此处省略一堆类型声明, 具体在源码查看\n  // ...\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.computed = !!options.computed\n      this.sync = !!options.sync\n      this.before = options.before\n    } else {\n      this.deep = this.user = this.computed = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.computed // for computed watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    if (this.computed) {\n      this.value = undefined\n      this.dep = new Dep()\n    } else {\n      this.value = this.get()\n    }\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  get () {\n    // 入栈 缓存Watcher  \n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      // 触发依赖收集\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        // 递归对象或数组 触发getter  \n        traverse(value)\n      }\n      // 出栈 恢复Watcher\n      popTarget()\n      // 清除不需要的依赖 逻辑实现在下面\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n  // 后面省略\n  // ...\n}\n```\n\n从代码可以看到，实例化一个`Watcher`时，会执行`get`函数，通过`pushTarget(this)`将当前`Watcher`入栈，然后又执行`this.getter.call(vm, vm)`，这里的`getter`对应了`updateComponent` 函数，这里会执行一句关键代码`vm._update(vm._render(), hydrating)`，`vm._render()`会访问`vm`上面的数据，这里就会触发所有数据的getter，完成依赖收集。\n\n触发依赖收集之后，根据上面代码里的注释，`vue`还做了三步操作\n\n1. 如果存在`deep`属性，说明存在**深度依赖关系**，采用**递归**进行依赖收集\n2. 执行`popTarget()`出栈，恢复`watcher`成上一状态\n3. 完成新订阅，执行`cleanupDeps()`，清除旧订阅，也就是清除旧依赖\n\n## 派发更新\n\n看下`setter`代码\n\n```javascript\nset: function reactiveSetter (newVal) {\n    const value = getter ? getter.call(obj) : val\n    /* eslint-disable no-self-compare */\n    if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n    }\n    /* eslint-enable no-self-compare */\n    if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n    }\n    // #7981: for accessor properties without setter\n    if (getter && !setter) return\n    if (setter) {\n        setter.call(obj, newVal)\n    } else {\n        val = newVal\n    }\n    // shallow为false时 将新值设置成响应式对象\n    childOb = !shallow && observe(newVal)\n    // 通知订阅者\n    dep.notify()\n}\n```\n\n值发生变化时，会调用`dep`的`notify`方法，看下`Dep`对`notify`的定义\n\n```javascript\n// 派发更新\nnotify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n        subs[i].update()\n    }\n}\n```\n\n这里调用了每个`watcher`的`update`方法\n\n```javascript\nupdate () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n        this.dirty = true\n    // 同步时执行\n    } else if (this.sync) {\n        this.run()\n    // 推送到观察者队列    \n    } else {\n        queueWatcher(this)\n    }\n}\n```\n\n这里关注`run`和`queueWatcher`\n\n### run\n\n```javascript\n// run 定义在watcher里面\n/**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        this.value = value\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n```\n\n`run`的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有`deep`等判断，满足其中之一就进行回调，而在通过`this.get()`拿值的时候，就会触发执行`getter`，这也是响应式数据修改时触发渲染的原因。\n\n### queueWatcher\n\n代码路径 `src/core/observer/scheduler.js` \n\n```javascript\nconst queue: Array<Watcher> = []\nconst activatedChildren: Array<Component> = []\nlet has: { [key: number]: ?true } = {}\nlet circular: { [key: number]: number } = {}\nlet waiting = false\nlet flushing = false\nlet index = 0\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nexport function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  // 保证每个watcher只会被添加一次\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n      // 同步\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue()\n        return\n      }\n      // 在下一个tick 异步执行flushSchedulerQueue\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\n```\n\n`vue`在派发更新的时候使用了**队列**，这样做的好处就是每次数据改变时不会马上触发`watcher`的回调，会先将`watcher`添加到队列里，然后在`nextTick`后执行`flushSchedulerQueue`\n\n### flushSchedulerQueue\n\n代码路径 `src/core/observer/scheduler.js` \n\n```javascript\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow()\n  flushing = true\n  let watcher, id\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  // 队列排序 原因如上注释\n  queue.sort((a, b) => a.id - b.id)\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  // 队列遍历  \n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before()\n    }\n    id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? `in watcher with expression \"${watcher.expression}\"`\n              : `in a component render function.`\n          ),\n          watcher.vm\n        )\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  const activatedQueue = activatedChildren.slice()\n  const updatedQueue = queue.slice()\n\n  resetSchedulerState()\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue)\n  callUpdatedHooks(updatedQueue)\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush')\n  }\n}\n```\n\n`flushSchedulerQueue`在这里做了两件事，**队列排序**和**队列遍历**。\n\n队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。\n\n然后对排序后的队列进行遍历，拿到`watcher`执行`run`方法，`run`已在上面分析。\n\n## 结语\n\n通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了`proxy`来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~\n\n","slug":"响应式原理-2.x版本（下）","published":1,"date":"2019-10-14T05:41:22.699Z","updated":"2020-01-21T03:25:32.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfauc4n6002uhsuhnobuob6o","content":"<p>上一篇分析了<strong>data</strong>的初始化过程以及做的一些操作，这一篇分析<strong>依赖收集</strong>和<strong>派发更新</strong>。</p>\n<h2 id=\"依赖收集\"><a href=\"#依赖收集\" class=\"headerlink\" title=\"依赖收集\"></a>依赖收集</h2><p>先看下<code>getter</code>的代码</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineReactive</span> (<span class=\"hljs-params\"></span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  obj: Object,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  key: string,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  val: any,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  customSetter?: ?Function,</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\">  shallow?: boolean</span></span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> Dep()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> property = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (property &amp;&amp; property.configurable === <span class=\"hljs-literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// cater for pre-defined getter/setters</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> getter = property &amp;&amp; property.get</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> setter = property &amp;&amp; property.set</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> ((!getter || setter) &amp;&amp; <span class=\"hljs-built_in\">arguments</span>.length === <span class=\"hljs-number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class=\"line\">  <span class=\"hljs-built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"hljs-literal\">true</span>,</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 重点看get这部分  </span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">get</span>: function reactiveGetter () &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"hljs-comment\">// ...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>getter</code>的逻辑里面，关键的两步是<code>const dep = new Dep()</code>和<code>dep.depend()</code>，第一步是实例化一个<code>Dep</code>实例，第二步就是实现依赖收集。</p>\n<p>先看第一步，<code>Dep</code>的实现，代码路径<code>/src/core/observer/dep.js</code></p>\n<h3 id=\"Dep\"><a href=\"#Dep\" class=\"headerlink\" title=\"Dep\"></a>Dep</h3><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> type Watcher <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./watcher'</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">import</span> &#123; remove &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../util/index'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> uid = <span class=\"hljs-number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * A dep is an observable that can have multiple</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * directives subscribing to it.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dep</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">static</span> target: ?Watcher;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  subs: <span class=\"hljs-built_in\">Array</span>&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.id = uid++</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 添加观察者</span></span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 移除观察者</span></span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(<span class=\"hljs-keyword\">this</span>.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 依赖收集 存在target时添加观察者对象</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(<span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 派发更新 省略 下面有用到</span></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// the current target watcher being evaluated.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// this is globally unique because there could be only one</span></span><br><span class=\"line\"><span class=\"hljs-comment\">// watcher being evaluated at any time.</span></span><br><span class=\"line\">Dep.target = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> targetStack = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pushTarget</span> (<span class=\"hljs-params\">_target: ?Watcher</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class=\"line\">  Dep.target = _target</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">popTarget</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  Dep.target = targetStack.pop()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，<code>Dep</code>是对<code>subs</code>数组的操作，而<code>subs</code>是<code>watcher</code>数组，所以<code>Dep</code>其实是对<code>watchers</code>的管理。</p>\n<p>接着看watcher的逻辑，代码路径<code>/src/core/observer/watcher.js</code></p>\n<h3 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a>Watcher</h3><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> uid = <span class=\"hljs-number\">0</span></span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * A watcher parses an expression, collects dependencies,</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * and fires callback when the expression value changes.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * This is used for both the $watch() api and directives.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">  deps: <span class=\"hljs-built_in\">Array</span>&lt;Dep&gt;;</span><br><span class=\"line\">  newDeps: <span class=\"hljs-built_in\">Array</span>&lt;Dep&gt;;  </span><br><span class=\"line\">  <span class=\"hljs-comment\">// 此处省略一堆类型声明, 具体在源码查看</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-keyword\">constructor</span> (</span><br><span class=\"line\">    vm: Component,</span><br><span class=\"line\">    expOrFn: string | Function,</span><br><span class=\"line\">    cb: Function,</span><br><span class=\"line\">    options?: ?Object,</span><br><span class=\"line\">    isRenderWatcher?: boolean</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.vm = vm</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (isRenderWatcher) &#123;</span><br><span class=\"line\">      vm._watcher = <span class=\"hljs-keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vm._watchers.push(<span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"hljs-comment\">// options</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (options) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.deep = !!options.deep</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.user = !!options.user</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.computed = !!options.computed</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.sync = !!options.sync</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.before = options.before</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.deep = <span class=\"hljs-keyword\">this</span>.user = <span class=\"hljs-keyword\">this</span>.computed = <span class=\"hljs-keyword\">this</span>.sync = <span class=\"hljs-literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.cb = cb</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.id = ++uid <span class=\"hljs-comment\">// uid for batching</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.active = <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.dirty = <span class=\"hljs-keyword\">this</span>.computed <span class=\"hljs-comment\">// for computed watchers</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.deps = []</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.newDeps = []</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.depIds = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.newDepIds = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.expression = process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span></span><br><span class=\"line\">      ? expOrFn.toString()</span><br><span class=\"line\">      : <span class=\"hljs-string\">''</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// parse expression for getter</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> expOrFn === <span class=\"hljs-string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.getter = expOrFn</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.getter = parsePath(expOrFn)</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.getter) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.getter = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span> &amp;&amp; warn(</span><br><span class=\"line\">          <span class=\"hljs-string\">`Failed watching path: \"<span class=\"hljs-subst\">$&#123;expOrFn&#125;</span>\" `</span> +</span><br><span class=\"line\">          <span class=\"hljs-string\">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class=\"line\">          <span class=\"hljs-string\">'For full control, use a function instead.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.computed) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.value = <span class=\"hljs-literal\">undefined</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.dep = <span class=\"hljs-keyword\">new</span> Dep()</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.value = <span class=\"hljs-keyword\">this</span>.get()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   */</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">get</span> () &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 入栈 缓存Watcher  </span></span><br><span class=\"line\">    pushTarget(<span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"hljs-keyword\">let</span> value</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> vm = <span class=\"hljs-keyword\">this</span>.vm</span><br><span class=\"line\">    <span class=\"hljs-keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// 触发依赖收集</span></span><br><span class=\"line\">      value = <span class=\"hljs-keyword\">this</span>.getter.call(vm, vm)</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.user) &#123;</span><br><span class=\"line\">        handleError(e, vm, <span class=\"hljs-string\">`getter for watcher \"<span class=\"hljs-subst\">$&#123;<span class=\"hljs-keyword\">this</span>.expression&#125;</span>\"`</span>)</span><br><span class=\"line\">      &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">throw</span> e</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// \"touch\" every property so they are all tracked as</span></span><br><span class=\"line\">      <span class=\"hljs-comment\">// dependencies for deep watching</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.deep) &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// 递归对象或数组 触发getter  </span></span><br><span class=\"line\">        traverse(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// 出栈 恢复Watcher</span></span><br><span class=\"line\">      popTarget()</span><br><span class=\"line\">      <span class=\"hljs-comment\">// 清除不需要的依赖 逻辑实现在下面</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.cleanupDeps()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * Add a dependency to this directive.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   */</span></span><br><span class=\"line\">  addDep (dep: Dep) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> id = dep.id</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.newDepIds.has(id)) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.newDepIds.add(id)</span><br><span class=\"line\">      <span class=\"hljs-keyword\">this</span>.newDeps.push(dep)</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.depIds.has(id)) &#123;</span><br><span class=\"line\">        dep.addSub(<span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * Clean up for dependency collection.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   */</span></span><br><span class=\"line\">  cleanupDeps () &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-keyword\">this</span>.deps.length</span><br><span class=\"line\">    <span class=\"hljs-keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">this</span>.deps[i]</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class=\"line\">        dep.removeSub(<span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">let</span> tmp = <span class=\"hljs-keyword\">this</span>.depIds</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.depIds = <span class=\"hljs-keyword\">this</span>.newDepIds</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.newDepIds = tmp</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.newDepIds.clear()</span><br><span class=\"line\">    tmp = <span class=\"hljs-keyword\">this</span>.deps</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.deps = <span class=\"hljs-keyword\">this</span>.newDeps</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.newDeps = tmp</span><br><span class=\"line\">    <span class=\"hljs-keyword\">this</span>.newDeps.length = <span class=\"hljs-number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 后面省略</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码可以看到，实例化一个<code>Watcher</code>时，会执行<code>get</code>函数，通过<code>pushTarget(this)</code>将当前<code>Watcher</code>入栈，然后又执行<code>this.getter.call(vm, vm)</code>，这里的<code>getter</code>对应了<code>updateComponent</code> 函数，这里会执行一句关键代码<code>vm._update(vm._render(), hydrating)</code>，<code>vm._render()</code>会访问<code>vm</code>上面的数据，这里就会触发所有数据的getter，完成依赖收集。</p>\n<p>触发依赖收集之后，根据上面代码里的注释，<code>vue</code>还做了三步操作</p>\n<ol>\n<li>如果存在<code>deep</code>属性，说明存在<strong>深度依赖关系</strong>，采用<strong>递归</strong>进行依赖收集</li>\n<li>执行<code>popTarget()</code>出栈，恢复<code>watcher</code>成上一状态</li>\n<li>完成新订阅，执行<code>cleanupDeps()</code>，清除旧订阅，也就是清除旧依赖</li>\n</ol>\n<h2 id=\"派发更新\"><a href=\"#派发更新\" class=\"headerlink\" title=\"派发更新\"></a>派发更新</h2><p>看下<code>setter</code>代码</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">    <span class=\"hljs-comment\">/* eslint-disable no-self-compare */</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">/* eslint-enable no-self-compare */</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// #7981: for accessor properties without setter</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (getter &amp;&amp; !setter) <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (setter) &#123;</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// shallow为false时 将新值设置成响应式对象</span></span><br><span class=\"line\">    childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 通知订阅者</span></span><br><span class=\"line\">    dep.notify()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值发生变化时，会调用<code>dep</code>的<code>notify</code>方法，看下<code>Dep</code>对<code>notify</code>的定义</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// 派发更新</span></span><br><span class=\"line\">notify () &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// stabilize the subscriber list first</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">const</span> subs = <span class=\"hljs-keyword\">this</span>.subs.slice()</span><br><span class=\"line\">    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里调用了每个<code>watcher</code>的<code>update</code>方法</p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update () &#123;</span><br><span class=\"line\">    <span class=\"hljs-comment\">/* istanbul ignore else */</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.lazy) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.dirty = <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">    <span class=\"hljs-comment\">// 同步时执行</span></span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.sync) &#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.run()</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 推送到观察者队列    </span></span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">        queueWatcher(<span class=\"hljs-keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里关注<code>run</code>和<code>queueWatcher</code></p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">// run 定义在watcher里面</span></span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * Scheduler job interface.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   * Will be called by the scheduler.</span></span><br><span class=\"line\"><span class=\"hljs-comment\">   */</span></span><br><span class=\"line\">  run () &#123;</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.active) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-keyword\">this</span>.get()</span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (</span><br><span class=\"line\">        value !== <span class=\"hljs-keyword\">this</span>.value ||</span><br><span class=\"line\">        <span class=\"hljs-comment\">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class=\"line\">        <span class=\"hljs-comment\">// when the value is the same, because the value may</span></span><br><span class=\"line\">        <span class=\"hljs-comment\">// have mutated.</span></span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"hljs-comment\">// set new value</span></span><br><span class=\"line\">        <span class=\"hljs-keyword\">const</span> oldValue = <span class=\"hljs-keyword\">this</span>.value</span><br><span class=\"line\">        <span class=\"hljs-keyword\">this</span>.value = value</span><br><span class=\"line\">        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.user) &#123;</span><br><span class=\"line\">          <span class=\"hljs-keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"hljs-keyword\">this</span>.cb.call(<span class=\"hljs-keyword\">this</span>.vm, value, oldValue)</span><br><span class=\"line\">          &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            handleError(e, <span class=\"hljs-keyword\">this</span>.vm, <span class=\"hljs-string\">`callback for watcher \"<span class=\"hljs-subst\">$&#123;<span class=\"hljs-keyword\">this</span>.expression&#125;</span>\"`</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"hljs-keyword\">this</span>.cb.call(<span class=\"hljs-keyword\">this</span>.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>run</code>的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有<code>deep</code>等判断，满足其中之一就进行回调，而在通过<code>this.get()</code>拿值的时候，就会触发执行<code>getter</code>，这也是响应式数据修改时触发渲染的原因。</p>\n<h3 id=\"queueWatcher\"><a href=\"#queueWatcher\" class=\"headerlink\" title=\"queueWatcher\"></a>queueWatcher</h3><p>代码路径 <code>src/core/observer/scheduler.js</code> </p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> queue: <span class=\"hljs-built_in\">Array</span>&lt;Watcher&gt; = []</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> activatedChildren: <span class=\"hljs-built_in\">Array</span>&lt;Component&gt; = []</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> has: &#123; [key: number]: ?<span class=\"hljs-literal\">true</span> &#125; = &#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> waiting = <span class=\"hljs-literal\">false</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> flushing = <span class=\"hljs-literal\">false</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * Push a watcher into the watcher queue.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * pushed when the queue is being flushed.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">queueWatcher</span> (<span class=\"hljs-params\">watcher: Watcher</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> id = watcher.id</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 保证每个watcher只会被添加一次</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (has[id] == <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">    has[id] = <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (!flushing) &#123;</span><br><span class=\"line\">      queue.push(watcher)</span><br><span class=\"line\">    &#125; <span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// if already flushing, splice the watcher based on its id</span></span><br><span class=\"line\">      <span class=\"hljs-comment\">// if already past its id, it will be run next immediately.</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">let</span> i = queue.length - <span class=\"hljs-number\">1</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class=\"line\">        i--</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      queue.splice(i + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, watcher)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"hljs-comment\">// queue the flush</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (!waiting) &#123;</span><br><span class=\"line\">      waiting = <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">      <span class=\"hljs-comment\">// 同步</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class=\"line\">        flushSchedulerQueue()</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"hljs-comment\">// 在下一个tick 异步执行flushSchedulerQueue</span></span><br><span class=\"line\">      nextTick(flushSchedulerQueue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>vue</code>在派发更新的时候使用了<strong>队列</strong>，这样做的好处就是每次数据改变时不会马上触发<code>watcher</code>的回调，会先将<code>watcher</code>添加到队列里，然后在<code>nextTick</code>后执行<code>flushSchedulerQueue</code></p>\n<h3 id=\"flushSchedulerQueue\"><a href=\"#flushSchedulerQueue\" class=\"headerlink\" title=\"flushSchedulerQueue\"></a>flushSchedulerQueue</h3><p>代码路径 <code>src/core/observer/scheduler.js</code> </p>\n<figure class=\"highlight javascript hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-comment\">/**</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> * Flush both queues and run the watchers.</span></span><br><span class=\"line\"><span class=\"hljs-comment\"> */</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">flushSchedulerQueue</span> (<span class=\"hljs-params\"></span>) </span>&#123;</span><br><span class=\"line\">  currentFlushTimestamp = getNow()</span><br><span class=\"line\">  flushing = <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> watcher, id</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// Sort queue before flush.</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// This ensures that:</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">//    created before the child)</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">//    user watchers are created before the render watcher)</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">//    its watchers can be skipped.</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 队列排序 原因如上注释</span></span><br><span class=\"line\">  queue.sort(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// do not cache length because more watchers might be pushed</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// as we run existing watchers</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 队列遍历  </span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">for</span> (index = <span class=\"hljs-number\">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class=\"line\">    watcher = queue[index]</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (watcher.before) &#123;</span><br><span class=\"line\">      watcher.before()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    id = watcher.id</span><br><span class=\"line\">    has[id] = <span class=\"hljs-literal\">null</span></span><br><span class=\"line\">    watcher.run()</span><br><span class=\"line\">    <span class=\"hljs-comment\">// in dev build, check and stop circular updates.</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">'production'</span> &amp;&amp; has[id] != <span class=\"hljs-literal\">null</span>) &#123;</span><br><span class=\"line\">      circular[id] = (circular[id] || <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span></span><br><span class=\"line\">      <span class=\"hljs-keyword\">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"hljs-string\">'You may have an infinite update loop '</span> + (</span><br><span class=\"line\">            watcher.user</span><br><span class=\"line\">              ? <span class=\"hljs-string\">`in watcher with expression \"<span class=\"hljs-subst\">$&#123;watcher.expression&#125;</span>\"`</span></span><br><span class=\"line\">              : <span class=\"hljs-string\">`in a component render function.`</span></span><br><span class=\"line\">          ),</span><br><span class=\"line\">          watcher.vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"hljs-keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// keep copies of post queues before resetting state</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> activatedQueue = activatedChildren.slice()</span><br><span class=\"line\">  <span class=\"hljs-keyword\">const</span> updatedQueue = queue.slice()</span><br><span class=\"line\"></span><br><span class=\"line\">  resetSchedulerState()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// call component updated and activated hooks</span></span><br><span class=\"line\">  callActivatedHooks(activatedQueue)</span><br><span class=\"line\">  callUpdatedHooks(updatedQueue)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// devtool hook</span></span><br><span class=\"line\">  <span class=\"hljs-comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class=\"line\">    devtools.emit(<span class=\"hljs-string\">'flush'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>flushSchedulerQueue</code>在这里做了两件事，<strong>队列排序</strong>和<strong>队列遍历</strong>。</p>\n<p>队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。</p>\n<p>然后对排序后的队列进行遍历，拿到<code>watcher</code>执行<code>run</code>方法，<code>run</code>已在上面分析。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了<code>proxy</code>来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~</p>\n","site":{"data":{}},"excerpt":"<p>上一篇分析了<strong>data</strong>的初始化过程以及做的一些操作，这一篇分析<strong>依赖收集</strong>和<strong>派发更新</strong>。</p>\n<h2 id=\"依赖收集\"><a href=\"#依赖收集\" class=\"headerlink\" title=\"依赖收集\"></a>依赖收集</h2><p>先看下<code>getter</code>的代码</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  obj: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  key: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  val: any,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  customSetter?: ?Function,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  shallow?: boolean</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> property = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (property &amp;&amp; property.configurable === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// cater for pre-defined getter/setters</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getter = property &amp;&amp; property.get</span><br><span class=\"line\">  <span class=\"keyword\">const</span> setter = property &amp;&amp; property.set</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((!getter || setter) &amp;&amp; <span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 重点看get这部分  </span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function reactiveGetter () &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>getter</code>的逻辑里面，关键的两步是<code>const dep = new Dep()</code>和<code>dep.depend()</code>，第一步是实例化一个<code>Dep</code>实例，第二步就是实现依赖收集。</p>\n<p>先看第一步，<code>Dep</code>的实现，代码路径<code>/src/core/observer/dep.js</code></p>\n<h3 id=\"Dep\"><a href=\"#Dep\" class=\"headerlink\" title=\"Dep\"></a>Dep</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> type Watcher <span class=\"keyword\">from</span> <span class=\"string\">'./watcher'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; remove &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../util/index'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uid = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A dep is an observable that can have multiple</span></span><br><span class=\"line\"><span class=\"comment\"> * directives subscribing to it.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> target: ?Watcher;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  subs: <span class=\"built_in\">Array</span>&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = uid++</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加观察者</span></span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 移除观察者</span></span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(<span class=\"keyword\">this</span>.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 依赖收集 存在target时添加观察者对象</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 派发更新 省略 下面有用到</span></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the current target watcher being evaluated.</span></span><br><span class=\"line\"><span class=\"comment\">// this is globally unique because there could be only one</span></span><br><span class=\"line\"><span class=\"comment\">// watcher being evaluated at any time.</span></span><br><span class=\"line\">Dep.target = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetStack = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pushTarget</span> (<span class=\"params\">_target: ?Watcher</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class=\"line\">  Dep.target = _target</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">popTarget</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Dep.target = targetStack.pop()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，<code>Dep</code>是对<code>subs</code>数组的操作，而<code>subs</code>是<code>watcher</code>数组，所以<code>Dep</code>其实是对<code>watchers</code>的管理。</p>\n<p>接着看watcher的逻辑，代码路径<code>/src/core/observer/watcher.js</code></p>\n<h3 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a>Watcher</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uid = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A watcher parses an expression, collects dependencies,</span></span><br><span class=\"line\"><span class=\"comment\"> * and fires callback when the expression value changes.</span></span><br><span class=\"line\"><span class=\"comment\"> * This is used for both the $watch() api and directives.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">  deps: <span class=\"built_in\">Array</span>&lt;Dep&gt;;</span><br><span class=\"line\">  newDeps: <span class=\"built_in\">Array</span>&lt;Dep&gt;;  </span><br><span class=\"line\">  <span class=\"comment\">// 此处省略一堆类型声明, 具体在源码查看</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (</span><br><span class=\"line\">    vm: Component,</span><br><span class=\"line\">    expOrFn: string | Function,</span><br><span class=\"line\">    cb: Function,</span><br><span class=\"line\">    options?: ?Object,</span><br><span class=\"line\">    isRenderWatcher?: boolean</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vm = vm</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRenderWatcher) &#123;</span><br><span class=\"line\">      vm._watcher = <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vm._watchers.push(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">// options</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.deep = !!options.deep</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.user = !!options.user</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.computed = !!options.computed</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.sync = !!options.sync</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.before = options.before</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.deep = <span class=\"keyword\">this</span>.user = <span class=\"keyword\">this</span>.computed = <span class=\"keyword\">this</span>.sync = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cb = cb</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = ++uid <span class=\"comment\">// uid for batching</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.active = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dirty = <span class=\"keyword\">this</span>.computed <span class=\"comment\">// for computed watchers</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deps = []</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.newDeps = []</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depIds = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.newDepIds = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expression = process.env.NODE_ENV !== <span class=\"string\">'production'</span></span><br><span class=\"line\">      ? expOrFn.toString()</span><br><span class=\"line\">      : <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"comment\">// parse expression for getter</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> expOrFn === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.getter = expOrFn</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.getter = parsePath(expOrFn)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.getter) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.getter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; warn(</span><br><span class=\"line\">          <span class=\"string\">`Failed watching path: \"<span class=\"subst\">$&#123;expOrFn&#125;</span>\" `</span> +</span><br><span class=\"line\">          <span class=\"string\">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class=\"line\">          <span class=\"string\">'For full control, use a function instead.'</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.computed) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">get</span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入栈 缓存Watcher  </span></span><br><span class=\"line\">    pushTarget(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">this</span>.vm</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 触发依赖收集</span></span><br><span class=\"line\">      value = <span class=\"keyword\">this</span>.getter.call(vm, vm)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.user) &#123;</span><br><span class=\"line\">        handleError(e, vm, <span class=\"string\">`getter for watcher \"<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.expression&#125;</span>\"`</span>)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// \"touch\" every property so they are all tracked as</span></span><br><span class=\"line\">      <span class=\"comment\">// dependencies for deep watching</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.deep) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 递归对象或数组 触发getter  </span></span><br><span class=\"line\">        traverse(value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 出栈 恢复Watcher</span></span><br><span class=\"line\">      popTarget()</span><br><span class=\"line\">      <span class=\"comment\">// 清除不需要的依赖 逻辑实现在下面</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.cleanupDeps()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Add a dependency to this directive.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  addDep (dep: Dep) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = dep.id</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.newDepIds.has(id)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.newDepIds.add(id)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.newDeps.push(dep)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.depIds.has(id)) &#123;</span><br><span class=\"line\">        dep.addSub(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Clean up for dependency collection.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  cleanupDeps () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"keyword\">this</span>.deps.length</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> dep = <span class=\"keyword\">this</span>.deps[i]</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class=\"line\">        dep.removeSub(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"keyword\">this</span>.depIds</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.depIds = <span class=\"keyword\">this</span>.newDepIds</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.newDepIds = tmp</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.newDepIds.clear()</span><br><span class=\"line\">    tmp = <span class=\"keyword\">this</span>.deps</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.deps = <span class=\"keyword\">this</span>.newDeps</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.newDeps = tmp</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.newDeps.length = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 后面省略</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码可以看到，实例化一个<code>Watcher</code>时，会执行<code>get</code>函数，通过<code>pushTarget(this)</code>将当前<code>Watcher</code>入栈，然后又执行<code>this.getter.call(vm, vm)</code>，这里的<code>getter</code>对应了<code>updateComponent</code> 函数，这里会执行一句关键代码<code>vm._update(vm._render(), hydrating)</code>，<code>vm._render()</code>会访问<code>vm</code>上面的数据，这里就会触发所有数据的getter，完成依赖收集。</p>\n<p>触发依赖收集之后，根据上面代码里的注释，<code>vue</code>还做了三步操作</p>\n<ol>\n<li>如果存在<code>deep</code>属性，说明存在<strong>深度依赖关系</strong>，采用<strong>递归</strong>进行依赖收集</li>\n<li>执行<code>popTarget()</code>出栈，恢复<code>watcher</code>成上一状态</li>\n<li>完成新订阅，执行<code>cleanupDeps()</code>，清除旧订阅，也就是清除旧依赖</li>\n</ol>\n<h2 id=\"派发更新\"><a href=\"#派发更新\" class=\"headerlink\" title=\"派发更新\"></a>派发更新</h2><p>看下<code>setter</code>代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = getter ? getter.call(obj) : val</span><br><span class=\"line\">    <span class=\"comment\">/* eslint-disable no-self-compare */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* eslint-enable no-self-compare */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// #7981: for accessor properties without setter</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getter &amp;&amp; !setter) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setter) &#123;</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// shallow为false时 将新值设置成响应式对象</span></span><br><span class=\"line\">    childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class=\"line\">    <span class=\"comment\">// 通知订阅者</span></span><br><span class=\"line\">    dep.notify()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值发生变化时，会调用<code>dep</code>的<code>notify</code>方法，看下<code>Dep</code>对<code>notify</code>的定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 派发更新</span></span><br><span class=\"line\">notify () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// stabilize the subscriber list first</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>.subs.slice()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里调用了每个<code>watcher</code>的<code>update</code>方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update () &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* istanbul ignore else */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lazy) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dirty = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\">// 同步时执行</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.sync) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.run()</span><br><span class=\"line\">    <span class=\"comment\">// 推送到观察者队列    </span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        queueWatcher(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里关注<code>run</code>和<code>queueWatcher</code></p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// run 定义在watcher里面</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Scheduler job interface.</span></span><br><span class=\"line\"><span class=\"comment\">   * Will be called by the scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  run () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.active) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        value !== <span class=\"keyword\">this</span>.value ||</span><br><span class=\"line\">        <span class=\"comment\">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class=\"line\">        <span class=\"comment\">// when the value is the same, because the value may</span></span><br><span class=\"line\">        <span class=\"comment\">// have mutated.</span></span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// set new value</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> oldValue = <span class=\"keyword\">this</span>.value</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.user) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, value, oldValue)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            handleError(e, <span class=\"keyword\">this</span>.vm, <span class=\"string\">`callback for watcher \"<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.expression&#125;</span>\"`</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>run</code>的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有<code>deep</code>等判断，满足其中之一就进行回调，而在通过<code>this.get()</code>拿值的时候，就会触发执行<code>getter</code>，这也是响应式数据修改时触发渲染的原因。</p>\n<h3 id=\"queueWatcher\"><a href=\"#queueWatcher\" class=\"headerlink\" title=\"queueWatcher\"></a>queueWatcher</h3><p>代码路径 <code>src/core/observer/scheduler.js</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> queue: <span class=\"built_in\">Array</span>&lt;Watcher&gt; = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> activatedChildren: <span class=\"built_in\">Array</span>&lt;Component&gt; = []</span><br><span class=\"line\"><span class=\"keyword\">let</span> has: &#123; [key: number]: ?<span class=\"literal\">true</span> &#125; = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> waiting = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> flushing = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Push a watcher into the watcher queue.</span></span><br><span class=\"line\"><span class=\"comment\"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class=\"line\"><span class=\"comment\"> * pushed when the queue is being flushed.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">queueWatcher</span> (<span class=\"params\">watcher: Watcher</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> id = watcher.id</span><br><span class=\"line\">  <span class=\"comment\">// 保证每个watcher只会被添加一次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (has[id] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    has[id] = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flushing) &#123;</span><br><span class=\"line\">      queue.push(watcher)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// if already flushing, splice the watcher based on its id</span></span><br><span class=\"line\">      <span class=\"comment\">// if already past its id, it will be run next immediately.</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> i = queue.length - <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class=\"line\">        i--</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      queue.splice(i + <span class=\"number\">1</span>, <span class=\"number\">0</span>, watcher)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// queue the flush</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!waiting) &#123;</span><br><span class=\"line\">      waiting = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"comment\">// 同步</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class=\"line\">        flushSchedulerQueue()</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 在下一个tick 异步执行flushSchedulerQueue</span></span><br><span class=\"line\">      nextTick(flushSchedulerQueue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>vue</code>在派发更新的时候使用了<strong>队列</strong>，这样做的好处就是每次数据改变时不会马上触发<code>watcher</code>的回调，会先将<code>watcher</code>添加到队列里，然后在<code>nextTick</code>后执行<code>flushSchedulerQueue</code></p>\n<h3 id=\"flushSchedulerQueue\"><a href=\"#flushSchedulerQueue\" class=\"headerlink\" title=\"flushSchedulerQueue\"></a>flushSchedulerQueue</h3><p>代码路径 <code>src/core/observer/scheduler.js</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Flush both queues and run the watchers.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushSchedulerQueue</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  currentFlushTimestamp = getNow()</span><br><span class=\"line\">  flushing = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> watcher, id</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Sort queue before flush.</span></span><br><span class=\"line\">  <span class=\"comment\">// This ensures that:</span></span><br><span class=\"line\">  <span class=\"comment\">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class=\"line\">  <span class=\"comment\">//    created before the child)</span></span><br><span class=\"line\">  <span class=\"comment\">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class=\"line\">  <span class=\"comment\">//    user watchers are created before the render watcher)</span></span><br><span class=\"line\">  <span class=\"comment\">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class=\"line\">  <span class=\"comment\">//    its watchers can be skipped.</span></span><br><span class=\"line\">  <span class=\"comment\">// 队列排序 原因如上注释</span></span><br><span class=\"line\">  queue.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// do not cache length because more watchers might be pushed</span></span><br><span class=\"line\">  <span class=\"comment\">// as we run existing watchers</span></span><br><span class=\"line\">  <span class=\"comment\">// 队列遍历  </span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class=\"line\">    watcher = queue[index]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (watcher.before) &#123;</span><br><span class=\"line\">      watcher.before()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    id = watcher.id</span><br><span class=\"line\">    has[id] = <span class=\"literal\">null</span></span><br><span class=\"line\">    watcher.run()</span><br><span class=\"line\">    <span class=\"comment\">// in dev build, check and stop circular updates.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp; has[id] != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      circular[id] = (circular[id] || <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          <span class=\"string\">'You may have an infinite update loop '</span> + (</span><br><span class=\"line\">            watcher.user</span><br><span class=\"line\">              ? <span class=\"string\">`in watcher with expression \"<span class=\"subst\">$&#123;watcher.expression&#125;</span>\"`</span></span><br><span class=\"line\">              : <span class=\"string\">`in a component render function.`</span></span><br><span class=\"line\">          ),</span><br><span class=\"line\">          watcher.vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// keep copies of post queues before resetting state</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> activatedQueue = activatedChildren.slice()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> updatedQueue = queue.slice()</span><br><span class=\"line\"></span><br><span class=\"line\">  resetSchedulerState()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// call component updated and activated hooks</span></span><br><span class=\"line\">  callActivatedHooks(activatedQueue)</span><br><span class=\"line\">  callUpdatedHooks(updatedQueue)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// devtool hook</span></span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class=\"line\">    devtools.emit(<span class=\"string\">'flush'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>flushSchedulerQueue</code>在这里做了两件事，<strong>队列排序</strong>和<strong>队列遍历</strong>。</p>\n<p>队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。</p>\n<p>然后对排序后的队列进行遍历，拿到<code>watcher</code>执行<code>run</code>方法，<code>run</code>已在上面分析。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了<code>proxy</code>来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckfauc4kn0006hsuh335527ee","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4l3000dhsuhnhxsmayw"},{"post_id":"ckfauc4k40000hsuhffloxs3k","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4l7000ihsuhb1fz5yar"},{"post_id":"ckfauc4kr0007hsuhjr8wd04c","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4la000khsuh05oh0mca"},{"post_id":"ckfauc4kw000bhsuh6xnlcxww","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4lg000ohsuhjaztjlkh"},{"post_id":"ckfauc4kd0002hsuhfhc5g12a","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4lk000rhsuh4snxamk9"},{"post_id":"ckfauc4kk0005hsuhqkrztps9","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4lm000vhsuh8rmqv0sa"},{"post_id":"ckfauc4ld000nhsuh36iu9an7","category_id":"ckfauc4lb000lhsuhn1uvrnqv","_id":"ckfauc4lo000yhsuhrlegggkn"},{"post_id":"ckfauc4l0000chsuhpmazev5v","category_id":"ckfauc4lb000lhsuhn1uvrnqv","_id":"ckfauc4lr0013hsuhlf6s65o1"},{"post_id":"ckfauc4li000qhsuhrq1h9ddr","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4lu0016hsuhrx1hwozl"},{"post_id":"ckfauc4ll000uhsuhox3hbu5w","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4m2001bhsuhlhlqytdu"},{"post_id":"ckfauc4l5000hhsuhakzs5j3r","category_id":"ckfauc4lb000lhsuhn1uvrnqv","_id":"ckfauc4m5001ehsuhha98se03"},{"post_id":"ckfauc4l8000jhsuhrthws6ub","category_id":"ckfauc4lb000lhsuhn1uvrnqv","_id":"ckfauc4m7001jhsuh3r2nsnds"},{"post_id":"ckfauc4lt0015hsuh4y5mz7ys","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4m9001mhsuht58d16qn"},{"post_id":"ckfauc4lv001ahsuh988njkz2","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4ma001phsuhivjrpwr3"},{"post_id":"ckfauc4ln000xhsuhgsiw6yvc","category_id":"ckfauc4lu0017hsuhn35594ui","_id":"ckfauc4me001thsuhobplhqmo"},{"post_id":"ckfauc4m4001dhsuh9e72i8jl","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4mh001xhsuhlo1ngjad"},{"post_id":"ckfauc4m6001ihsuhb4lb56rk","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4mk0021hsuhsjswveb7"},{"post_id":"ckfauc4lq0012hsuh0keuzmxf","category_id":"ckfauc4m5001fhsuhgad8vadx","_id":"ckfauc4ml0024hsuh16xs4d3s"},{"post_id":"ckfauc4m8001lhsuhf749y2m4","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4mo0027hsuh3xbjzduf"},{"post_id":"ckfauc4mg001whsuhk3rfnmt3","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4mp0029hsuhzbk5d9wj"},{"post_id":"ckfauc4mj0020hsuhlmaq8v3s","category_id":"ckfauc4lu0017hsuhn35594ui","_id":"ckfauc4mq002chsuhs5koz8ib"},{"post_id":"ckfauc4ma001ohsuhiwq9kazi","category_id":"ckfauc4mf001uhsuh7gelsrex","_id":"ckfauc4mq002ehsuho1xyuyei"},{"post_id":"ckfauc4mc001shsuh4ynmnigg","category_id":"ckfauc4mf001uhsuh7gelsrex","_id":"ckfauc4ms002ghsuhuegmicpm"},{"post_id":"ckfauc4n1002phsuhx6r9wysy","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4n7002vhsuhcj0yttko"},{"post_id":"ckfauc4n2002qhsuh1rsxcnsy","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4n8002xhsuhagf2xgdu"},{"post_id":"ckfauc4n4002shsuhez2slld4","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4n9002zhsuhzag28lm5"},{"post_id":"ckfauc4n6002uhsuhnobuob6o","category_id":"ckfauc4kg0003hsuhk457ze6b","_id":"ckfauc4na0031hsuhitatt78s"}],"PostTag":[{"post_id":"ckfauc4k40000hsuhffloxs3k","tag_id":"ckfauc4kj0004hsuh9erfq047","_id":"ckfauc4kw000ahsuhbvurtmlk"},{"post_id":"ckfauc4kd0002hsuhfhc5g12a","tag_id":"ckfauc4kj0004hsuh9erfq047","_id":"ckfauc4l5000ghsuhuvzgetw4"},{"post_id":"ckfauc4kk0005hsuhqkrztps9","tag_id":"ckfauc4l4000fhsuhb6k28c3k","_id":"ckfauc4lh000phsuhngqb5zx8"},{"post_id":"ckfauc4li000qhsuhrq1h9ddr","tag_id":"ckfauc4l4000fhsuhb6k28c3k","_id":"ckfauc4ln000whsuhzspx2lra"},{"post_id":"ckfauc4ll000uhsuhox3hbu5w","tag_id":"ckfauc4kj0004hsuh9erfq047","_id":"ckfauc4lp0010hsuhphz3550l"},{"post_id":"ckfauc4kn0006hsuh335527ee","tag_id":"ckfauc4lc000mhsuhh8y18vlw","_id":"ckfauc4ls0014hsuh1mlu9htm"},{"post_id":"ckfauc4kn0006hsuh335527ee","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4lv0018hsuh36dy0rmx"},{"post_id":"ckfauc4lq0012hsuh0keuzmxf","tag_id":"ckfauc4l4000fhsuhb6k28c3k","_id":"ckfauc4m3001chsuh9hl3f5sc"},{"post_id":"ckfauc4kr0007hsuhjr8wd04c","tag_id":"ckfauc4l4000fhsuhb6k28c3k","_id":"ckfauc4m6001ghsuhhvrkj9f5"},{"post_id":"ckfauc4lt0015hsuh4y5mz7ys","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4m8001khsuhszkh3b44"},{"post_id":"ckfauc4lv001ahsuh988njkz2","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4m9001nhsuhughnzsd7"},{"post_id":"ckfauc4kw000bhsuh6xnlcxww","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4mb001rhsuhr4knegsh"},{"post_id":"ckfauc4m4001dhsuh9e72i8jl","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4mg001vhsuh2cmmvufs"},{"post_id":"ckfauc4m6001ihsuhb4lb56rk","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4mi001zhsuh6izttrhd"},{"post_id":"ckfauc4m8001lhsuhf749y2m4","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4ml0022hsuh290kl5xu"},{"post_id":"ckfauc4l0000chsuhpmazev5v","tag_id":"ckfauc4m6001hhsuhrls6avv6","_id":"ckfauc4mn0026hsuh74wx8v2l"},{"post_id":"ckfauc4l5000hhsuhakzs5j3r","tag_id":"ckfauc4m6001hhsuhrls6avv6","_id":"ckfauc4mo0028hsuhzferro0a"},{"post_id":"ckfauc4l8000jhsuhrthws6ub","tag_id":"ckfauc4m6001hhsuhrls6avv6","_id":"ckfauc4mp002bhsuhyppm0rm1"},{"post_id":"ckfauc4ld000nhsuh36iu9an7","tag_id":"ckfauc4m6001hhsuhrls6avv6","_id":"ckfauc4mq002dhsuhdkqq16x2"},{"post_id":"ckfauc4ln000xhsuhgsiw6yvc","tag_id":"ckfauc4mp002ahsuhk0qlylcm","_id":"ckfauc4ms002hhsuh32yoxjen"},{"post_id":"ckfauc4ma001ohsuhiwq9kazi","tag_id":"ckfauc4mr002fhsuhjdx5qxty","_id":"ckfauc4ms002jhsuhywah38ed"},{"post_id":"ckfauc4mc001shsuh4ynmnigg","tag_id":"ckfauc4ms002ihsuh84kufrf4","_id":"ckfauc4mt002lhsuhbkjtfuyt"},{"post_id":"ckfauc4mg001whsuhk3rfnmt3","tag_id":"ckfauc4mt002khsuhge34crxg","_id":"ckfauc4mv002nhsuhkfdt7m84"},{"post_id":"ckfauc4mj0020hsuhlmaq8v3s","tag_id":"ckfauc4mp002ahsuhk0qlylcm","_id":"ckfauc4mv002ohsuh4rpaq6hq"},{"post_id":"ckfauc4n1002phsuhx6r9wysy","tag_id":"ckfauc4kj0004hsuh9erfq047","_id":"ckfauc4n4002rhsuhdoh1ex5x"},{"post_id":"ckfauc4n2002qhsuh1rsxcnsy","tag_id":"ckfauc4kj0004hsuh9erfq047","_id":"ckfauc4n5002thsuh8kjsc0f2"},{"post_id":"ckfauc4n4002shsuhez2slld4","tag_id":"ckfauc4lc000mhsuhh8y18vlw","_id":"ckfauc4n8002whsuhogvp9eby"},{"post_id":"ckfauc4n4002shsuhez2slld4","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4n9002yhsuhs1fvah7g"},{"post_id":"ckfauc4n6002uhsuhnobuob6o","tag_id":"ckfauc4lc000mhsuhh8y18vlw","_id":"ckfauc4n90030hsuh2kprhmm3"},{"post_id":"ckfauc4n6002uhsuhnobuob6o","tag_id":"ckfauc4ll000thsuhail0v69n","_id":"ckfauc4na0032hsuh1co8sr9u"}],"Tag":[{"name":"总结","_id":"ckfauc4kj0004hsuh9erfq047"},{"name":"JS","_id":"ckfauc4l4000fhsuhb6k28c3k"},{"name":"源码","_id":"ckfauc4lc000mhsuhh8y18vlw"},{"name":"vue","_id":"ckfauc4ll000thsuhail0v69n"},{"name":"务实","_id":"ckfauc4m6001hhsuhrls6avv6"},{"name":"感想","_id":"ckfauc4mp002ahsuhk0qlylcm"},{"name":"HTTP","_id":"ckfauc4mr002fhsuhjdx5qxty"},{"name":"缓存","_id":"ckfauc4ms002ihsuh84kufrf4"},{"name":"CSS","_id":"ckfauc4mt002khsuhge34crxg"}]}}