<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2020征途大总结</title>
    <link href="/2020/12/23/2020%E5%BE%81%E9%80%94%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/23/2020%E5%BE%81%E9%80%94%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>时间如白驹过隙，一转眼2020就要过去。如果以金融交易的概念来比喻，那就是开盘低开，中间起起伏伏，不断震荡然后逐渐走高，那今年就算是一个低开高走的走势吧！年底这段时间也是越来越忙，但是按照以往的惯例，年底一定要对自己这一年进行一波回顾和总结，顺便对未来做一些规划和展望。</p><p>经过自己的一番深思熟虑，已经有几个点可以进行复盘总结：</p><ol><li>思维层面的提升；</li><li>解决问题能力的提升；</li><li>学习能力的提升；</li></ol><p>除了以上几个点，其实还有很多想法，那就先列举出来占个位，后续逐渐更新~</p>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React踩坑--配置篇</title>
    <link href="/2020/12/02/React%E8%B8%A9%E5%9D%91--%E9%85%8D%E7%BD%AE%E7%AF%87/"/>
    <url>/2020/12/02/React%E8%B8%A9%E5%9D%91--%E9%85%8D%E7%BD%AE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>最近在使用React的脚手架<code>create-react-app</code>搭建项目的时候踩了一些坑，主要都是配置方面的坑，大体上是因为React官方是把webpack等配置都封装好并隐藏起来，所以如果需要自定义配置需要自行处理，当然脚手架也提供了<code>eject</code>命令来释放配置，但是这是一个<strong>单向不可逆操作</strong>，释放了就回不来了，所以最好不要随便就释放配置。</p><a id="more"></a><p>但是我在踩坑的过程中搜索资料发现，很多人分享的经验，都是基于释放配置的情况。这种操作我个人不是很喜欢，脚手架将配置封装好隐藏起来肯定有它的道理，至少优化方面肯定是做足的，如果如果能通过其它方法来解决，自然是能不释放配置为好，这也是我做本篇记录的一个原因，以下是我自定义配置踩的一些坑，在不释放配置的前提下进行。</p><p>以<code>create-react-app@4.0.1</code> 及创建出来的项目<code> react@17.0.1</code>为例说明。</p><h3 id="目前踩坑清单"><a href="#目前踩坑清单" class="headerlink" title="目前踩坑清单"></a>目前踩坑清单</h3><ol><li><strong>路径别名配置</strong>；</li><li><strong>多个开发环境配置</strong>；</li><li><strong>多个代理环境配置</strong>；</li><li><strong>node-sass与node版本不匹配问题</strong>；</li><li><strong>动态引进图片</strong></li></ol><h3 id="路径别名配置"><a href="#路径别名配置" class="headerlink" title="路径别名配置"></a>路径别名配置</h3><p>用脚手架创建的项目配置里面没有默认设置别名，那只通过相对路径去引入文件的话路径就会很长也不方便，那肯定要设置一个别名来缩短路径，让引入变得更方便和优雅。这里借助<a href="https://www.npmjs.com/package/react-app-rewired">react-app-rewired</a>和<a href="https://www.npmjs.com/package/customize-cra">customize-cra</a>两个插件。</p><p><strong>react-app-rewired</strong>：此工具可以在不 <code>eject</code> 也不创建额外 <code>react-scripts</code> 的情况下修改脚手架内置的 <strong>webpack</strong> 配置，你将拥有 create-react-app 的一切特性，且可以根据你的需要去配置 <strong>webpack</strong> 的 <strong>plugins</strong>, <strong>loaders</strong> 等。</p><p><strong>customize-cra</strong>：利用<strong>react-app-rewired</strong>的核心功能来自定义<strong>create-react-app</strong>版本2和3的配置。</p><p>根目录创建<code>config-overrides.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; override, addWebpackAlias &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;customize-cra&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-built_in">module</span>.exports = override(<br>  addWebpackAlias(&#123;<br>    [<span class="hljs-string">&#x27;@&#x27;</span>]: path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br>  &#125;)<br>)<br></code></pre></td></tr></table></figure><p>然后修改<code>package.json</code>中运行命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;react-app-rewired start&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有引入ts的，还需在<code>tsconfig.json</code>中增加<code>paths</code>字段。但是在修改<code>tsconfig.json</code>配置之后，重新启动项目某些配置字段会被覆盖，就如<code>paths</code>。</p><p>解决方案：在根目录创建一个<code>paths.json</code>文件，写上<code>paths</code>的配置，然后通过<code>extends</code>扩展字段将该文件引入<code>tsconfig.json</code>。</p><p><code>paths.json</code>文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>,<br>    <span class="hljs-attr">&quot;paths&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;@/*&quot;</span>: [<span class="hljs-string">&quot;src/*&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tsconfig.json</code>文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">&quot;extends&quot;</span>: <span class="hljs-string">&quot;./paths.json&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以解决别名配置问题了。啪的一声，很快啊，项目就跑起来了。</p><h3 id="多个开发环境配置"><a href="#多个开发环境配置" class="headerlink" title="多个开发环境配置"></a>多个开发环境配置</h3><p>React脚手架提供开发环境配置仅限于<code>test</code>、<code>local</code>、<code>development</code>和<code>production</code>，对于我们自身开发有其它<strong>自定义环境</strong>的就显得不够了。那怎么去自定义开发环境呢，这里借助第三方插件<a href="https://www.npmjs.com/package/cross-env">cross-env</a>来实现。</p><p>第一步，通过<strong>yarn</strong>或<strong>npm</strong>安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">yarn add cross<span class="hljs-literal">-env</span> <span class="hljs-literal">-D</span><br>// or<br>npm i cross<span class="hljs-literal">-env</span> <span class="hljs-literal">-D</span><br></code></pre></td></tr></table></figure><p>第二步，修改<code>package.json</code>文件里<code>scripts</code>的执行命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>    &quot;start:test&quot;: &quot;cross-env REACT_APP_ENV=test react-app-rewired start&quot;,<br>    &quot;build:test&quot;: &quot;cross-env REACT_APP_ENV=test react-app-rewired build&quot;<br>&#125;,<br></code></pre></td></tr></table></figure><p>通过这样的配置，就可以使用<strong>process.env.REACT_APP_ENV</strong>来获取到当前环境。其它自定义环境也是如此。</p><h3 id="多个代理环境配置"><a href="#多个代理环境配置" class="headerlink" title="多个代理环境配置"></a>多个代理环境配置</h3><p>如果是开发环境不需要像上面的自定义，只有一个的话，那可以直接在<code>package.json</code>文件加上代理配置<code>proxy</code>字段：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;proxy&quot;: &quot;http://xxx&quot;<br></code></pre></td></tr></table></figure><p>但是如果有多个环境，这种配置就不合适了，所以多环境的时候还是需要借助第三方插件，这里选用<a href="https://www.npmjs.com/package/http-proxy-middleware">http-proxy-middleware</a>，这里比较方便的脚手架安装的时候这个插件已经有了，可以直接拿来用：</p><p>第一步，在<code>src</code>文件夹下新建名为<strong>setupProxy.js</strong>的文件，名字必须是这个；</p><p>第二步，在文件里面加入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)<br><span class="hljs-comment">// 这一步是根据上面的配置 获取当前开发对应的环境</span><br><span class="hljs-keyword">const</span> runEnv = process.env.REACT_APP_ENV<br><span class="hljs-comment">// 接下来根据环境自定义需要代理的api和代理目标 并暴露出去 简单参考配置如下</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">app</span>) </span>&#123;<br>  app.use(<span class="hljs-string">&#x27;/api&#x27;</span>, &#123;<br>    target: <span class="hljs-string">&#x27;http://xxx&#x27;</span>,<br>    changeOrigin: <span class="hljs-literal">true</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>根据自身业务补充上自定义的逻辑就可以实现多环境代理了。</p><h3 id="node-sass与node版本不匹配"><a href="#node-sass与node版本不匹配" class="headerlink" title="node-sass与node版本不匹配"></a>node-sass与node版本不匹配</h3><p>严格来说，这个坑不属于react配置上的坑，但是因为在项目基础建设的过程中遇到，因此记录进来。</p><p>脚手架已经内置了<code>sass-loader</code>，所以想要在项目里面使用<strong>sass预处理语言</strong>，只需安装<code>node-sass</code>就可以，无需再安装<code>sass-loader</code>。</p><p>安装完<code>node-sass</code>之后项目跑不起来了，根据提示是<code>node-sass</code>版本问题，然后看了一下它的更新文档，有这么一个图：</p><p><img src="/images/node-sass.png"></p><p>从这个图可以知道，<code>node-sass</code>对<strong>NodeJS</strong>的版本是有要求的，我的版本是<code>14</code>，但安装的<code>node-sass</code>是<code>5.0</code>的，所以才会出现不支持的情况，这里更新一下<strong>node</strong>的版本或者安装<code>4.14+</code>的<code>node-sass</code>都可以解决问题。</p><h3 id="动态引进图片"><a href="#动态引进图片" class="headerlink" title="动态引进图片"></a>动态引进图片</h3><p>本来打算使用<code>require(path)</code>来动态引入图片，通过传参来设置不同的背景图片，但是报错了，错误截图如下：</p><p><img src="/images/require_err.png"></p><p>原因是<code>webpack</code>本身是一个<strong>预编译</strong>的打包工具，无法预测未知变量路径，<code>require</code>不能传<strong>纯变量</strong>路径，且path需要由三部分组成：<strong>目录+文件名+后缀</strong>，其实上图所示就是一个合格的路径。</p><p>解决方案1：<code>require</code>不使用纯变量，那就采用<strong>字符串+变量</strong>，如<code>require(&#39;@/assets/images&#39;+url)</code>，再写成一个工具函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getImg = <span class="hljs-function">(<span class="hljs-params">url: string</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> imgObj = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/assets/images&#x27;</span>+url)<br>  <span class="hljs-keyword">return</span> imgObj &amp;&amp; imgObj.default<br>&#125;<br></code></pre></td></tr></table></figure><p>然后放到样式中，就可以实现动态渲染背景图片：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">style=&#123;&#123;<br>  backgroundImage: <span class="hljs-string">`url(<span class="hljs-subst">$&#123;getImg(props.bgUrl)&#125;</span>)`</span>,<br>&#125;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器工作原理-渲染流程</title>
    <link href="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>浏览器在走完导航流程之后，接下来就是渲染阶段，走渲染流程。</p><p>渲染流程按照流水线可以分为以下阶段：DOM树构建、样式计算、布局阶段、分层、绘制、分块、栅格化、合成。每个阶段都有自己的输入内容、处理过程和输出结果。</p><a id="more"></a><p><strong>DOM树构建</strong>：浏览器并不能直接识别接收到的字节流，所以需要通过HTML解析器来进行一系列解析，转换成浏览器可以识别的结构，这个结构就是DOM树。</p><p><strong>样式计算</strong>：同样的，浏览器不能直接识别CSS，所以也需要转换成它可以识别的结构。转换过程有以下的步骤：</p><p>1.将CSS转换为可以识别的结构<strong>CSSOM</strong>，可以通过<code>document.styleSheets</code>来获取；</p><p>2.转换属性值，使其标准化；如下，渲染引擎对<code>em</code>、<code>bold</code>等属性值并不理解，需要进行转换成标准值；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">// 转换前<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;<br>    <span class="hljs-attribute">color</span>: blue;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br>// 转换后<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>);<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.根据标准化后的值计算出DOM节点的具体样式；</p><p><strong>布局阶段</strong>：有了DOM结构和其具体的样式之后，接下来就是要构建可见节点的几何位置，即布局阶段：</p><p>1.构建布局树（layoutTree）：遍历DOM树，将可见节点加入到布局中，不可见的（如<code>display: none</code>）不加入；</p><p>2.布局计算：计算出每个节点的几何位置；</p><p><strong>分层</strong>：有了布局树之后，渲染引擎会为布局树的节点创建图层形成一棵图层树（layerTree），但并不会为每个节点创建单独的图层，需满足以下条件之一：</p><p>1.拥有<strong>层叠上下文属性</strong>；如定位属性position、z-index、透明属性opacity、CSS滤镜filter等；</p><p>2.需要<strong>剪裁</strong>的地方；如某容器内文字部分过多超出当前容器，则文字部分会被单独创建一个图层，如果有滚动条，滚动条也是单独的图层；</p><p><strong>图层绘制</strong>：完成图层树的构建之后，渲染引擎会对每个图层进行绘制。图层绘制这个过程并没有开始真的绘制，而是将图层拆分成一个个绘制指令，按顺序组成一个待绘制列表。</p><p><strong>图层分块</strong>：有一些图层比较大，远远超过浏览器视口（viewport），一次性渲染会比较耗费性能，所以渲染进程里的合成线程会将图层分成很多的图块。</p><p><strong>栅格化</strong>：在合成线程将图层分成很多图块之后，栅格化操作就是将视口附近的图块转换成位图。渲染进程维护了一个栅格化线程池，位图的转换就是在线程池里面完成。通常情况栅格化还会在GPU进程里进行，这个过程也叫做<strong>GPU栅格化</strong>或<strong>快速栅格化</strong>。</p><p><strong>合成</strong>：当所有的图层都绘制完成，合成线程会生成一个绘制命令drawQuad给浏览器进程，浏览器进程里有一个Viz组件专门接收该命令然后根据命令绘制内容并最终显示到屏幕。</p><p>到此渲染流程就结束了，经过一系列阶段终于把各种资源转换成美观的页面显示在屏幕上，从浏览器的角度出发去看待整个过程，就会对这个过程有更多的了解。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器工作原理-导航流程</title>
    <link href="/2020/11/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/11/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>下面从一道常见的题目来开启浏览器工作原理之旅：<strong>用户输入URL到页面展示，这个过程发生了什么</strong>？</p><h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><p>开始之前先了解一下浏览器的架构，此处以chrome为例。</p><a id="more"></a><h4 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h4><p>早期chrome浏览器是单进程架构，所有的功能模块都运行在同个进程里，进程里面有浏览器主线程、网络线程、插件线程和其它线程。这么多个功能模块运行在同个进程里，当其中任何一个线程崩溃了，进程也会跟着崩溃，甚至导致浏览器也崩溃，这就导致了单进程浏览器<strong>不稳定</strong>、<strong>不流程</strong>和<strong>不安全</strong>。所以早期浏览器的体验也是比较差的。</p><h4 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h4><p>08年chrome发布了多进程浏览器，那时的多进程架构主要有浏览器主进程、渲染进程和插件进程。而现在的浏览器架构有<strong>浏览器主进程</strong>、<strong>渲染进程</strong>、<strong>网络进程</strong>、<strong>插件进程</strong>、<strong>GPU进程</strong>等。简单了解下各进程的主要作用：</p><p>浏览器进程：主要负责用户交互、子进程管理和文件存储等；</p><p>网络进程：面向浏览器进程和渲染进程提供网络下载等功能；</p><p>渲染进程：负责将从网络下载的HTML、JavaScript、图片等资源解析成可以显示和交互的界面；</p><h3 id="导航流程"><a href="#导航流程" class="headerlink" title="导航流程"></a>导航流程</h3><p>用户从输入URL到页面渲染展示出来之前的过程就是导航流程。</p><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>上面有提到各进程的主要功能，其中浏览器主进程用于处理用户交互，因此用户输入URL这个动作是发生在浏览器进程中，这里浏览器进程还有做一个处理，会自动识别用户输入的是搜索关键词还是URL，如果是搜索关键词会进行额外的处理并提交给搜索引擎，这里已经知道用户输入的是URL，则直接提交网络请求消息给网络进程。</p><h4 id="URL请求过程"><a href="#URL请求过程" class="headerlink" title="URL请求过程"></a>URL请求过程</h4><h5 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h5><p>接下来就是页面资源请求过程。浏览器进程通过IPC将网络请求发给网络进程，网络进程接收到浏览器进程的请求后，这个时候并不会直接发起网络请求，而是先查看本地是否有缓存，如果本地有缓存，则直接返回缓存的资源给浏览器进程，没有缓存才发起网络请求，进入<strong>网络请求流程</strong>。</p><h5 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h5><p>网络请求需要先进行DNS解析拿到IP地址，通过IP地址与服务器进行TCP三次握手连接。连接成功后浏览器向服务器发送构建的信息，服务器返回响应数据。</p><p>网络进程根据返回的响应数据，先进行重定向处理：判断返回的状态码是否是301或302，如果有则重定向，根据location字段重新发起新的网络请求。</p><p>如果返回200则继续流程，接着进行数据类型处理：返回的数据类型一般是HTML字节流，也有可能是下载文件，网络进程根据返回的Content-Type字段判断，如果是下载文件，则将该请求发给下载管理器，同时本次导航流程到此结束；如果是HTML字节流，则继续流程，浏览器进程开始准备渲染进程。</p><h4 id="准备渲染进程"><a href="#准备渲染进程" class="headerlink" title="准备渲染进程"></a>准备渲染进程</h4><p>默认情况下chrome会为每个页面分配一个渲染进程，即每个标签页对应一个渲染进程。但当从当前页面打开新的页面，且两个页面是属于同一站点：即根域名和协议是一样的，则会共用同一个渲染进程。</p><p>渲染进程准备好之后，还不能马上进入解析文档阶段，因为此时文档数据还在网络进程中，因此下一步要进入提交文档阶段。</p><h4 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h4><p>这里的“文档”指的是服务器返回的响应数据。浏览器进程发送“<strong>提交文档</strong>”的消息给渲染进程，渲染进程接收到消息后与网络进程建立起传输数据的“管道”，等数据传输完成之后，渲染进程会返回“<strong>确认提交</strong>”的消息给浏览器进程，浏览器进程接收到消息后会更新浏览器界面状态，包括安全状态、地址栏URL、前进后退的历史状态并更新web界面。</p><p>到这里就走完了一个完整的导航流程，而页面的显示则需要下面的<strong>渲染阶段</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监控网页崩溃的方案思考</title>
    <link href="/2020/11/14/%E7%9B%91%E6%8E%A7%E7%BD%91%E9%A1%B5%E5%B4%A9%E6%BA%83%E7%9A%84%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
    <url>/2020/11/14/%E7%9B%91%E6%8E%A7%E7%BD%91%E9%A1%B5%E5%B4%A9%E6%BA%83%E7%9A%84%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>众所周知，网页崩溃的时候，我们的JS是无法运行的，那我们要如何去做网页崩溃的监控呢？</p><a id="more"></a><p>个人理解崩溃监控的主要有两个点：能够<strong>准确监控</strong>和<strong>及时上报</strong>。业界对这种监控有一个专业名词：心跳检测。大致思路是每隔一段时间做一个指定的操作来证明网页还“<strong>存活</strong>”着，当超过一定的时间没有执行该操作就说明网页已经崩溃。基于这种思路，我们还可以利用网页的<code>load</code>和<code>beforeunload</code>事件来实现。</p><p>load事件是在页面加载后触发，beforeunload是正常网页关闭之前触发，而当网页崩溃时的关闭是无法触发<code>beforeunload</code>事件的，所以我们可以基于心跳检测的概念和这两个事件来实现网页崩溃的监控。</p><h3 id="方案一：使用sessionStorage"><a href="#方案一：使用sessionStorage" class="headerlink" title="方案一：使用sessionStorage"></a>方案一：使用sessionStorage</h3><p>这里使用到两个标识字段，<strong>exitFlag</strong>和<strong>updateTime</strong>来分别标识网页状态和操作的更新时间。</p><p>在load事件里面设置<strong>exitFlag</strong>字段值为<code>pending</code>，并加入<strong>updateTime</strong>字段，值为当前时间，设置定时器，每隔10s执行更新<strong>updateTime</strong>值。然后在<code>beforeunload</code>事件里面更改<strong>exitFlag</strong>字段的值为<code>unload</code>，表示网页正常关闭。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  sessionStorage.setItem(<span class="hljs-string">&#x27;exitFlag&#x27;</span>, <span class="hljs-string">&#x27;pending&#x27;</span>);<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    sessionStorage.setItem(<span class="hljs-string">&#x27;updateTime&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toString());<br>  &#125;, <span class="hljs-number">10000</span>);<br>&#125;);<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;beforeunload&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  sessionStorage.setItem(<span class="hljs-string">&#x27;exitFlag&#x27;</span>, <span class="hljs-string">&#x27;unload&#x27;</span>);<br>&#125;);<br><span class="hljs-keyword">if</span> (sessionStorage.getItem(<span class="hljs-string">&#x27;exitFlag&#x27;</span>) &amp;&amp;<br>  sessionStorage.getItem(<span class="hljs-string">&#x27;exitFlag&#x27;</span>) !== <span class="hljs-string">&#x27;unload&#x27;</span>) &#123;<br>  <span class="hljs-comment">/* 崩溃了  */</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;crashed on: &#x27;</span> + sessionStorage.getItem(<span class="hljs-string">&#x27;updateTime&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>监控逻辑：当用户进入页面的时候，去查看<strong>exitFlag</strong>，如果<strong>exitFlag</strong>存在且值为<code>pending</code>，那就说明之前网页已经崩溃，这时可以执行上报操作。</p><p>弊端：sessionStorage只跟当前会话页面关联，如果用户在页面崩溃的时候直接关闭网页而不是刷新页面，那么sessionStorage保存的内容也跟着被清理，做不到记录上报的作用；同时因为需要用户下次刷新页面才会上报，所以无法做到崩溃的时候及时上报。</p><h3 id="方案二：使用localStorage"><a href="#方案二：使用localStorage" class="headerlink" title="方案二：使用localStorage"></a>方案二：使用localStorage</h3><p>既然会话页面关闭sessionStorage会失去作用，那换成localStorage呢？将字段保存在localStorage不会存在关闭页面就清空的问题，但是同源的页面会使用同一个localStorage，有可能造成数据相互覆盖和多次误报的问题，所以还需要加上一个<strong>uniqueKey</strong>唯一字段来区分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generatorKey</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> +((<span class="hljs-built_in">Math</span>.random().toString().substring(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>) + <span class="hljs-built_in">Date</span>.now()).toString())<br>&#125;<br><span class="hljs-keyword">const</span> CRASH_TIME = <span class="hljs-number">5000</span>;<br><span class="hljs-keyword">const</span> uniqueKey = generatorKey();<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">localStorage</span>.setItem(uniqueKey, <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>    timeBeforeCrash: +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>  &#125;));<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">localStorage</span>.setItem(uniqueKey, <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>      timeBeforeCrash: +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;));<br>  &#125;, CRASH_TIME);<br>&#125;);<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;beforeunload&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">localStorage</span>.removeItem(uniqueKey);<br>&#125;);<br><br><span class="hljs-comment">// 遍历 localStorage 中储存的数据</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">localStorage</span>.valueOf()) &#123;<br>  <span class="hljs-keyword">const</span> item = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">localStorage</span>.getItem(key));<br>  <span class="hljs-comment">// 超过 CRASH_TIME 没有更新时间，则认为页面崩溃</span><br>  <span class="hljs-keyword">if</span> (item &amp;&amp; item.timeBeforeCrash &amp;&amp; (+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - item.timeBeforeCrash) &gt; CRASH_TIME) &#123;<br>    <span class="hljs-comment">// 执行上报等操作...</span><br>    <span class="hljs-built_in">localStorage</span>.removeItem(key)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>监控逻辑：检测关联的每个页面<strong>uniqueKey</strong>的<code>timeBeforeCrash</code>时间，如果超过设置的阈值未更新，则判断为页面崩溃。</p><p>弊端：同sessionStorage因为需要用户下次刷新页面才会上报，所以无法做到崩溃的时候及时上报。</p><h3 id="方案三：使用serviceWorker"><a href="#方案三：使用serviceWorker" class="headerlink" title="方案三：使用serviceWorker"></a>方案三：使用serviceWorker</h3><p>上面两种方案都是页面崩溃后需要等待再次进入页面才能上报，这就存在无法及时上报的问题，有没有其它的方法可以在页面崩溃的时候上报的工作还能继续运行，这时候就想到了<strong>web worker</strong>，<strong>shared worker</strong>和<strong>service woker</strong>了。考虑到各自的生命周期这个因素，service worker一般生命周期会比页面更长，关联的页面关闭后它还会继续存在，所以这里可以使用<strong>service worker</strong>来完成监控上报工作：</p><p>主页面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendMessageToSw</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>  navigator.serviceWorker.controller &amp;&amp; navigator.serviceWorker.controller.postMessage(msg);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryToRegister</span>(<span class="hljs-params"></span>) </span>&#123;<br>  sendMessageToSw(&#123;<br>    type: <span class="hljs-string">&#x27;register&#x27;</span>,<br>    reportData: &#123;<br>      url: location.href,<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 注册service worker</span><br>navigator.serviceWorker.register(<span class="hljs-string">&#x27;./sw.js&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> &#123;<br>  tryToRegister();<br>&#125;)<br><br>tryToRegister();<br><span class="hljs-comment">// 心跳回包</span><br>navigator.serviceWorker.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (event.data.type === <span class="hljs-string">&#x27;checkHealth&#x27;</span>) &#123;<br>    sendMessageToSw(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;keepHealth&#x27;</span>&#125;);<br>  &#125;<br>&#125;);<br><span class="hljs-comment">// 页面关之前发送退出信息</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;beforeunload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  sendMessageToSw(&#123;<br>    type: <span class="hljs-string">&#x27;unregister&#x27;</span>,<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>service worker代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// sw 代码</span><br><span class="hljs-keyword">const</span> heartDetection = &#123;&#125;;<br><span class="hljs-keyword">const</span> CRASH_TIME = <span class="hljs-number">5000</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-variable">client</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-variable">msg</span></span></span><br><span class="hljs-comment"> * 给对应的client发送消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendMessageToClient</span>(<span class="hljs-params">client, msg</span>)</span>&#123;<br>  client.postMessage(msg);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;String&#125;</span> <span class="hljs-variable">id</span></span></span><br><span class="hljs-comment"> * 根据 id 给主页面发送心跳包并检测是否存活</span><br><span class="hljs-comment"> * 下一个心跳包发送的的时候，上一个还没回来，则认为页面已崩溃</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkHealth</span>(<span class="hljs-params">id</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (heartDetection[id]) &#123;<br>    <span class="hljs-comment">// 状态不健康就上报</span><br>    <span class="hljs-keyword">if</span> (heartDetection[id].flag !== <span class="hljs-string">&#x27;healthy&#x27;</span>) &#123;<br>      <span class="hljs-comment">// do something</span><br>      <span class="hljs-comment">// reportCrash(heartDetection[id].reportData);</span><br>      removeCheck(id);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 设置成不健康，下次定时器的时候检查</span><br>    heartDetection[id].flag = <span class="hljs-string">&#x27;unhealthy&#x27;</span>;<br>    sendMessageToClient(heartDetection[id].client, &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;checkHealth&#x27;</span>&#125;)<br>  &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;String&#125;</span> <span class="hljs-variable">id</span></span></span><br><span class="hljs-comment"> * 清理心跳定时器并从map中移除</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeCheck</span>(<span class="hljs-params">id</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (heartDetection[id]) &#123;<br>    heartDetection[id].timer &amp;&amp; <span class="hljs-built_in">clearInterval</span>(heartDetection[id].timer);<br>    <span class="hljs-keyword">delete</span> heartDetection[id];<br>  &#125;<br>&#125;<br>self.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> sourceId = event.source.id;<br>  <span class="hljs-keyword">switch</span> (event.data.type) &#123;<br>    <span class="hljs-comment">// 页面新来的时候注册</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;register&#x27;</span>:<br>      <span class="hljs-comment">// 根据id拿到对应的页面</span><br>      self.clients.get(sourceId)<br>        .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">client</span>) </span>&#123;<br>          heartDetection[sourceId] = &#123;<br>            client: client,<br>            reportData: event.data.reportData,<br>            timer: <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              checkHealth(sourceId);<br>            &#125;, CRASH_TIME),<br>            flag: <span class="hljs-string">&#x27;healthy&#x27;</span>,<br>          &#125;;<br>          client.postMessage(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;registerSuccess&#x27;</span>&#125;)<br>        &#125;)<br>        .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(err);<br>        &#125;)<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// 页面关闭的时候删除有关信息</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unregister&#x27;</span>:<br>      removeCheck(sourceId);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keepHealth&#x27;</span>:<br>      <span class="hljs-keyword">if</span>(heartDetection[sourceId]) &#123;<br>        heartDetection[sourceId].flag = <span class="hljs-string">&#x27;healthy&#x27;</span>;<br>      &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>监控逻辑：主页面通过发送心跳<strong>keepHealth</strong>来表示当前关联页面的健康状态，service worker定时检测心跳的状态是否正常，如果下一个心跳包发送的的时候，上一个还没回来，则认为页面<strong>unhealthy</strong>已崩溃。</p><p>以上就是关于监控页面崩溃的一些想法和方案，后续如果有遇到更好的解决方案会同步更新。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>崩溃监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[10]-Pagination</title>
    <link href="/2020/11/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B10%5D-Pagination/"/>
    <url>/2020/11/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B10%5D-Pagination/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li>页码样式。页码不采用圆圈显示：当页码数值比较大时，有可能溢出圆圈，样式也并不好看。</li><li>页码显示。存在多于一页的情况时，页码显示<strong>第一页</strong>、<strong>当前页-2</strong>，**-1<strong>、</strong>当前页<strong>、</strong>当前页+1<strong>，</strong>+2<strong>、</strong>最后一页<strong>，重复则去重，中间未显示的页码用“</strong>…**”代替。</li></ol><a id="more"></a><h2 id="功能细节"><a href="#功能细节" class="headerlink" title="功能细节"></a>功能细节</h2><ol><li><p>页码去重。组件需要通过传入当前页码和总页码来计算出需要显示的页码，默认只展示第一页、当前页-2，-1、当前页、当前页+1，+2、最后一页。计算页码的过程需要去重，一开始是想使用ES6中的Set来去重，但为了兼顾到兼容性问题，因此使用将页码作为对象的键，最后遍历对象键的方式来去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span> (<span class="hljs-params">array</span>) </span>&#123;<br>  <span class="hljs-comment">// ES6</span><br>  <span class="hljs-comment">// return [...new Set(array)]</span><br><br>  <span class="hljs-keyword">const</span> object = &#123;&#125;<br>  array.map(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> &#123;<br>    object[number] = <span class="hljs-literal">true</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(object).map(<span class="hljs-function">(<span class="hljs-params">s</span>) =&gt;</span> <span class="hljs-built_in">parseInt</span>(s, <span class="hljs-number">10</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>因为对象的键都为字符串，所以还需要最后转为数值的一步。</p></li><li><p>页码显示。在对页码去重后，还需筛选出范围在<strong>1~totalPage</strong>的页码并排序，这时再遍历这个有序的页码数组，如果前后两个值不连续，说明页码是不连续的，再在中间加上“**…**”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>computed: &#123;<br>pages() &#123;<br>          return unique([1, this.totalPage,<br>            this.currentPage,<br>            this.currentPage - 1, this.currentPage - 2,<br>            this.currentPage + 1, this.currentPage + 2]<br>            .filter((n) &#x3D;&gt; n &gt;&#x3D; 1 &amp;&amp; n &lt;&#x3D; this.totalPage)<br>            .sort((a, b) &#x3D;&gt; a - b))<br>            .reduce((prev, current, index, array) &#x3D;&gt; &#123;<br>              prev.push(current)<br>              array[index + 1] !&#x3D;&#x3D; undefined &amp;&amp; array[index + 1] - array[index] &gt; 1 &amp;&amp; prev.push(&#39;...&#39;)<br>              return prev<br>            &#125;, [])<br>        &#125;<br>&#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li><p>页码切换。页码切换处理起来很简单，给页码和前进后退按钮绑定点击事件，传入点击的页码或-1、+1，通过<code>$emit</code>提交更新的值和<code>change</code>事件，父组件可通过<code>.sync</code>或者监听<code>change</code>事件来处理更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>    methods: &#123;<br>        onClickPage (n) &#123;<br>          if (n &gt;&#x3D; 1 &amp;&amp; n &lt;&#x3D; this.totalPage) &#123;<br>            this.$emit(&#39;update:currentPage&#39;, n)<br>            this.$emit(&#39;change&#39;, n)<br>          &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h2><p>已完成。</p><h2 id="vuepress设置"><a href="#vuepress设置" class="headerlink" title="vuepress设置"></a>vuepress设置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>pagination-demo</code>vue文件，内容就是我们要展示的<code>pagination</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>pagination</code>的md文件，内容就是放置整个<code>pagination</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/pagination.html">访问这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[9]-Carousel</title>
    <link href="/2020/10/31/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B9%5D-Carousel/"/>
    <url>/2020/10/31/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B9%5D-Carousel/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li>轮播分为有缝轮播和无缝轮播，这里采用的是无缝轮播。</li><li>轮播功能主要基于<a href="https://cn.vuejs.org/v2/guide/transitions.html">vue过渡&amp;动画</a>实现，建议对这方面做一定的了解，很好用。</li><li>加上<code>touchStart</code>和<code>touchEnd</code>事件处理，增加对移动端的支持。</li><li>本次父子组件通信使用<code>$parent</code>和<code>$children</code>。</li><li>使用到了<code>updated</code>生命周期来处理轮播的选中更新等操作。</li></ol><a id="more"></a><h2 id="功能细节"><a href="#功能细节" class="headerlink" title="功能细节"></a>功能细节</h2><ol><li><p>无缝轮播设计的坑。这里实现无缝轮播的思路是将所有要轮播的元素都放在同一行的第一个位置，这就有两种考虑方案，一种是使用<strong>绝对定位</strong>，另一种就是父元素使用<strong>flex布局</strong>，显然是绝对定位方案比较好。然后使用了绝对定位方案之后又有坑：原先父级元素是没有设置高度由轮播元素撑起，但是使用绝对定位之后，子元素<strong>脱离了文档流</strong>就造成了父元素高度塌陷。那么首先想到使用JS去获取第一个元素的高度，但是如果是图片的话，图片是异步获取一般几百毫秒后才能拿到宽高，显然不行；还有一种是常见的让用户设置宽高，但如果是响应式的网站，让用户基于多种情况去设置是一件很不现实的事情。那最后的解决方案，还是要充分利用vue所提供的东西，在轮播动画离开（对应的类名<code>leave-active</code>）的时候，才让元素绝对定位，这样的话先前的元素就能撑起父元素的高度了，再配合vue提供的其它动画来实现轮播效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;transition name&#x3D;&quot;slide&quot;&gt;<br>    &lt;div class&#x3D;&quot;yv-carousel-item__content&quot; v-if&#x3D;&quot;visible&quot;&gt;<br>        &lt;slot&gt;&lt;&#x2F;slot&gt;<br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;transition&gt;<br><br>&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;<br> .slide-leave-active &#123;<br>    position: absolute;<br>    left: 0; top: 0;<br>    width: 100%;<br>    height: 100%;<br> &#125;<br>.slide-enter-active, .slide-leave-active &#123;<br>    transition: all 0.5s;<br> &#125;<br>.slide-enter &#123;<br>    transform: translateX(100%);<br>&#125;<br>.slide-leave-to &#123;<br>    transform: translateX(-100%);<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure></li><li><p>处理子组件选中状态。在父组件<code>Carousel</code>挂载后进行子组件选中状态的处理，以及处理后轮播跳转到前一个轮播的后退动画处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Carousel.vue --&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    mounted() &#123;<br>      this.updateChildren()<br>      if (this.autoPlay) &#123;<br>        this.playAutomatically()<br>      &#125;<br>      this.childrenLength &#x3D; this.items.length<br>    &#125;,<br>    methods: &#123;<br>      updateChildren() &#123;<br>        let selected &#x3D; this.getSelected()<br>        this.items.forEach((vm) &#x3D;&gt; &#123;<br>          let reverse &#x3D; this.selectedIndex &lt;&#x3D; this.lastSelectedIndex<br>          if (this.timerId) &#123;<br>            if (this.lastSelectedIndex &#x3D;&#x3D;&#x3D; this.items.length - 1 &amp;&amp; this.selectedIndex &#x3D;&#x3D;&#x3D; 0) &#123;<br>           reverse &#x3D; false<br>            &#125;<br>            if (this.lastSelectedIndex &#x3D;&#x3D;&#x3D; 0 &amp;&amp; this.selectedIndex &#x3D;&#x3D;&#x3D; this.items.length - 1) &#123;<br>              reverse &#x3D; true<br>            &#125;<br>          &#125;<br>          vm.reverse &#x3D; reverse<br>          this.$nextTick(() &#x3D;&gt; &#123;<br>            vm.selected &#x3D; selected<br>          &#125;)<br>        &#125;)<br>      &#125;,<br>      getSelected() &#123;<br>        let first &#x3D; this.items[0]<br>        return this.selected || first.name<br>      &#125;<br>    &#125;<br>  &#125;<br> &lt;&#x2F;script&gt;<br><br>&lt;!-- CarouselItem.vue --&gt;<br>&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;<br>  &#x2F;&#x2F; ...<br>  .slide-enter.reverse &#123;<br>    transform: translateX(-100%);<br>  &#125;<br>  .slide-leave-to.reverse &#123;<br>    transform: translateX(100%);<br>  &#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p>上面使用了<code>$nextTick</code>来解决更新不及时的问题，同时更新的时候也要通知，这里用到了<code>update</code>生命周期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    updated() &#123;<br>      this.updateChildren()<br>    &#125;,<br>  &#125;<br> &lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li><p>点击圆点、前后箭头显示对应的轮播。点击事件主要做了记录点击前轮播的索引，以及后面自动轮播时边界情况处理，如最后一个轮播时下一个是显示第一个轮播的处理等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    methods: &#123;<br>      onClickPrev() &#123;<br>        this.select(this.selectedIndex - 1)<br>      &#125;,<br>      onClickNext() &#123;<br>        this.select(this.selectedIndex + 1)<br>      &#125;,<br>      select(newIndex) &#123;<br>        this.lastSelectedIndex &#x3D; this.selectedIndex<br>        if (newIndex &#x3D;&#x3D;&#x3D; -1) &#123;<br>          newIndex &#x3D; this.names.length - 1<br>        &#125;<br>        if (newIndex &#x3D;&#x3D;&#x3D; this.names.length) &#123;<br>          newIndex &#x3D; 0<br>        &#125;<br>        this.$emit(&#39;update:selected&#39;, this.names[newIndex])<br>      &#125;<br>    &#125;<br>  &#125;<br> &lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li><p>自动轮播以及暂停处理。鼠标移入或移出时也要进行相应的处理，主要通过定时器控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    methods: &#123;<br>      onMouseEnter() &#123;<br>        this.pause()<br>      &#125;,<br>      onMouseLeave() &#123;<br>        this.playAutomatically()<br>      &#125;,<br>      playAutomatically() &#123;<br>        if (this.timerId) &#123;<br>          return<br>        &#125;<br>        let run &#x3D; () &#x3D;&gt; &#123;<br>          let index &#x3D; this.names.indexOf(this.getSelected())<br>          let newIndex &#x3D; index + 1<br>          this.select(newIndex)<br>          this.timerId &#x3D; setTimeout(run, this.autoPlayDelay)<br>        &#125;<br>        this.timerId &#x3D; setTimeout(run, this.autoPlayDelay)<br>      &#125;,<br>      pause() &#123;<br>        window.clearTimeout(this.timerId)<br>        this.timerId &#x3D; undefined<br>      &#125;,<br>      getSelected() &#123;<br>        &#x2F;&#x2F; ...<br>      &#125;,<br>      select(newIndex) &#123;<br>        &#x2F;&#x2F; ...<br>      &#125;<br>    &#125;<br>  &#125;<br> &lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li><p>加上<code>touchStart</code>和<code>touchEnd</code>事件处理，增加对移动端的支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    methods: &#123;<br>      onTouchStart(e) &#123;<br>        this.pause()<br>        if (e.touches.length &gt; 1) &#123;<br>          return<br>        &#125;<br>        this.startTouch &#x3D; e.touches[0]<br>      &#125;,<br>      onTouchEnd(e) &#123;<br>        let endTouch &#x3D; e.changedTouches[0]<br>        let &#123;clientX: x1, clientY: y1&#125; &#x3D; this.startTouch<br>        let &#123;clientX: x2, clientY: y2&#125; &#x3D; endTouch<br>        let distance &#x3D; Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))<br>        let deltaY &#x3D; Math.abs(y2 - y1)<br>        let rate &#x3D; distance &#x2F; deltaY<br>        if (rate &gt; 2) &#123;<br>          if (x2 &gt; x1) &#123;<br>            this.select(this.selectedIndex - 1)<br>          &#125; else &#123;<br>            this.select(this.selectedIndex + 1)<br>          &#125;<br>        &#125;<br>        this.$nextTick(() &#x3D;&gt; &#123;<br>          this.playAutomatically()<br>        &#125;)<br>      &#125;,<br>    &#125;<br>  &#125;<br> &lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="vuepress配置"><a href="#vuepress配置" class="headerlink" title="vuepress配置"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>carousel-demo</code>vue文件，内容就是我们要展示的<code>carousel</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>carousel</code>的md文件，内容就是放置整个<code>carousel</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/carousel.html">访问这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[8]-Collapse</title>
    <link href="/2020/10/15/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B8%5D-Collapse/"/>
    <url>/2020/10/15/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B8%5D-Collapse/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li>展示模式。默认可以同时展示多个折叠面板，也可以通过设置<code>single</code>属性来开启手风琴模式，即每次只能展示一个折叠面板。</li><li>控制打开与关闭采用单向数据流。关于折叠面板的开关控制方式，在多次试错后，决定采用单向数据流的方式：新建一个<strong>事件总线eventBus</strong>，点击折叠面板后，该子组件不直接操控自身的开启或关闭，而是通过<strong>eventBus</strong>去通知父组件，然后由父组件进行某些逻辑处理后，再通过<strong>eventBus</strong>向子组件传递事件，子组件收到事件后，再判断是开启还是关闭。</li></ol><a id="more"></a><h2 id="功能细节"><a href="#功能细节" class="headerlink" title="功能细节"></a>功能细节</h2><ol><li><p>绑定值的使用。这里的绑定值会加上<code>.sync</code>修饰符，然后在<code>collapse</code>组件里通过提交<code>update:selected</code>事件来更新绑定值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>        mounted() &#123;<br>            &#x2F;&#x2F; 处理值的逻辑<br>            &#x2F;&#x2F; ...<br>            this.$emit(&#39;update:selected&#39;, this.selectedArray)<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li><p>处理选中值。区分<strong>手风琴</strong>和<strong>多面板展示</strong>两种模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>        mounted() &#123;<br>            &#x2F;&#x2F; 一开始就广播事件<br>            this.eventBus.$emit(&#39;update:selected&#39;, this.selected)<br>            &#x2F;&#x2F; 监听添加选中事件<br>            this.eventBus.$on(&#39;update:addSelected&#39;, (name) &#x3D;&gt; &#123;<br>                &#x2F;&#x2F; 对selected做深拷贝处理<br>                this.selectedArray &#x3D; JSON.parse(JSON.stringify(this.selected))<br>                if (this.single) &#123;<br>                    this.selectedArray &#x3D; [name]<br>                &#125; else &#123;<br>                    this.selectedArray.push(name)<br>                &#125;<br>                &#x2F;&#x2F; 通过eventBus广播事件，子组件监听该事件<br>                this.eventBus.$emit(&#39;update:selected&#39;, this.selectedArray)<br>                &#x2F;&#x2F; 上面第1点讲到的，更新selected值<br>                this.$emit(&#39;update:selected&#39;, this.selectedArray)<br>            &#125;)<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>判断<code>single</code>值是否为真，为真则将name值设置为数组的唯一值，否则将name值push进数组。</p></li><li><p>移除非选中值。无需区分模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>        mounted() &#123;<br>            &#x2F;&#x2F; 一开始就广播事件<br>            this.eventBus.$emit(&#39;update:selected&#39;, this.selected)<br>            &#x2F;&#x2F; 监听添加选中事件<br>            &#x2F;&#x2F; ...<br>            <br>            &#x2F;&#x2F; 监听选中移除事件<br>            this.eventBus.$on(&#39;update:removeSelected&#39;, (name) &#x3D;&gt; &#123;<br>                this.selectedArray &#x3D; JSON.parse(JSON.stringify(this.selected))<br>                &#x2F;&#x2F; 找到当前移除值的索引值<br>                let index &#x3D; this.selectedArray.indexOf(name)<br>                &#x2F;&#x2F; 移除<br>                this.selectedArray.splice(index, 1)<br>                &#x2F;&#x2F; 通过eventBus广播事件，子组件监听该事件<br>                this.eventBus.$emit(&#39;update:selected&#39;, this.selectedArray)<br>                &#x2F;&#x2F; 上面第1点讲到的，更新selected值<br>                this.$emit(&#39;update:selected&#39;, this.selectedArray)<br>            &#125;)<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li><p>处理子组件点击事件。设计细节里面有说到，子组件点击时，不直接处理自身的开启/关闭事件，而是通过<strong>eventBus</strong>广播<code>addSelected</code>或<code>removeSelected</code>事件，而父组件监听事件并做逻辑处理（第2、3点）后再广播<code>update:selected</code>事件，子组件监听事件拿到选中的值后判断是否有自己，有则打开。这样就完成了一个单向数据流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>        mounted() &#123;<br>            &#x2F;&#x2F; 监听事件 看选中的值中是否有自己 有则打开<br>            this.eventBus &amp;&amp; this.eventBus.$on(&#39;update:selected&#39;, (names) &#x3D;&gt; &#123;<br>                this.open &#x3D; names.indexOf(this.name) &gt;&#x3D; 0<br>            &#125;)<br>        &#125;,<br>        methods: &#123;<br>            toggle() &#123;<br>                if (this.open) &#123;<br>                    this.eventBus &amp;&amp; this.eventBus.$emit(&#39;update:removeSelected&#39;, this.name)<br>                &#125; else &#123;<br>                    this.eventBus &amp;&amp; this.eventBus.$emit(&#39;update:addSelected&#39;, this.name)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="vuepress配置"><a href="#vuepress配置" class="headerlink" title="vuepress配置"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>collapse-basic</code>和<code>collapse-single</code>vue文件，内容就是我们要展示的<code>collapse</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>collapse</code>的md文件，内容就是放置整个<code>collapse</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/collapse.html">访问这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[7]-Popover</title>
    <link href="/2020/10/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B7%5D-Popover/"/>
    <url>/2020/10/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B7%5D-Popover/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li>触发方式。可设置通过<code>trigger</code>属性设置<strong>点击click</strong>或者<strong>覆盖hover</strong>触发弹出框。同时通过点击触发的弹出框，再次点击或者点击页面其它地方，将会关闭该弹出框，但点击弹出框区域不关闭。</li><li>弹出位置。可通过<code>position</code>属性设置弹出位置，有<strong>顶部top</strong>、<strong>底部bottom</strong>、<strong>左侧left</strong>和<strong>右侧right</strong>。</li></ol><a id="more"></a><h2 id="功能细节"><a href="#功能细节" class="headerlink" title="功能细节"></a>功能细节</h2><ol><li><p>弹出框元素层级。遇到的第一个坑，弹出层的容器是放在popover里面的，看下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class&#x3D;&#39;yv-popover&#39; ref&#x3D;&quot;popover&quot;&gt;<br>        &lt;div class&#x3D;&quot;content-wrapper&quot;&gt;<br>          &lt;slot name&#x3D;&quot;content&quot;&gt;&lt;&#x2F;slot&gt;<br>        &lt;&#x2F;div&gt;<br>        &lt;span ref&#x3D;&quot;triggerWrapper&quot;&gt;<br>          &lt;slot&gt;&lt;&#x2F;slot&gt;<br>        &lt;&#x2F;span&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br></code></pre></td></tr></table></figure><p>如果popover的父容器设置了<code>overflow: hidden</code>的样式值，弹出层的内容就会被隐藏。解决方案就是让弹出层放在body里面而不是popover里面，这样弹出框就不会受到包含了popover的元素的影响。</p></li><li><p>弹出框的定位值。这是继第一个坑之后的坑。弹出框是设置了绝对定位，在它出现在body里面之前，它是相对于popover容器定位，出现在body里面之后，就是相对于body定位，所以坑就出现了，如果当前位置超过了当前视口的大小而出现了滚动条，弹出框出现的位置一直是相对于body的位置而不能精准出现在当前视口，看下图示：</p><p><img src="/images/popover1.png"></p><p>从图示可以看到popover弹出框出现的位置并没有在浏览器视口中，解决方案就是需要加上滚动条的高度，即<code>window.scrollY</code>，同理，左边需要加上<code>window.screenX</code>，具体的设置请看<strong>弹出位置设置</strong>。</p></li><li><p>设置弹出框的位置。这里不管弹出位置在上下还是左右，都通过top和left来设置位置，所以写成一个对象，到时通过传入值来匹配：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> positions = &#123;<br>top: &#123;<br>        top: <span class="hljs-string">&#x27;&#x27;</span>,<br>        left: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;,<br>    bottom: &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;,<br>    left: &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;,<br>    right: &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顶部位置就是一开始的设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">top: &#123;<br>    top: top + <span class="hljs-built_in">window</span>.scrollY,<br>    left: left + <span class="hljs-built_in">window</span>.screenX,<br>&#125;<br></code></pre></td></tr></table></figure><p>底部位置：由于是出现在content底部，所以top值还需要加上content本身的高度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">bottom: &#123;<br>    top: top + height + <span class="hljs-built_in">window</span>.scrollY,<br>    left: left + <span class="hljs-built_in">window</span>.screenX<br>&#125;<br></code></pre></td></tr></table></figure><p>左侧位置和右侧位置：一般两个元素并列居中展示会看着比较舒服，如果让弹出层和content层居中展示呢？将top值加上用两个元素之间的差值除以2的值，得到的就是弹出层的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">left: &#123;<br>    top: top + <span class="hljs-built_in">window</span>.scrollY + (height - contentHeight) / <span class="hljs-number">2</span>,<br>    left: left + <span class="hljs-built_in">window</span>.screenX<br>&#125;<br></code></pre></td></tr></table></figure><p>同时由于在右侧弹出，所以右侧的left值还需加上content的宽度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">right: &#123;<br>    top: top + <span class="hljs-built_in">window</span>.scrollY + (height - contentHeight) / <span class="hljs-number">2</span>,<br>    left: left + width + <span class="hljs-built_in">window</span>.screenX<br>&#125;<br></code></pre></td></tr></table></figure><p>上面所用到的left、width等均来自：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; contentWrapper, triggerWrapper &#125; = <span class="hljs-built_in">this</span>.$refs<br><span class="hljs-keyword">let</span> &#123; width, height, left, top &#125; = triggerWrapper.getBoundingClientRect()<br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">height</span>: contentHeight &#125; = contentWrapper.getBoundingClientRect()<br></code></pre></td></tr></table></figure><p>然后根据用户传进来的<code>position</code>位置属性值，给弹出层<code>contentWrapper</code>赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">contentWrapper.style.top = positions[<span class="hljs-built_in">this</span>.position].top + <span class="hljs-string">&#x27;px&#x27;</span><br>contentWrapper.style.left = positions[<span class="hljs-built_in">this</span>.position].left + <span class="hljs-string">&#x27;px&#x27;</span><br></code></pre></td></tr></table></figure><p>最后还有优化的地方，即给弹出框加上一个小尾巴，这个属于CSS范畴且样式代码比较多，同样也是要分成上下左右四部分设置，看源码即可。</p></li><li><p>触发方式的处理。点击方式通过给<strong>document</strong>添加<strong>click</strong>监听事件，这里有个点需要注意，如果是给<strong>body</strong>添加<strong>click</strong>监听，有可能会出现因为body<strong>高度不够</strong>而点击不到的问题。<strong>hover</strong>触发方式是通过给<code>popover</code>添加<strong>mouseenter</strong>和<strong>mouseleave</strong>监听事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    mounted() &#123;<br>      if (this.trigger &#x3D;&#x3D;&#x3D; &#39;click&#39;) &#123;<br>      this.$refs.popover.addEventListener(&#39;click&#39;, (e) &#x3D;&gt; &#123;<br>          this.showPopover(e)<br>        &#125;)<br>      &#125; else &#123;<br>          this.$refs.popover.addEventListener(&#39;mouseenter&#39;, () &#x3D;&gt; &#123;<br>            this.open()<br>          &#125;)<br>          this.$refs.popover.addEventListener(&#39;mouseleave&#39;, () &#x3D;&gt; &#123;<br>            this.close()<br>          &#125;)<br>        &#125;<br>      &#125;<br>  &#125;<br> &lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>点击关闭弹出框的处理。对于点击后弹出的弹出框，需求是再次点击触发的区域或者页面其它地方，会关闭弹出框，点击弹出框自身不关闭。这个需求开发过程中也出现一些坑：第一个大坑是在第一次开启关闭弹出框之后，已经给document添加了监听事件，在第二次以及后面的点击弹出框时，由于事件冒泡机制，会依次触发：<strong>点击popover弹出弹出框</strong> -&gt; <strong>点击document关闭弹出框</strong>，就会造成一个问题，弹出框刚弹出马上就被关闭了，看不到弹出框；第二个坑是关闭事件没有统一处理起来，每个需要关闭的地方都要写一遍，如果关闭的时候忘记对document取消监听click事件，就会导致后面弹出的弹出框关闭的时候会触发多次关闭事件。</p><p>针对第二个问题，先将关闭事件内聚，统一写成一个方法，将弹出框关闭，并移除对click事件的监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br> export default &#123;<br>   methods: &#123;<br>    close() &#123;<br>      this.visible &#x3D; false<br>      document.removeEventListener(&#39;click&#39;, this.eventHandler)<br>    &#125; <br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>针对第一个问题，本来是用<code>click.stop</code>加上修饰符<code>.stop</code>来阻止事件冒泡，这样在点击popover的时候就不会再触发document的点击事件，但是这样会导致用户在包裹了popover的元素上自定义的click事件失效，这显然是不行的。最后的解决方案就是各自管各自的，即document只管自己的，popover只管popover的，具体通过click事件中的参数<code>event.target</code>来判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default &#123;<br>    methods: &#123;<br>     eventHandler(e) &#123;<br>       if (this.$refs.popover &amp;&amp; (this.$refs.popover &#x3D;&#x3D;&#x3D; e.target || this.$refs.popover.contains(e.target))) &#123;<br>         return<br>       &#125;<br>       if (this.$refs.contentWrapper &amp;&amp; (this.$refs.contentWrapper &#x3D;&#x3D;&#x3D; e.target || this.$refs.contentWrapper.contains(e.target))) &#123;<br>         return<br>       &#125;<br>       this.close()<br>     &#125;,<br>    &#125;<br>  &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>有两个判断，如果当前存在<strong>popover</strong>、<strong>contentWrapper</strong>，并且<strong>popover</strong>或者<strong>contentWrapper</strong>等于或包含了<code>e.target</code>，则不做任何处理直接返回。若不是，则调用close事件。</p></li></ol><h2 id="vuepress配置"><a href="#vuepress配置" class="headerlink" title="vuepress配置"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>popover-demo</code>vue文件，内容就是我们要展示的<code>popover</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>popover</code>的md文件，内容就是放置整个<code>popover</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/popover.html">访问这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[6]-Toast</title>
    <link href="/2020/09/29/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B6%5D-Toast/"/>
    <url>/2020/09/29/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B6%5D-Toast/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li>兼容性设计。在设计关闭提示框按钮的时候，有考虑要如何实现：如果是一个关闭图标，在移动端的交互体验会有点差，因为图标太小，手指有可能很难点击命中；所以将关闭区域设置得稍微大一点，在提示文案的右边区域作为关闭点击区域，同时支持设置点击回调函数。</li><li>方向设置。可设置提示框的弹出方向，按时钟顺序包括：上、右、下、左、中。</li><li>自动关闭。可设置自动关闭以及关闭的时间。</li></ol><a id="more"></a><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><ol><li><p>开发为插件。对于toast的定位就是有点击等操作时可以通过<code>this.$toast</code>直接调用toast，一开始的想法是直接在<code>Vue.prototype</code>上添加，但是这种方案有弊端，就是无法确定<code>Vue.prototype.$toast</code>能不能直接用，会不会已经被用户设置成其它的，所以这样的修改的决定权还是得交给用户，因此我们可以采用<a href="https://cn.vuejs.org/v2/guide/plugins.html">vue的插件机制</a>来完成这件事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">install</span>(<span class="hljs-params">Vue, options</span>)</span> &#123;<br>    Vue.prototype.$toast = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">toastOptions</span>) </span>&#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>动态创建。使用<code>this.$toast</code>的时候可以生成toast组件，包含了指定的内容，然后挂载到页面中，同时还要兼容处理页面中同时只能有一个toast，如果生成之前已经有了toast组件，需要先销毁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// plugin.js</span><br><span class="hljs-keyword">let</span> currentToast<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">install</span>(<span class="hljs-params">Vue, options</span>)</span> &#123;<br>    Vue.prototype.$toast = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">toastOptions</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (currentToast) &#123;<br>        currentToast.onClose()<br>      &#125;<br>      currentToast = createToast(&#123;<br>        Vue,<br>        propsData: toastOptions,<br>        onClose: <span class="hljs-function">() =&gt;</span> &#123;<br>          currentToast = <span class="hljs-literal">null</span><br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createToast</span>(<span class="hljs-params">&#123; Vue, propsData, onClose &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> Constructor = Vue.extend(Toast)<br>  <span class="hljs-keyword">const</span> toast = <span class="hljs-keyword">new</span> Constructor(&#123; propsData &#125;)<br>  toast.$slots.default = [propsData.message]<br>  toast.$mount()<br>  toast.$on(<span class="hljs-string">&#x27;close&#x27;</span>, onClose)<br>  <span class="hljs-built_in">document</span>.body.appendChild(toast.$el)<br>  <span class="hljs-keyword">return</span> toast<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Toast.vue --&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    name: &quot;YvToast&quot;,<br>    methods: &#123;<br>      &#x2F;&#x2F; ...<br>      onClose() &#123;<br>        this.$el.remove()<br>        this.$emit(&#39;close&#39;)<br>        this.$destroy()<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li><li><p>设置toast出现动画。这里有个坑，就是toast 动画中的属性 <code>transform: translate()</code> 在使用了 fixed 绝对定位后与 <code>transform: translate()</code> 发生了冲突，解决方案是在toast外套一层wrapper负责fixed定位，toast自身负责动画：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@keyframes</span> pushToast-top &#123;<br>   0% &#123;<span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">transform</span>: translateY(-<span class="hljs-number">100%</span>)&#125;<br>   <span class="hljs-number">100%</span> &#123;opacity: <span class="hljs-number">1</span>;<span class="hljs-attribute">transform</span>: translateY(<span class="hljs-number">0</span>)&#125;<br>&#125;<br>@keyframes pushToast-bottom &#123;<br>   <span class="hljs-number">0%</span> &#123;opacity: <span class="hljs-number">0</span>;<span class="hljs-attribute">transform</span>: translateY(<span class="hljs-number">100%</span>)&#125;<br>   <span class="hljs-number">100%</span> &#123;opacity: <span class="hljs-number">1</span>;<span class="hljs-attribute">transform</span>: translateY(<span class="hljs-number">0</span>)&#125;<br>&#125;<br>@keyframes pushToast-middle &#123;<br>   <span class="hljs-number">0%</span> &#123;opacity: <span class="hljs-number">0</span>;&#125;<br>   100% &#123;<span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;&#125;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> pushToast-left &#123;<br>   0% &#123;<span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">transform</span>: translateX(-<span class="hljs-number">100%</span>)&#125;<br>   <span class="hljs-number">100%</span> &#123;opacity: <span class="hljs-number">1</span>;<span class="hljs-attribute">transform</span>: translateY(<span class="hljs-number">0</span>)&#125;<br>&#125;<br>@keyframes pushToast-right &#123;<br>   <span class="hljs-number">0%</span> &#123;opacity: <span class="hljs-number">0</span>;<span class="hljs-attribute">transform</span>: translateX(<span class="hljs-number">100%</span>)&#125;<br>   <span class="hljs-number">100%</span> &#123;opacity: <span class="hljs-number">1</span>;<span class="hljs-attribute">transform</span>: translateY(<span class="hljs-number">0</span>)&#125;<br>&#125;<br><br>.wrapper &#123;<br>    position: fixed;<br>    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">9999</span>;<br>    &amp;<span class="hljs-selector-class">.toast-position-top</span> &#123;<br>       <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>       <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>       <span class="hljs-attribute">transform</span>: translateX(-<span class="hljs-number">50%</span>);<br>       <span class="hljs-selector-class">.yv-toast</span> &#123;<br>         <span class="hljs-attribute">animation</span>: pushToast-top .<span class="hljs-number">3s</span>;<br>       &#125;<br>    &#125;<br>    &amp;<span class="hljs-selector-class">.toast-position-right</span> &#123;<br>        <span class="hljs-attribute">right</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>        <span class="hljs-attribute">transform</span>: translateY(-<span class="hljs-number">50%</span>);<br>        <span class="hljs-selector-class">.yv-toast</span> &#123;<br>            <span class="hljs-attribute">animation</span>: pushToast-right .<span class="hljs-number">3s</span>;<br>        &#125;<br>    &#125;<br>    &amp;<span class="hljs-selector-class">.toast-position-bottom</span> &#123;<br>        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>        <span class="hljs-attribute">transform</span>: translateX(-<span class="hljs-number">50%</span>);<br>        <span class="hljs-selector-class">.yv-toast</span> &#123;<br>            <span class="hljs-attribute">animation</span>: pushToast-bottom .<span class="hljs-number">3s</span>;<br>        &#125;<br>    &#125;<br>    &amp;<span class="hljs-selector-class">.toast-position-left</span> &#123;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>        <span class="hljs-attribute">transform</span>: translateY(-<span class="hljs-number">50%</span>);<br>        <span class="hljs-selector-class">.yv-toast</span> &#123;<br>            <span class="hljs-attribute">animation</span>: pushToast-left .<span class="hljs-number">3s</span>;<br>        &#125;<br>    &#125;<br>    &amp;<span class="hljs-selector-class">.toast-position-middle</span> &#123;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>        <span class="hljs-attribute">transform</span>: translate(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>        <span class="hljs-selector-class">.yv-toast</span>&#123;<br>            <span class="hljs-attribute">animation</span>: pushToast-middle <span class="hljs-number">1s</span>;<br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h2><p>手动测试。。。已完成。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>未完成。</p><h2 id="vuepress设置"><a href="#vuepress设置" class="headerlink" title="vuepress设置"></a>vuepress设置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>toast-basic</code>和<code>toast-close</code>vue文件，内容就是我们要展示的<code>toast</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>toast</code>的md文件，内容就是放置整个<code>toast</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/toast.html">访问这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[5]-Tabs</title>
    <link href="/2020/09/25/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B5%5D-Tabs/"/>
    <url>/2020/09/25/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B5%5D-Tabs/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li><p>结构分明。为了让结构层次更明显，在<code>tabs-head</code>里面有子组件<code>tabs-item</code>，在<code>tabs-body</code>里面有子组件<code>tabs-pane</code>，表示各自的标签与内容。</p><p>但结构分明的同时也有些许缺陷，就是<code>tabs-item</code>和<code>tabs-pane</code>都要加上相同的<code>name</code>属性，对于喜欢“偷懒”的程序猿来说，多写一遍属性是比较麻烦的事情。</p></li></ol><a id="more"></a><h2 id="功能细节"><a href="#功能细节" class="headerlink" title="功能细节"></a>功能细节</h2><ol><li><p>组件通信。由于存在爷 -&gt; 父 -&gt; 孙组件的通信，为了让通信更方便，使用<code>provide</code>和<code>inject</code>。</p></li><li><p>事件通信。还是上面的原因，为了让多层组件的通信更简单，这里使用了事件总线eventBus，通过new一个vue实例，将这个实例通过provide传递，inject接收，来实现组件之间的事件通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; tabs.vue<br><br>import Vue from &#39;vue&#39;<br>export default &#123;<br>  name: &quot;YvTabs&quot;,<br>  provide() &#123;<br>    return &#123;<br>      eventBus: this.eventBus<br>    &#125;<br>  &#125;,<br>&#x2F;&#x2F; ...<br>  data() &#123;<br>    return &#123;<br>      eventBus: new Vue()<br>    &#125;<br>  &#125;,<br>&#x2F;&#x2F; ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h2><p>手动测试。。。已完成。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>在<strong>test</strong>文件夹下增加<code>tabs.test.js</code>和<code>tabs-item.test.js</code>文件。</p><p>因为<code>tabs-pane</code>和<code>tabs-item</code>基本一致，这里就不再做自动化测试了。</p><p><code>tabs.test.js</code>文件有2个测试用例：<strong>测试tabs是否存在</strong>、<strong>接收selected</strong>；</p><p><code>tabs-item.test.js</code>文件有4个测试用例：<strong>测试tabs-item是否存在</strong>、<strong>接收name</strong>、<strong>接收disabled</strong>、<strong>点击事件</strong>。  </p><p>运行命令<code>parcel watch test/* --no-cache</code>和<code>karma start</code>查看测试结果：</p><p><img src="/images/tabs-test.png" alt="tabs测试结果"></p><h2 id="vuepress"><a href="#vuepress" class="headerlink" title="vuepress"></a>vuepress</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加多个<code>tabs-demo</code>的vue文件，内容就是我们要展示的<code>tabs</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>tabs</code>的md文件，内容就是放置整个<code>tabs</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/tabs.html">访问这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左手绿皮，右手红宝</title>
    <link href="/2020/09/20/%E5%B7%A6%E6%89%8B%E7%BB%BF%E7%9A%AE%EF%BC%8C%E5%8F%B3%E6%89%8B%E7%BA%A2%E5%AE%9D/"/>
    <url>/2020/09/20/%E5%B7%A6%E6%89%8B%E7%BB%BF%E7%9A%AE%EF%BC%8C%E5%8F%B3%E6%89%8B%E7%BA%A2%E5%AE%9D/</url>
    
    <content type="html"><![CDATA[<p>买的两本书今天都到了，就是前端比较热门和重量级的两本书：<strong>《JavaScript语言精髓和编程实践（第三版）》</strong>和<strong>《JavaScript高级程序设计（第四版）》</strong>，也就是大家常说的绿皮书和红宝书，一本是今年4月份出版，一本是9月份刚出版。</p><p>献上图过过瘾</p><a id="more"></a><img src="/images/3and4.jpg" alt="绿皮书和红宝书" width="560px" height="400px"/><p>看了目录以及部分内容，个人感觉绿皮书是偏“<strong>阐释</strong>”的，就像是修炼JS内功，目的在于告诉你<strong>为什么</strong>，而不是教你<strong>如何用</strong>，跟市面上其它书就是<strong>思维型</strong>与<strong>实战型</strong>的区别。</p><p>红宝书还是一如既往地适合各个阶段的前端开发者阅读，时隔8年，第三版坐着的小孩如今也已经站了起来。今年第四版图灵更是贴心地提供了<strong>前端学习路线图</strong>和<strong>第四版阅读路线图</strong>，这对于新手和刚入门的前端算是指引了前进的方向。看下路线图长啥样：</p><img src="/images/red4route.jpg" alt="高4阅读路线" width="490" height="350" /><img src="/images/tllearnroute.jpg" alt="图灵前端学习路线" width="490" height="350" /><p>这两本“<strong>厚重</strong>”的书够看一段时间了，加上昨天尤大大官宣<code>vue3.0 one piece</code>发布，需要看的东西又多了起来，只能左手绿皮，右手红宝努力去找寻前端的<strong>one piece</strong>了~</p>]]></content>
    
    
    <categories>
      
      <category>书籍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[4]-Container</title>
    <link href="/2020/09/16/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B4%5D-Container/"/>
    <url>/2020/09/16/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B4%5D-Container/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><p>容器的功能比较简单，主要将页面切分成<code>头部header</code>、<code>侧边栏aside</code>、<code>主要区域main</code>、<code>底部footer</code>，这几个部分都放在<code>容器container</code>里。</p><a id="more"></a><p>在没有侧边栏的时候，container里的排列方向是<code>column</code>，当有侧边栏时，container里的排列方向就切换成<code>row</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  name: &quot;YvContainer&quot;,<br>  data() &#123;<br>    return &#123;<br>      containerClass: &#123;<br>        hasAside: false<br>      &#125;<br>    &#125;<br>  &#125;,<br>  mounted() &#123;<br>    this.$children.some(child &#x3D;&gt; &#123;<br>      if (child.$options.name &#x3D;&#x3D;&#x3D; &#39;YvAside&#39;) &#123;<br>        this.containerClass.hasAside &#x3D; true<br>        return true<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>通过遍历判断是否存在<code>aside</code>组件，存在<code>aside</code>的时候将<code>hasAside</code>设置为<code>true</code>，同时给<code>container</code>加上了<code>hasAside</code>的类，样式为<code>flex-direction: row</code></p><h2 id="vuepress配置"><a href="#vuepress配置" class="headerlink" title="vuepress配置"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>container-demo</code>的vue文件，内容就是我们要展示的<code>container</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>container</code>的md文件，内容就是放置整个<code>container</code>组件说明。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[3]-Layout</title>
    <link href="/2020/09/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B3%5D-Layout/"/>
    <url>/2020/09/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B3%5D-Layout/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li><code>row</code>组件默认采用<code>flex</code>布局，可通过<code>left</code>、<code>center</code>、<code>right</code>来设置对齐方式；</li><li><code>row</code>组件可通过设置<code>gutter</code>参数来设置列之间的间隔；</li><li><code>col</code>组件可通过设置<code>span</code>参数来设置不同列数，默认将宽度分为<strong>24</strong>列，同时可搭配<code>offset</code>参数来设置分栏偏移数；</li><li>响应式布局传递的参数不采用<code>element-ui</code>那些<code>xs</code>、<code>sm</code>参数，字面上不利于理解，<br>所以这里采用了<code>phone</code>、<code>iPad</code>、<code>narrowPC</code>和<code>widePC</code>等参数来分别表示在屏幕大小为<br>手机、平板、窄屏PC端和宽屏PC端下的展示。</li></ol><a id="more"></a><h2 id="功能处理细节"><a href="#功能处理细节" class="headerlink" title="功能处理细节"></a>功能处理细节</h2><ol><li><p><code>span</code>设置分栏数。默认将页面宽度分成了24等分，再通过<code>span/24</code>来算出分栏的占比，那要怎么设置各占比分栏宽度呢？如果直接通过<code>yv-col-1 ~ 24</code>这样写24个类名，就会出现一堆重复的代码，维护、改动也麻烦。幸好可以通过<strong>css预处理器</strong>来处理这种情况，<strong>预处理器</strong>可以像JS那样写变量，函数，可以为我们提供很多方便的操作，这里采用了<code>scss</code>来处理：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$n</span> from <span class="hljs-number">1</span> through <span class="hljs-number">24</span> &#123;<br>  <span class="hljs-variable">$class-prefix</span>: yv-col-;<br>  &amp;.#&#123;<span class="hljs-variable">$class-prefix</span>&#125;#&#123;<span class="hljs-variable">$n</span>&#125; &#123;<br>    <span class="hljs-attribute">width</span>: (<span class="hljs-variable">$n</span> / <span class="hljs-number">24</span>) * <span class="hljs-number">100%</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先设置通用前缀<code>yv-col-</code>，再通过for循环从1到24，算出每一份的宽度，这样就可以根据<code>span</code>的值得到对应的类名<code>yv-col-n</code>从而得到对应的宽度。包括<code>offset</code>设置偏移栏数也是如此：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$n</span> from <span class="hljs-number">1</span> through <span class="hljs-number">24</span> &#123;<br>  <span class="hljs-variable">$class-prefix</span>:yv-col-offset-;<br>  &amp;.#&#123;<span class="hljs-variable">$class-prefix</span>&#125;#&#123;<span class="hljs-variable">$n</span>&#125; &#123;<br>    <span class="hljs-attribute">margin-left</span>: (<span class="hljs-variable">$n</span> / <span class="hljs-number">24</span>) * <span class="hljs-number">100%</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>gutter</code>传参问题。设置分栏间隔是通过在<code>row</code>组件上面传递<code>gutter</code>参数，但实际上我们还得靠处理<code>col</code>组件来实现。一开始直接像下面这样直接把<code>gutter</code>传个每个<code>col</code>组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;yv-row :gutter&#x3D;&quot;10&quot;&gt;<br>  &lt;yv-col :gutter&#x3D;&quot;10&quot;&gt;&lt;&#x2F;yv-col&gt;<br>  &lt;yv-col :gutter&#x3D;&quot;10&quot;&gt;&lt;&#x2F;yv-col&gt;<br>&lt;&#x2F;yv-row&gt;<br></code></pre></td></tr></table></figure><p>看起来很不友好。这里可以使用父子组件通信的另一种方法：<code>$parent</code>和<code>$children</code>。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Row.vue --&gt;<br>mounted() &#123;<br>  this.$children.forEach(child &#x3D;&gt; &#123;<br>    child.gutter &#x3D; this.gutter<br>  &#125;)<br>&#125;<br><br>&lt;!-- Col.vue --&gt;<br>data() &#123;<br>  return &#123;<br>    gutter: 0<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>row</code>的生命周期<code>mounted</code>中通过<code>$children</code>给每个子组件的<code>gutter</code>属性赋值，同时<code>col</code>组件也要在<code>data</code>里面定义<code>gutter</code>属性。</p></li><li><p><code>gutter</code>具体设置问题。一开始的想法是直接给每一列的左右加上<code>gutter/2</code>的外边距，但是这会跟通过<code>offset</code>设置的偏移分栏外边距产生冲突。那么换成内边距如何呢？试下内边距的效果。<br><img src="/images/gutter-padding.png" alt="设置内边距效果"><br>从图片可以发现最左边跟最右边的分栏没有紧挨父级容器，这是设置了内边距的原因，跟父容器的空隙就是<code>gutter/2</code>px。解决方案是给父级容器加上<code>-gutter/2</code>的左右外边距，就ok了。</p></li><li><p>响应式处理。这里采用了<code>phone</code>、<code>iPad</code>、<code>narrowPC</code>、<code>widePC</code>这种直观的字段来表示不同屏幕宽度。通过<code>createClasses</code>方法来创建不同的类名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">computed: &#123;<br>  colClass() &#123;<br>    let &#123;<br>      span,<br>      offset,<br>      phone,<br>      iPad,<br>      narrowPC,<br>      widePC<br>    &#125; &#x3D; this<br>    return [<br>      &#39;yv-col&#39;,<br>      ...this.createClasses(phone, &#39;phone-&#39;),<br>      ...this.createClasses(iPad, &#39;iPad-&#39;),<br>      ...this.createClasses(narrowPC, &#39;narrowPC-&#39;),<br>      ...this.createClasses(widePC, &#39;widePC-&#39;),<br>      ...this.createClasses(&#123; span, offset &#125;)<br>    ]<br>  &#125;<br>&#125;,<br><br>methods: &#123;<br>  createClasses(obj, str &#x3D; &#39;&#39;) &#123;<br>    if (!obj) return []<br>    let arr &#x3D; []<br>    if (obj.span) &#123;<br>      arr.push(&#96;yv-col-$&#123;str&#125;$&#123;obj.span&#125;&#96;)<br>    &#125;<br>    if (obj.offset) &#123;<br>      arr.push(&#96;yv-col-$&#123;str&#125;offset-$&#123;obj.offset&#125;&#96;)<br>    &#125;<br>    return arr<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置一个计算属性<code>colClass</code>，根据传入不同的尺寸属性生成不同的class添加到col上面，再通过媒体查询的写法，来实现不同尺寸下的宽度计算：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@media</span> (min-width: <span class="hljs-number">0px</span>) &#123;<br>  <span class="hljs-keyword">@for</span> <span class="hljs-variable">$n</span> from <span class="hljs-number">1</span> through <span class="hljs-number">24</span> &#123;<br>    <span class="hljs-variable">$class-prefix</span>:yv-col-phone-;<br>    &amp;.#&#123;<span class="hljs-variable">$class-prefix</span>&#125;#&#123;<span class="hljs-variable">$n</span>&#125; &#123;<br>      <span class="hljs-attribute">width</span>: (<span class="hljs-variable">$n</span> / <span class="hljs-number">24</span>) * <span class="hljs-number">100%</span><br>    &#125;<br>  &#125;<br>  @for <span class="hljs-variable">$n</span> from <span class="hljs-number">1</span> through <span class="hljs-number">24</span> &#123;<br>    <span class="hljs-variable">$class-prefix</span>:yv-col-phone-offset-;<br>    &amp;.#&#123;<span class="hljs-variable">$class-prefix</span>&#125;#&#123;<span class="hljs-variable">$n</span>&#125; &#123;<br>      <span class="hljs-attribute">margin-left</span>: (<span class="hljs-variable">$n</span> / <span class="hljs-number">24</span>) * <span class="hljs-number">100%</span><br>    &#125;<br>  &#125;<br>&#125;<br>@media (min-width: <span class="hljs-number">577px</span>) &#123;<br>  // ...<br>&#125;<br>@media (min-width: <span class="hljs-number">769px</span>) &#123;<br>  // ...<br>&#125;<br>@media (min-width: <span class="hljs-number">993px</span>) &#123;<br>  // ...<br>&#125;<br>@media (min-width: <span class="hljs-number">1201px</span>) &#123;<br>  // ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h2><p>手动测试。。。已完成。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>在<strong>test</strong>文件夹下增加<code>row.test.js</code>和<code>col.test.js</code>文件。</p><p><code>row.test.js</code>文件有3个测试用例：<strong>测试row是否存在</strong>、<strong>接收getter</strong>、<strong>接收align</strong>；</p><p><code>col.test.js</code>文件有7个测试用例：<strong>测试col是否存在</strong>、<strong>接收span</strong>、<strong>接收offset</strong>、<strong>接收phone</strong>、<strong>接收iPad</strong>、<strong>接收narrowPC</strong>、<strong>接收widePC</strong>。</p><p>运行命令<code>parcel watch test/* --no-cache</code>和<code>karma start</code>查看测试结果：</p><p><img src="/images/layout-browser.png" alt="layout测试结果"></p><h2 id="vuepress"><a href="#vuepress" class="headerlink" title="vuepress"></a>vuepress</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加多个<code>layout-*</code>的vue文件，内容就是我们要展示的<code>layout</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>layout</code>的md文件，内容就是放置整个<code>layout</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/layout.html">访问这里</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[2]-Button</title>
    <link href="/2020/09/04/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B2%5D-Button/"/>
    <url>/2020/09/04/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B2%5D-Button/</url>
    
    <content type="html"><![CDATA[<h2 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h2><ol><li>高度最好为<strong>8</strong>的倍数，此处设置为<strong>32px</strong>；如果要支持大小类型的按钮，可设置为<strong>24px</strong>(<strong>small</strong>)和<strong>40px</strong>(<strong>large</strong>)；</li><li>按钮不设置固定宽度，左右<code>padding</code>设置为<strong>1em</strong>，表示左右各留一个字的空间；</li><li>因为<code>button</code>设置为<code>inline-flex</code>布局，在多个按钮并列时会存在位置不对齐的问题，使用<code>vertical-align: middle</code>解决。</li></ol><a id="more"></a><h2 id="功能细节"><a href="#功能细节" class="headerlink" title="功能细节"></a>功能细节</h2><ol><li>支持icon的设置。比较常见的场景是icon在文案左边或者右边，这个可以通过传入一个<code>iconPosition</code>为<strong>left</strong>或<strong>right</strong>来决定，一开始的想法是通过<code>v-if</code>来决定显示哪一行：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button&gt;<br>  &lt;yv-icon v-if&#x3D;&quot;iconPosition &#x3D;&#x3D;&#x3D; &#39;left&#39;&quot;&gt;&lt;&#x2F;yv-icon&gt;<br>  &lt;div class&#x3D;&quot;button-content&quot;&gt;&lt;&#x2F;div&gt;<br>  &lt;yv-icon v-if&#x3D;&quot;iconPosition &#x3D;&#x3D;&#x3D; &#39;right&#39;&quot;&gt;&lt;&#x2F;yv-icon&gt;<br>&lt;&#x2F;button&gt;<br></code></pre></td></tr></table></figure><p>但是这种做法有点low，也多了一行没必要的重复代码，然后想到<code>flex</code>有一个<code>order</code>的属性，可以决定子元素布局的排列优先级，<code>template</code>修改成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;button class&#x3D;&quot;yv-button&quot; :class&#x3D;&quot;&#123;[&#96;icon-$&#123;iconPosition&#125;&#96;]: true&#125;&quot;&gt;<br>      &lt;div class&#x3D;&quot;button-content&quot;&gt;<br>        &lt;slot&gt;&lt;&#x2F;slot&gt;<br>      &lt;&#x2F;div&gt;<br>      &lt;yv-icon class&#x3D;&quot;icon&quot;&gt;&lt;&#x2F;yv-icon&gt;<br>    &lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br>&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;<br>  .yv-button &#123;<br>    &gt; .button-content &#123;<br>      order: 2;<br>    &#125;<br>    &gt; .icon &#123;<br>      order: 1;<br>    &#125;<br>    &amp;.icon-right &#123;<br>      &gt; .button-content &#123;<br>        order: 1;<br>      &#125; <br>      &gt; .icon &#123;<br>        order: 2;<br>      &#125; <br>    &#125; <br>  &#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p>一开始设置icon的<code>order</code>为<strong>1</strong>表示默认icon是在左边，当用户传了<code>iconPosition</code>为<strong>right</strong>时，就会给<code>button</code>加上<br><code>icon-right</code>的<strong>class</strong>名，这时icon的<code>order</code>设置为<strong>2</strong>，<code>content</code>的<code>order</code>设置为<strong>1</strong>，这样在不修改代码的情况下，通过<code>order</code>的值就可以设置icon的显示位置。</p><ol start="2"><li>支持loading的设置。因为loading也要有图标，所以需要处理loading时不出现其它图标的情况，增加一个判断条件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button&gt;<br>  &lt;div class&#x3D;&quot;button-content&quot;&gt;<br>    &lt;slot&gt;&lt;&#x2F;slot&gt;<br>  &lt;&#x2F;div&gt;<br>  &lt;yv-icon class&#x3D;&quot;icon&quot; v-if&#x3D;&quot;icon &amp;&amp; !loading&quot; :name&#x3D;&quot;name&quot;&gt;&lt;&#x2F;yv-icon&gt;<br>  &lt;yv-icon class&#x3D;&quot;loading icon&quot; v-if&#x3D;&quot;loading&quot; name&#x3D;&quot;loading&quot;&gt;&lt;&#x2F;yv-icon&gt;<br>&lt;&#x2F;button&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>让loading的图标动起来。因为<strong>iconfont</strong>上面的图标都是静态的，而loading是要动起来的。仔细想了一下，loading就是360°不断地旋转，那我们只要写一个旋转的动画处理就可以，如下：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> spin&#123;<br>  0% &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>)&#125;<br>  100% &#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>)&#125;<br>&#125;<br><br><span class="hljs-selector-class">.loading</span> &#123;<br>  <span class="hljs-attribute">animation</span>: spin <span class="hljs-number">1s</span> infinite linear;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>按钮组合。按钮组合应该让按钮衔接看起来顺滑一点，这里采取的默认方案是按钮紧挨，然后第一个按钮和最后一个按钮的边缘钝化，同时中间的按钮应向前靠<strong>1像素</strong>，因为<code>button</code>都有<code>border</code>，看起来会很粗。代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style scoped lang&#x3D;&quot;scss&quot;&gt;<br>$button-radius: 4px;<br>.yv-button-group &#123;<br>  display: inline-flex;<br>  vertical-align: middle;<br>  .yv-button &#123;<br>    border-radius: 0;<br>    &amp;:not(:first-child) &#123;<br>      margin-left: -1px;<br>    &#125;<br>    &amp;:first-child &#123;<br>      border-bottom-left-radius: $button-radius;<br>      border-top-left-radius: $button-radius;<br>    &#125;<br>    &amp;:last-child &#123;<br>      border-top-right-radius: $button-radius;<br>      border-bottom-right-radius: $button-radius;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><h2 id="人工测试"><a href="#人工测试" class="headerlink" title="人工测试"></a>人工测试</h2><p>手动测试。。。已完成。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>在<strong>test</strong>文件夹下增加<code>button.test.js</code>文件。</p><p>主要增加<strong>7</strong>个测试用例，分别是：<strong>测试button是否存在</strong>、<strong>设置icon</strong>、<strong>icon初始位置</strong>、<strong>设置icon位置</strong>、<strong>设置loading</strong>、<strong>设置disabled</strong>、<strong>click点击事件</strong>。</p><p>运行<code>npm run dev-test</code>命令，是配置在package.json文件中的该命令：<code>parcel watch test/* --no-cache &amp; karma start</code>，就是监听、打包test文件夹下的*.test.js文件，然后运行karma开始自动化测试，测试结果可在浏览器控制台查看：</p><p><img src="/images/browser.png" alt="浏览器控制台显示"></p><p>或者powershell面板查看：</p><p><img src="/images/powershell.png" alt="powershell显示"></p><h2 id="vuepress配置"><a href="#vuepress配置" class="headerlink" title="vuepress配置"></a>vuepress配置</h2><p>在<strong>docs/.vuepress/components</strong>文件夹下增加<code>button-demo</code>的vue文件，内容就是我们要展示的<code>button</code>示例，然后在<strong>docs/components</strong>文件夹下增加<code>button</code>的md文件，内容就是放置整个<code>button</code>组件说明。</p><p>具体内容请<a href="https://ysom.github.io/yvue-ui/components/button.html">访问这里</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[1]-前置工作</title>
    <link href="/2020/08/31/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B1%5D-%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C/"/>
    <url>/2020/08/31/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B1%5D-%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h3><ol><li>github</li><li>gitee</li></ol><a id="more"></a><h3 id="包管理器（二选一）"><a href="#包管理器（二选一）" class="headerlink" title="包管理器（二选一）"></a>包管理器（二选一）</h3><ol><li>npm</li><li>yarn</li></ol><h3 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h3><ol><li>parcel（无需配置，可快速预览）</li><li>webpack（项目后续复杂的时候切换到webpack）</li></ol><h3 id="业界成熟方案"><a href="#业界成熟方案" class="headerlink" title="业界成熟方案"></a>业界成熟方案</h3><ol><li>ant-design</li><li>element-ui</li><li>ant-design-vue</li></ol><h3 id="原型设计工具"><a href="#原型设计工具" class="headerlink" title="原型设计工具"></a>原型设计工具</h3><ol><li>Balsamiq</li></ol><h3 id="交互设计工具"><a href="#交互设计工具" class="headerlink" title="交互设计工具"></a>交互设计工具</h3><ol><li>墨刀</li><li>Sketch(mac)</li></ol><h3 id="文章系统"><a href="#文章系统" class="headerlink" title="文章系统"></a>文章系统</h3><ol><li>vuepress</li><li>github pages</li></ol><h3 id="持续部署工具"><a href="#持续部署工具" class="headerlink" title="持续部署工具"></a>持续部署工具</h3><ol><li>Travis CI</li></ol><h2 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><ol><li><code>npm init</code></li><li>完成项目初始化</li></ol><h3 id="添加需要的插件"><a href="#添加需要的插件" class="headerlink" title="添加需要的插件"></a>添加需要的插件</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i vue<br><span class="hljs-built_in">npm</span> i parcel-bundler vuepress -D<br></code></pre></td></tr></table></figure><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ol><li>index.html</li><li>app.js</li><li>在index.html文件引入app.js</li><li>使用npx parcel index.html即可根据提示观察打包后结果</li><li>开发各个组件</li></ol><h2 id="坑点总结"><a href="#坑点总结" class="headerlink" title="坑点总结"></a>坑点总结</h2><ol><li>使用parcel打包成功后，打开<code>http://localhost:1234</code>会报这样一个错误：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">You are <span class="hljs-keyword">using</span> the runtime-<span class="hljs-keyword">only</span> build <span class="hljs-keyword">of</span> Vue <span class="hljs-keyword">where</span> the <span class="hljs-keyword">template</span> compiler <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> available.<br>Either pre-compile the templates <span class="hljs-keyword">into</span> render <span class="hljs-keyword">functions</span>,<br><span class="hljs-keyword">or</span> use the compiler-included build.<br></code></pre></td></tr></table></figure>这个错误是因为vue有两种模式的代码，<code>compiler</code>和<code>runtime</code>，vue默认指向的是<code>runtime</code>模式，即<code>dist/vue.runtime.common.js</code>。如果是使用webpack的话，可以在webpack.config.js文件添加以下配置：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">configureWebpack: &#123;<br>  resolve: &#123;<br>    alias: &#123;<br>      <span class="hljs-string">&#x27;vue$&#x27;</span>: <span class="hljs-string">&#x27;vue/dist/vue.esm.js&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>因为我使用的是parcel，没有配置文件，所以直接在package.json里面添加这一句即可：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;alias&quot;: &#123;<br>  &quot;vue&quot;: &quot;./node_modules/vue/dist/vue.esm.js&quot;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>2.如果使用parcel打包后打开页面发现报错了，但是你能确定代码没错的时候，那错误的原因大概就是因为parcel使用了缓存没有重新构建，使用以下命令解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npx parcel --no-cache<br></code></pre></td></tr></table></figure><p>或者删除<code>.cache</code>文件夹。因为parcel是默认启用缓存的。</p><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><ol><li>为啥使用parcel？</li></ol><p>首先parcel使用起来非常方便，无需配置，只需一个命令，就能自动找到文件所依赖的文件，包括文件需要什么样的依赖包，它都会自动安装；</p><p>其次parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换，让我们改动起来十分方便；</p><p>最后也是最重要的一个原因，对于我来说，这是一个全新的挑战，刚开始肯定会是在不断试错，如何花最少的成本在短时间得到我想要的效果，parcel会比webpack更适合做这件事情，<br>等到我对所有流程都比较熟悉、项目开始复杂起来的时候，再切换成webpack也不迟。</p><ol start="2"><li>只会实现大致功能，不会像成熟的UI框架那么丰富</li></ol><p>自己周末仔细地算了一下，每个组件从<strong>功能需求分析-可行性分析-原型设计-交互设计-功能开发-测试-发布</strong>这样的流程会耗费非常多的时间，而我的主要目的是在于提升技术的深度，所以每个组件应该是尽量只实现核心的功能，不会囊括常见的所有功能（除非刚好有业务需求）。<br>所以这个项目最后的样子应该是：一个简洁、清爽的UI轮子（不敢说是UI框架了，哈哈哈）。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发一个UI框架项目[0]-想法</title>
    <link href="/2020/08/30/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B0%5D-%E6%83%B3%E6%B3%95/"/>
    <url>/2020/08/30/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAUI%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%5B0%5D-%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>近段时间一直有搞个开源项目的想法，思来想去，加上近段时间的一些事情和个人在开发中遇到的一些情况，最终决定写一个UI框架轮子，具体的原因跟分析见下面。</p><h2 id="造轮子的初衷"><a href="#造轮子的初衷" class="headerlink" title="造轮子的初衷"></a>造轮子的初衷</h2><a id="more"></a><ol><li><p><strong>总结、有目标性地提升自己</strong>。这是最根本的原因。大多数前端工程师平时基本都是在写业务代码，这本身没有问题，但是如果我们只是在持续性地写业务，没有给每个阶段的业务、项目还有技术做总结，那我们就是在不断地重复同一件事且没有提升，这种情况就是<strong>内卷化</strong>。所以我们可以歇息，但是不能停止进步和提升，这是最根本和最核心的问题。</p></li><li><p><strong>纸上得来终觉浅，绝知此事要躬行</strong>。现在的前端技术日新月异，我们需要学习很多知识，很多人也懂很多理论知识，然后我们会发现在和别人聊天的时候可以侃侃而谈，但在具体实践的时候经常手忙脚乱出问题，这是为什么？我觉得最重要的原因之一就是缺乏实践，将理论付诸行动。基础知识很重要，是我们的“<strong>内功</strong>”，内功扎实了我们才能更稳定地提升，但同时也只有把掌握的知识发挥出来，知识才算有用武之地，不然我们就是在“<strong>纸上谈兵</strong>”。造轮子其实是一个很好的实践过程，精进技术的同时还可以锻炼我们的思维和业务能力。从0到1的过程，我们存在的很多问题会在实践中不断暴露出来，那我们要做的就是发现问题-&gt;解决问题-&gt;总结-&gt;发现问题-&gt;解决问题。。。如此坚持与循环，那我们肯定会得到很多收获，虽然这个过程确实非常耗费时间和精力。</p></li><li><p><strong>“拿来主义”下的居安思危</strong>。现阶段<strong>开源氛围</strong>很浓厚，大多数的团队也愿意将他们成熟的解决方案放到github之类的托管网站，在业务和时间排期的影响下，很多人会觉得造轮子是一件费力不讨好的事情，网上资源那么丰富，开源的项目那么多，直接拿来用就好，为啥还要自己造呢？先不说好不好用，光是业务不等人就是个问题。这种想法一般情况下是对的，但考虑以下几种情况：</p><ol><li>定制化的需求。总会有一些定制化的需求是第三方无法满足的，或是公司内部特定业务，或是某些惊为天人的创新想法，第三方不是万能，总有需要自己创造的东西；</li><li>迭代稳定性。我们永远无法保证我们使用的第三方库能一直维护更新，第三方库也不会给予我们这样的保证。比如现在<code>vue</code>比较热门的组件库<code>element-ui</code>，目前已经停止维护，还有<code>mint-ui</code>。热门的框架尚且如此，那么其它的呢？时代一直在前进，我们的产品也终将是要跟随时代的脚步，如果我们依赖的第三方停止迭代了，我们是否变得很被动，也要跟着止步不前？如果每次都要更换第三方，迁移成本是否很昂贵？</li><li>服务稳定性。如果第三方库出于某些因素考虑，强制单方面不再对我们提供服务。这个可能概率比较小，但是也是很现实的问题。就像去年以来，美帝不分青红皂白对华为还有其它中国企业强制采取某些制裁手段，这种情况如果没有备用方案，应急方案，是不是很被动？所谓君子不立危墙之下，平时做到居安思危才不会在出现意外情况的时候被一举击溃。</li></ol></li></ol><h2 id="实践想法"><a href="#实践想法" class="headerlink" title="实践想法"></a>实践想法</h2><ol><li><p><strong>从0到1</strong>。项目会采用软件工程的理论以及当前环境项目的发布，过程大概包含<strong>立项</strong>、<strong>需求收集和分析</strong>、<strong>可行性分析</strong>、<strong>功能设计</strong>、<strong>原型设计</strong>、<strong>交互设计</strong>、<strong>功能开发</strong>、<strong>测试</strong>、<strong>功能预演</strong>、<strong>发布</strong>，部分步骤会直接采用业界已有的成熟方案，虽然是造轮子，但也不是全部都是从0开始，我们不能这么傻ヽ(￣▽￣)ﾉ。</p></li><li><p><strong>同步记录</strong>。由于做的是<code>vue</code>的ui库，所以打算使用对<code>vue</code>非常友好的<code>vuepress</code>来记录整个过程，同时由于<code>vuepress</code>强大的功能，还可以用来展示开发的功能示例，这简直不能太棒ヾ(ﾟ∀ﾟゞ)！</p></li><li><p><strong>同时部署在github和gitee</strong>。本来打算后面项目部署在<code>github</code>这个全球最大同性交友社区的，但是种种原因限制，访问慢，有时还会被限制，特别是这段时间，因为运营商<code>dns</code>污染，<code>github.io</code>也访问不了，需要修改dns或者自己部署其它域名，确实有点坑，所以还是那句话，要居安思危，因此会多部署在<code>gitee</code>。</p></li><li><p><strong>发布到npm</strong>。项目开发过程中会逐步更新并发布到npm上面。虽然该项目用在生产环境的概率比较小，但是趁机体会发布流程也是ok的。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从该想法萌生之后，自己也查阅很多资料做了大致了解，做一个ui库项目会耗费比较多的时间，特别是从0到1，而且后面大概率也不会直接用于生产环境。但是经历过这样的过程，我相信从思维层面来看，我会不再局限于用技术的角度去看问题，从技术的层面来看，这个过程将会让我对所用技术栈有更深刻的理解。如果有一天需要我去创造的时候，这种经历所收获的经验会发挥很大的作用。最后，这项目是第一个但不会是最后一个，我会在空闲的时间，不断去提升自己，总结自己，将理论付诸于行动(≖ᴗ≖)✧。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员修炼之道》 -- 务实的方法（下）</title>
    <link href="/2020/06/04/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B--%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2020/06/04/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B--%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇记录了<strong>务实的方法</strong>上部分的内容，这里接着记录下部分的内容~</p><h3 id="曳光弹"><a href="#曳光弹" class="headerlink" title="曳光弹"></a>曳光弹</h3><p>很多人应该看过枪击电影、电视节目或者玩过枪击游戏，在这些场景里面，我们经常可以看到子弹在空中留下明亮的轨迹，这些轨迹就是来自<strong>曳光弹</strong>。</p><a id="more"></a><p>曳光弹和普通弹药间隔着一起被压入弹夹，当曳光弹发射时，上面的磷会被点着，在枪和击中物之间留下一道轨迹。如果曳光弹击中了目标，那么之后的常规子弹也会击中，士兵们通过使用曳光弹来调整他们的瞄准，这是一种务实的方法，可以在真实条件下实时获得反馈。</p><p><strong>真实条件下获得实时反馈</strong>。这个原则同样适用于我们的开发，特别是我们接触到以前未做过的东西的时候，<strong>曳光弹式开发</strong>针对变化的目标进行实时性的反馈是很有必要的。当我们在使用不熟悉的技术，或者在推进新技术的时候，往往会面临很多未知因素，所以在项目完成的这段时间内，我们的工作环境可能会经常的变动。</p><p><strong>曳光代码</strong>。曳光弹之所以有用，是因为其工作环境和约束跟真实环境是一致的，且能快速的到达目标，从实用性的角度来看，这也是一种低成本的解决方案。为了在开发中能获得同样的效果，我们可以找一些东西，能让我们快速、直观地从需求中得到最终系统的某个方面。开发中最初的曳光代码，就是创建一个简单的工程，加上一行我们熟悉的“hello world”并让这个工程跑起来，然后继续找出系统中不确定的部分再往上添加。我们在平时开发中使用一些demo来快速测试我们的想法是否行得通，其实也是属于曳光代码。</p><p>曳光代码并不是一次性的，而应该是持续性的，一开始它并不完整，随着我们不断地往上添加，我们就能知道我们跟目标的距离，一旦偏离了轨迹，我们就应该快速做出调整，这是一个逐步增加的过程。</p><h3 id="原型与便签"><a href="#原型与便签" class="headerlink" title="原型与便签"></a>原型与便签</h3><p>各行各业都有使用原型来尝试特定的想法：比如汽车制造商可能会为一款新车的设计制造许多不同的原型，每个原型都是为了测试某一特定的功能。我们开发软件也是一样，可以通过构建软件原型，来分析和暴露风险。</p><p>原型被设计出来只是为了回答我们某些疑惑的地方，所以我们的原型可以忽略一些不重要的细节，比如制作UI原型，我们可以忽略数据，制作关于性能方面的，我们可以忽略界面。但是如果是任何一个细节都不能忽略的，那这种情况下，我们应该考虑的是上面的模式–曳光弹，也不是制作原型这种模式。</p><p><strong>需要做原型的东西</strong>。我们会选择用原型来研究什么类型的东西呢？答案是任何有风险的东西，任何之前没有尝试过，或者说在系统中很关键的东西，任何我们觉得可疑的东西，甚至是某些地方让我们觉得不舒服的，都可以制作原型。制作原型的意义就在于吸取经验，减少错误的成本。</p><p><strong>制作架构原型</strong>。有很多原型也会用于还在考虑中的整个系统建模。有时候这些原型不一定得编写代码，还可以用一些标签或者索引卡搞定，下面列出的领域，可能是我们希望在架构原型中找到相关问题的答案：</p><ul><li>主要组件的定义是否清晰，职责是否恰当？</li><li>组件之间的协作是否定义清晰？</li><li>耦合度是否已经是最小化？</li><li>接口的定义和约束是否可以接受？</li><li>在执行过程中是否每个模块都有访问所需数据的途径？在我们需要数据的时候，能访问到吗？</li></ul><p>带着这些去寻找，思考，我们往往能获得更有价值的结果。</p><p><strong>不要把原型用于产品</strong>。我们制作的这种原型跟产品经理所做的产品原型的作用是不同的，我们的原型是不完整的且不可能做到完整，因为它是一个用来做特定方面分析的东西，所以在展示我们制作出来的原型时，应该跟其他人说明，这仅仅是一个展示效果，并不是最后的成品，避免其他人后面想要坚持部署不完善的原型。</p><p>如果使用得当，原型利于在开发的早期就识别出潜在的问题点，并给予纠正，且在这个时间点修正错误不仅廉价还容易。</p><p><strong>关于便签</strong>。便签非常适合构建动态事务的原型，比如我们的工作流和系统逻辑。最近看了谍战片《局中人》，其中有一处的场景是男二在墙壁上粘贴关于男一各种信息、模型，再通过线条来动态确立各模型、数据之间的联系，从而辅助他做逻辑更清晰的判断。而他所做的工作，就是情报分析。</p><h3 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h3><p>估算不管是在生活中，还是程序世界里都是普遍存在的，当我们面对问题不能肯定地答复时，都是属于估算。通过学习估算，把这项技能发展成为对事物的数量级产生直觉，将会对我们的工作和生活产生魔法般的作用，并且在估算的过程中，我们也会加深对程序所处世界的理解。</p><p><strong>多精确才够</strong>。在某种程度上，所有的答案都是估算，区别仅在于一些比另一些更精确。所以当我们需要估算的时候，我们要问自己一个问题：答案会用在什么场合，对方需要怎样的精度？</p><p>有一个关于估算有趣的事：我们使用的单位会对结果的解释产生影响。如果我们说<strong>某件事需要130个工作日完成</strong>，那么听的人往往会觉得实际的时间很接近130这个数字，然而如果我们说的是“<strong>大概4个月吧</strong>”，他们就会认为还需要4-6个月不等。两个数字代表的时间周期是差不多的，但是“130天”却暗示了<strong>更高的精度级别</strong>。因此当我们做估算时，可以挑选<strong>答案的单位</strong>来反映想要传达的精确性。</p><p><strong>掌握问题域的范围</strong>。所有的评估工作都是建立在对于所问问题的理解。除了精确度以外，我们还需要掌握问题域的范围。范围通常是问题的隐含前提，我们要养成一个在猜测之前加以考虑的习惯，很多时候，我们选择的范围会成为给出的答案的一部分。</p><p><strong>记录估算能力</strong>。除了从某些点出发去提高估算能力之外，我们还可以记录下我们做过的估算，这样可以看到我们做过的估算的准确程度，简单来说就是复盘。当我们时常估算准确的时候，我们应该觉得这是理所应当，是估算的魅力；如果估算不准确的时候，我们也要找出为什么偏离的原因，有可能是实际情况的问题，有可能是估算时采用的参数问题，通过复盘，让我们下次的估算能更加准确。通过长时间的复盘总结，也可以逐渐建立起属于自己的一套估算系统，这就是我们常说的经验，但这又比经验这一说法更可靠，更经得起推敲。</p>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>务实</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员修炼之道》 -- 务实的方法（上）</title>
    <link href="/2020/05/15/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B--%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2020/05/15/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B--%E5%8A%A1%E5%AE%9E%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>周五啦，忙碌了一个星期，趁着周五晚上听听轻音乐，看会书，写写感想，放松一下~</p><p>《程修道》在第一章由<strong>务实的哲学</strong>开头之后，在接下来的第二章就开始讲务实的方法，即由<strong>思想理念</strong>到<strong>操作实践</strong>的过程。</p><p>务实的方法总共有<strong>8</strong>部分，<code>优秀设计的精髓</code>、<code>DRY-邪恶的重复</code>、<code>正交性</code>、<code>可逆性</code>、<code>曳光弹</code>、<code>原型与便签</code>、<code>领域语言</code>、<code>估算</code>。</p><p>第二章的内容很丰富也更需要深入去阅读品味，今晚先记录一部分。</p><a id="more"></a><h3 id="优秀设计的精髓"><a href="#优秀设计的精髓" class="headerlink" title="优秀设计的精髓"></a>优秀设计的精髓</h3><p>这一部分，可以说是触及软件开发核心的至关重要主题，后面的7部分内容，都是由此来进行更为详细的展开。</p><p><strong>优秀的设计比糟糕的设计更容易变更</strong>。我们在日常经常有谈到怎样设计好的软件，最后总的概括，能适应使用者的就是好的设计。对于我们的代码而言，就是要顺应变化，这个顺应变化怎么理解呢，书中提到了一个重要的原则<strong>ETC（Easier To Change）原则</strong>：更容易变更。很多设计原则，基本都是ETC原则的特例。</p><p>为什么代码要解耦，因为通过隔离关注焦点，可以让每一部分都容易变更。</p><p>为什么单一职责原则很有用？因为一个需求变化仅体现为某个单一模块上的一个对应变化。</p><p>为什么良好的命名规则很重要？因为好的命名可以使代码更容易阅读，而我们必须先通过阅读之后才能做变更。</p><p><strong>ETC应当是一种价值观念，而不是一条规则</strong>。价值观念跟规则的区别在于，规则是用来规范大家的行为，是要遵守的，有一种被动、甚至是束缚的感知。而价值观念是一种思维向导，它会帮助我们去思考，去做决定：哪些是该做的，哪些是不该做的。我们应该把ETC当成跟其它的价值观念一样，像“<strong>八荣八耻</strong>”，让它漂浮在我们的思维当中，当我们开始思考做决定时，它能微妙地将我们推向正确的方向。</p><p><strong>怎样做到将ETC作为价值观念？</strong>作者给出了他们这些年总结的一些经验：一开始需要一点有意识的强化。我们可能花几个星期的时间来有意识地问自己：“刚刚做的代码设计是让整个系统更容易变更还是更难改变？”。当我们提交代码的时候问一遍，写测试的时候问一遍，当我们修复BUG的时候再问一遍，甚至要反思这个BUG的出现是不是可以通过更好的设计来规避。</p><p><strong>更进一步</strong>。除了上述作者给出的经验建议，我们还可以做得更好。第一点是让我们的代码坚持保持<strong>解耦</strong>和<strong>内聚</strong>、让我们的代码容易替换，即我们常说的<strong>可配置化</strong>。可配置化的好处就是不管以后有什么需求改变，我们都可以较为容易地去变更，而无需花费精力去重写。第二点是培养直觉，要经常记录我们遇到的问题、可以做的选择、可以怎样改变的猜测，以便我们可以进行快速的回顾和反思，下次遇到同样的问题，可以在脑海里快速提炼出方案。</p><h3 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h3><p>“<strong>正交性</strong>”是从几何中借用来的术语：若两条直线相交成直角，它们就是正交的。用向量术语来说，这两条直线互不依赖。在计算科学中，正交就代表<strong>独立性</strong>或者<strong>解耦性</strong>。</p><p><strong>消除不相关事物之间的影响</strong>。组件化这个概念在如今已经是一个普遍的概念，很多大厂也都有开源的组件库。我们在写组件的时候，都是希望我们的组件是独立自主，有单一、清晰的定义，能够简单、重复地使用。当我们变更某一个组件的时候，不会对其它组件有很大影响甚至是没有影响。从这角度来看，正交性的系统主要有两个方面的好处：<strong>提高生产力</strong>以及<strong>降低风险</strong>。</p><p><strong>提高生产力</strong></p><ul><li>正交的方法促进了复用。前端组件化最基本的定义，就是组件都是<strong>职责明确</strong>、<strong>定位清晰</strong>的，像表格组件、时间选择组件等等，根据不同的职责，能够跟不同的组件进行搭配复用。越是低耦合，我们需要重新配置和变更的地方就越少，也就越容易进行。</li><li>节省开发、测试时间。</li></ul><p><strong>减少风险</strong></p><ul><li>代码中“生病”的部分被分隔开。如果一个组件出问题了，我们只需改动组件某个部分，减少大幅改动的风险。</li><li>系统更加稳健。这样的系统，就像天气预报一样，局部有阵雨，局部多云一样，哪一块“天气不好”，我们只需对特定的部分修复，不会对系统造成影响。</li><li>更有意思的一点，就是不会受特定供应商的束缚。我们的系统可能会对外对接一些特定的服务，那这些服务我们更应该遵从正交性，最好将对接的这部分独立，以后供应商改了啥东西，我们也照样只是更改独立的这部分就OK了。</li></ul><h3 id="可逆性"><a href="#可逆性" class="headerlink" title="可逆性"></a>可逆性</h3><blockquote><p>如果某个想法是你唯一的想法，那就没有比它更危险的东西了。 ——埃米尔-奥古斯特-沙尔捷</p></blockquote><p><strong>可逆性</strong>跟上面的正交性有点相似，正交性强调<strong>独立</strong>和<strong>解耦</strong>，可逆性是<strong>可逆</strong>，<strong>容易改变</strong>，两者之间存在一定的联系。</p><p>我们在生活中都喜欢简单、唯一的解决方案，甚至有时还会严重依赖某些事实，但这在某种程度上是很危险的。</p><p>变化不需要多么剧烈，甚至不必立刻发生，随着时间推移还有项目的演进，我们可能会发现很难前行，甚至陷入无法立足的困境，每当做出一个关键决定，我们就会投身于更具体的目标，由于选择变少，视野会越来越窄。但是问题在于，<strong>关键的决定一般不容易逆转</strong>。</p><p>所以为了做到可逆性，我们要坚持做面向有弹性、适应性强的编程，像解耦，做外部配置，组件化，模块化等等，错误在于认为任何决定都是板上钉钉，而没有为可能出现的意外或者变更做好准备。</p><p>现实中我们也不可能为今后会出现的各类架构提前做好准备，我们能做的，就是在变化来临时修改能更容易一点，而不是每次面临巨大的变化，脑海里只有一个念头：<strong>重构、重写</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>务实</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员修炼之道》 -- 务实的哲学</title>
    <link href="/2020/05/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B--%E5%8A%A1%E5%AE%9E%E7%9A%84%E5%93%B2%E5%AD%A6/"/>
    <url>/2020/05/09/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B--%E5%8A%A1%E5%AE%9E%E7%9A%84%E5%93%B2%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《程修道》第一章讲的是<strong>务实的哲学</strong>，内容的安排觉得很巧妙，不像传统的书籍那样，上来直接跟你说某个概念，而是通过“哲学”一词来表达务实本身所具有的高度以及务实给我们带来的是思想和心理层面的改变和进化，也让读者对务实有更多的兴趣和探索欲。</p><a id="more"></a><p>这一章由7部分组成，分别是<code>人生是你的</code>、<code>我的源码被猫吃了</code>，<code>软件的熵</code>，<code>石头做的汤和煮熟的青蛙</code>，<code>够好即可的软件</code>，<code>知识组合</code>和<code>交流</code>。这里挑感触比较多的部分做感想和记录。</p><h3 id="我的源码被猫吃了"><a href="#我的源码被猫吃了" class="headerlink" title="我的源码被猫吃了"></a>我的源码被猫吃了</h3><p>看到这个标题的时候是不是觉得很搞笑，猫竟然能吃源码？？？</p><p>现实中猫肯定是没法把源码吃掉的，这个比喻说的是，当下很多找借口、甩锅、不敢担当的现象。</p><p><strong>承担责任</strong>。不管在工作中还是生活中，我们都需要承担责任，责任意味着我们对某事积极认同，当我们决定对一个结果承担责任时，意味着我们将承接相关的义务，当我们在这期间犯了错，做了错误的决定，写了一个潜藏的BUG导致线上事故，我们都要诚实地去承担，并且尝试给出选择，给出解决方案。</p><p><strong>提供选择，别找借口</strong>。我们很多人经常在出现错误的时候找各种各样的借口来搪塞老板、领导或者同事，想以此来减轻自己犯错后应承担的后果：为什么项目会延期，为什么线上会出现大BUG。如果想找借口，最好是在心里把跟领导的对话过一遍，看看你给出的借口有没有说服力，如果没有，还是老老实实地考虑“有没有试过这样的方案，或者另外的方案”，在找借口前，还有没有其它解决方案可以试试的？我觉得最基本的处理方式，应该是承担责任，说出原因，然后提供解决方案给领导选择，而不是把问题抛给领导。</p><p><strong>更好地改进</strong>。如果真的出现问题，我们最终目的还是要解决问题。是一段老代码引起的坑？那么是不是要进行优化或者重构，跟领导讲一下重构的价值；如果是业务不熟悉造成的，我们是不是应该花多一些时间去了解业务，了解原型；为了防止错误的再次发生，我们可不可以引入更好的测试或者增加一些自动化流程；等等这些，都是一些改进的方案。</p><h3 id="软件的熵"><a href="#软件的熵" class="headerlink" title="软件的熵"></a>软件的熵</h3><p><code>熵</code>是物理学的术语，它定义了一个系统的“<strong>无序</strong>”即混乱程度，熵越大，则代表项目越混乱越难以维护，正在“<strong>腐烂</strong>”。</p><p>有很多个因素可以导致软件腐烂，而文中讲了最重要的一个因素，“<strong>项目工作中的心理性状态</strong>”。</p><p>这个词看起来可能比较难以理解，我们先看一些对比的例子：</p><p>有的项目安排了合理的计划和合适的开发人员，但项目还是可能在生命周期中逐渐荒废，腐烂；有的项目正在经历巨大的困难和挫折，但是却成功地对抗了系统的无序化倾向。</p><p>为什么有这种反差存在？文中有一个“<strong>破窗理论</strong>“：</p><blockquote><p>在一栋建筑中有一扇破损的窗户，只要有一段时间不去修理，建筑中的居民就会产生一种潜移默化的被遗弃的感觉：没人在乎这个破窗和这栋建筑。然后，其它窗户也开始损坏，居民开始乱丢垃圾，墙上开始出现涂鸦，建筑开始出现严重的结构性破坏。建筑的损坏程度足以打消居民想修复的期望，被遗弃的感觉最终也变成了现实。</p></blockquote><p>这个破窗为什么会造成这样的影响，心理学家的研究表明，<strong>负面情绪是会传染的</strong>，无视一个明显损坏的东西，会强化这样的观念：<strong>没人在乎，看来可以不用管不用去修好它</strong>。</p><p><strong>不要放任破窗</strong>。这种破窗现象，对应到了我们软件开发中一些问题，<code>糟糕的设计</code>、<code>错误的决定</code>、<code>不规范的、劣质的代码</code>等。如果项目中存在这样的情况，每发现一个最好赶紧修一个，如果项目的版本没有安排到这块范围，那最好把它<strong>标记</strong>起来，或者注释一下，说明这里存在的问题，预防进一步的损害发生。如果团队中没人有这样的想法， 觉得代码烂就烂了，那这种情绪就不单会从现在开始传播，就连躺在项目里的烂代码也会给后来的新人一种“烂”误导。只有保持良好的破窗修复习惯，我们的系统才可以稳健运行，漠视只会加速系统的腐烂，安排再合理的开发计划和技术人员，也无法逃离熵的制裁。</p><p><strong>举个自己的栗子</strong>。刚加入团队的时候，我会仔细阅读团队中已有的技术规范文档，一方面是让自己的开发习惯尽量跟团队的规范保持一致，另一个是避免一些沟通、合作上的问题。而在刚接手已有系统的开发时，我记得第一次我很小心，小心翼翼地观察项目中代码的写法，文件创建规范，特别生怕自己一不小心，就搞了个“破窗”。现在回想起来，我这方面的小心翼翼还是值得的，代码符合规范，质量过关几乎没有BUG，版本正常上线。</p><h3 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h3><blockquote><p>我认为被人从头打量到脚总比被人视而不见要好。 ——梅·韦斯特 电影：《九十岁的美女》</p></blockquote><p>我们可以细细品味韦斯特女士的这句话：<strong>只拥有是不够的，还是学会如何包装</strong>。即使拥有最好的想法，漂亮的代码，务实的思想，如果不懂得和别人交流，最终都无法落地，孕育出果实。</p><p>交流这部分本来是在第一章最后的内容，在这里拎出来记录主要是想起一件事情，颇有感触：技术人员A同事需要对接其它分公司的同事，让他们提供某块业务的技术支持。本来这事没那么复杂，就是沟通好A这边的业务需求以及具体需要哪些支持，然后分公司的同事B提供相应的支持就OK了。但是一件不复杂的事情，足足聊了好几天，期间还不断拉各位大佬进群，导致最后大佬都发话不满意了。</p><p>是业务太复杂，涉及的东西太多吗？并不然，看整个沟通过程总结下来就是一个点：<strong>表达不清晰</strong>。A同事没有清晰地表达自己的需求，B同事没有清晰表达自己的疑问以及目前存在的问题，这种情况导致双方沟通了很长时间，甚至还引发领导的不满。</p><p><strong>明白自己想说什么</strong>。在我们日常沟通、更正式的商务沟通中，可能整理思绪是一件比较困难的事情，所以一开始我们可以计划好我们想表达的内容，然后写一个大纲，自己对着大纲去描述，最后问自己，这份大纲能清晰地向我们沟通的对象传达我们的想法吗？如果不行，就得继续提炼，反复提炼。还有可以准备多个表达的策略，我们的沟通对象可能是产品，技术人员，用户，不同的人群对我们的话术的理解是不一致的，所以我们还需要针对不同的人群，准备不同的沟通策略。</p><p><strong>沟通的时机</strong>。上述事例沟通失败的重要原因之一，还有沟通的时机。B同事有紧急的任务在处理，而A同事还是选择在这个时间点找同事沟通，毫无疑问，B同事处理优先级不在于这一块，所以存在了一个情况：A在催，B没空，A开始觉得B对这件事不上心，B开始觉得A不懂变通，咄咄逼人，最后双方也都稍微带着点情绪在沟通。沟通选择的时机在我们日常中也是很重要的，沟通的时候也要尽量考虑沟通双方当前事项的优先级，避免谈而不得。</p>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>务实</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《程序员修炼之道》</title>
    <link href="/2020/05/07/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B/"/>
    <url>/2020/05/07/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近买了<strong>《程序员修炼之道（第二版）-通向务实的最高境界》</strong>这本书，第一版是在2004年3月出版的<strong>《程序员修炼之道-从小工到专家》</strong>，听说是一本神书，90%程序员都看过（我就是那10%的一员(￣ω￣;)），还颠覆了很多IT界大牛的技术生涯。时隔16年，今年2020年4月份出版了现在的第二版，除了回顾、更新前一版所引用的技术，两位作者还充分借鉴这16年来增加的丰富经验来重新审视前一版所推崇的时间背后的种种假设，构成了一本更胜第一版的神书。</p><a id="more"></a><h3 id="为什么阅读这本书"><a href="#为什么阅读这本书" class="headerlink" title="为什么阅读这本书"></a>为什么阅读这本书</h3><p>除了书籍本身所携带的光环和知名度之外，吸引我的还是这个书名。</p><p><strong>《程序员修炼之道》</strong>，让我想到了星爷的<strong>《演员的自我修养》</strong>，星爷本身就是一个励志、传奇故事，他的电影可以说是很多人的美好回忆，所以这种异曲同工之妙，是第一个吸引点；</p><p>第二吸引点是书的副题，“<strong>通向务实的最高境界</strong>”，“<strong>务实</strong>”一词，给我的感触就是现实中已经越来越少有这种精神了，不单是开发，映射到各种各样的行业，“<strong>浮躁</strong>”反而是当前更多人的心态。前端开发，给人也是这种浮躁的感觉，培训班、自学生出来的各种不合格的初级前端，嘴里喊着“别更新了，我已经学不动了”，又伴随着开发中各种骚操作，等等现象。包括我对自己的评价也算是比较浮躁，所以探索“务实”对我来说，格外的有吸引力。</p><h3 id="阅读计划"><a href="#阅读计划" class="headerlink" title="阅读计划"></a>阅读计划</h3><p>“<strong>是骡子是马拉出来溜溜</strong>”，是不是好书要读过才知道，同时在博客上面记录、分享阅读后的感想，通过<strong>读</strong>、<strong>想</strong>、<strong>写</strong>，来让自己距离务实更近一些。</p><h3 id="最后，瞄一眼书的样貌"><a href="#最后，瞄一眼书的样貌" class="headerlink" title="最后，瞄一眼书的样貌"></a>最后，瞄一眼书的样貌</h3><p><img src="/images/book.jpg" alt="《程序员修炼之道第二版》"></p>]]></content>
    
    
    <categories>
      
      <category>代码人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>务实</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.0-beta尝鲜</title>
    <link href="/2020/05/02/vue3.0-beta%E5%B0%9D%E9%B2%9C/"/>
    <url>/2020/05/02/vue3.0-beta%E5%B0%9D%E9%B2%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>尤大大前段时间发布了vue3.0-beta版本，现在趁着五一假期尝尝鲜，记录一下。</p><h2 id="vue3设计更新点"><a href="#vue3设计更新点" class="headerlink" title="vue3设计更新点"></a>vue3设计更新点</h2><p>先回顾官方提出的vue3.0设计目标</p><ul><li>更小<ul><li>全局 API 和内置组件</li><li>支持 tree-shaking</li><li>常驻代码大小控制在 10kb gzipped 左右</li></ul></li><li>更快<ul><li>基于 Proxy 的变动侦测</li><li>Virtual DOM 重构</li><li>编译器架构重构，更多的编译时优化</li></ul></li><li>加强API设计一致性</li><li>加强TypeScript支持</li><li>提高自身可维护性<ul><li>代码采用 monorepo 结构，内部分层更清晰</li><li>TypeScript 使得外部贡献者更有信心做改动</li></ul></li><li>开放更多底层功能</li></ul><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 升级vue-cli到4.0版本</span><br>cnpm install -g @vue/cli<br><br><span class="hljs-comment">// 创建项目（注意，这里的vue版本还是2.x）</span><br>vue create vue-<span class="hljs-number">3.0</span>-beta-test<br><br><span class="hljs-comment">// 切换到项目目录 通过vue add 命令添加3.0版本</span><br>vue add vue-next<br></code></pre></td></tr></table></figure><p>然后打开项目，可以看到vue的版本已经变成<code>^3.0.0-beta.1</code>，还有一些插件版本的更新和新增了两个插件</p><p><img src="/images/vue%E5%8D%87%E7%BA%A73.0-beta.png" alt="vue升级3.0-beta"></p><h3 id="对比项目结构"><a href="#对比项目结构" class="headerlink" title="对比项目结构"></a>对比项目结构</h3><p>再从项目的整体结构来看，对比2.x版本基本没有变化，主要看下变化了的<code>main.js</code>文件</p><p><img src="/images/mainjs%E5%AF%B9%E6%AF%94.png" alt="main.js"></p><p>通过图片可以看到，这里只解构出一个<code>createApp</code>函数，因为vue3.0支持<code>tree-shaking</code>，可以把每一个用到的API抽取出来，让vue变得更小</p><h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><p>原先是叫<code>Vue-Function-API</code>，后面经社区意见收集，更改为<code>Vue-Composition-API</code>，这里面有几个变化比较大的：</p><ul><li>生命周期钩子</li><li>reactive API</li><li>ref API</li><li>watch API</li><li>computed API</li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在3.0中，生命周期发生了很大变化：</p><table><thead><tr><th>2.x</th><th>3.0</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td></tr><tr><td>created</td><td>setup</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>onUnmounted</td></tr></tbody></table><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><blockquote><p>该API作用是创建响应式对象，类似之前在<code>data</code>中声明变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; App.vue<br>&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;<br>    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;&#x2F;h3&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123; reactive &#125; from &quot;vue&quot;;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  setup() &#123;<br>    let info &#x3D; reactive(&#123;<br>      msg: &#96;vue3.0-beta尝鲜&#96;<br>    &#125;);<br>    return &#123;<br>      info<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/images/%E6%95%88%E6%9E%9C%E5%9B%BE-1.png" alt="reactive效果"></p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><blockquote><p>创建一个包装式对象，含有一个响应式属性value，通过修改value来修改值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; App.vue<br>&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;<br>    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;h3&gt;&#123;&#123; tip &#125;&#125;&lt;&#x2F;h3&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123; reactive, ref &#125; from &quot;vue&quot;;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  setup() &#123;<br>    let info &#x3D; reactive(&#123;<br>      msg: &#96;vue3.0-beta尝鲜&#96;<br>    &#125;);<br>    let tip &#x3D; ref(&#96;value of ref&#96;);<br>    &#x2F;&#x2F; 通过修改value属性来修改值<br>    tip.value &#x3D; &#96;change ref of value&#96;;<br>    return &#123;<br>      info,<br>      tip<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/images/ref%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="ref效果"></p><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>3.0没有<code>methods</code>对象，也是写在<code>setup</code>里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; App.vue<br>&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;<br>    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;input v-model&#x3D;&quot;inputValue&quot; &#x2F;&gt;<br>    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;click me&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123; reactive, ref &#125; from &quot;vue&quot;;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  setup() &#123;<br>    let info &#x3D; reactive(&#123;<br>      msg: &#96;vue3.0-beta尝鲜&#96;<br>    &#125;);<br>    let tip &#x3D; ref(&#96;value of ref&#96;);<br>    tip.value &#x3D; &#96;change ref of value&#96;;<br>    let inputValue &#x3D; ref(&quot;&quot;);<br>    const handleClick &#x3D; () &#x3D;&gt; &#123;<br>      tip.value &#x3D; inputValue.value;<br>    &#125;;<br>    return &#123;<br>      info,<br>      tip,<br>      inputValue,<br>      handleClick<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>上面写了一个方法，绑定一个点击事件来改变变量<code>tip</code>的值，效果如图：</p><p><img src="/images/%E4%BA%8B%E4%BB%B6%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="绑定事件"></p><h4 id="onMounted钩子"><a href="#onMounted钩子" class="headerlink" title="onMounted钩子"></a>onMounted钩子</h4><p>我们在vue项目中用得最多的生命钩子就是<code>created</code>和<code>mounted</code>，在<code>created</code>发送请求，接收、处理参数之类，在<code>mounted</code>页面渲染后进行相关的业务处理，在上面有提过，现在<code>beforeCreate</code>和<code>created</code> 都是<code>setup</code>了，现在看下新的<code>onMounted</code>怎么用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;<br>    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;input v-model&#x3D;&quot;inputValue&quot; &#x2F;&gt;<br>    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;click me&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123; reactive, ref, onMounted &#125; from &quot;vue&quot;;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  setup() &#123;<br>    &#x2F;&#x2F; 省略上面例子的代码<br>    &#x2F;&#x2F; ...  <br>    onMounted(() &#x3D;&gt; &#123;<br>      console.log(&#96;mounted&#96;);<br>      &#x2F;&#x2F; 页面渲染完 获取所有h3元素  <br>      let h3List &#x3D; document.querySelectorAll(&quot;h3&quot;);<br>      console.log(&#123;<br>        h3List: h3List<br>      &#125;);<br>    &#125;);<br>    return &#123;<br>        &#x2F;&#x2F; ...<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br></code></pre></td></tr></table></figure><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;<br>    &lt;h3&gt;&#123;&#123; info.msg &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;h3&gt;tip：&#123;&#123; tip &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;h3&gt;computed num：&#123;&#123; num &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;input v-model&#x3D;&quot;inputValue&quot; &#x2F;&gt;<br>    &lt;button @click&#x3D;&quot;handleClick&quot;&gt;click me&lt;&#x2F;button&gt;<br>    &lt;button @click&#x3D;&quot;incrementNum&quot;&gt;increment&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123; reactive, ref, onMounted, computed &#125; from &quot;vue&quot;;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  setup() &#123;<br>&#x2F;&#x2F; ...<br>    let initNum &#x3D; ref(0);<br>    const incrementNum &#x3D; () &#x3D;&gt; &#123;<br>      initNum.value++;<br>    &#125;;<br>    &#x2F;&#x2F; 让num成为计算属性<br>    let num &#x3D; computed(() &#x3D;&gt; &#123;<br>      return initNum.value * 2;<br>    &#125;);<br>    return &#123;<br>      &#x2F;&#x2F; ...<br>      incrementNum,<br>      num<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br></code></pre></td></tr></table></figure><p>看下效果：</p><p><img src="/images/%E9%92%A9%E5%AD%90%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面的例子可以看到，3.0的语法更加简洁精炼！总的来说，3.0会兼容2.x，我们的学习成本基本就只集中在composition这一块，而更具体、更详细的内容，可访问<a href="https://composition-api.vuejs.org/#summary">composition-api</a>，上面还有很丰富的内容等着我们探索，包括对<code>TypeScript</code>的更好支持等。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>致敬英雄，主流网站置灰的探索</title>
    <link href="/2020/04/05/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84%EF%BC%8C%E4%B8%BB%E6%B5%81%E7%BD%91%E7%AB%99%E7%BD%AE%E7%81%B0%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <url>/2020/04/05/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84%EF%BC%8C%E4%B8%BB%E6%B5%81%E7%BD%91%E7%AB%99%E7%BD%AE%E7%81%B0%E7%9A%84%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>2020年4月4号，清明节，全国下降半旗，北京时间十点整，全国默哀3分钟，停止一切娱乐性活动，致敬为国、为民而逝世的英雄。</p><p>国内的很多主流网站，为致敬英雄将网站全站置灰。如：</p><a id="more"></a><p><img src="/images/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84iqiyi.png" alt="爱奇艺"></p><p><img src="/images/%E8%87%B4%E6%95%AC%E8%8B%B1%E9%9B%84bilibili.png" alt="b站"></p><p>这种置灰包括了图片、按钮、文字等，那是怎样实现的呢？</p><p>一种思路是通过对每个元素都加上统一的样式，但是这种成本太高，而且要做到没有遗漏，是一件比较费精力的事情。</p><p>另一种思路是通过主题样式设置，即设置为灰色主题，但是我们知道，主题样式会有对应的配色设计，像这种置灰是单一的，直接全体置灰，没有一些配色显示突出的设计。</p><p>上面两种方案是可以实现的，只是不符合我们程序猿简洁、高效的理念。</p><p>那有没有一种方案，靠一个属性，一个方法直接设置，就能对全站起到这样一个效果呢？如果有的话，毫无疑问这种方案是最省时省力的。</p><p>带着这种疑问，我们利用开发者工具，看了几个主流网站的代码，貌似还真的有一个属性可以实现我们的想法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">// <span class="hljs-selector-tag">b</span>站<br><span class="hljs-selector-tag">html</span><span class="hljs-selector-class">.gray</span> &#123;<br>    <span class="hljs-attribute">-webkit-filter</span>: <span class="hljs-built_in">grayscale</span>(.<span class="hljs-number">95</span>);<br>&#125;<br><br>// <span class="hljs-selector-tag">CSDN</span>博客<br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">-webkit-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">-moz-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">-ms-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">-o-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="hljs-built_in">BasicImage</span>(grayscale=<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>把这些个样式勾选掉，网站果然就恢复了原来的配色，看来这种置灰操作，确实可以由属性来操控，而且跟<code>filter</code>属性脱不了干系。</p><p>搜下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">MDN</a>，可以看到对<code>filter</code>的解释：</p><blockquote><p>CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p></blockquote><p>也就是说，这个属性可以用来做滤镜操作。</p><p>这里展示一下所有属性设置的代码，建议前往<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">官网</a>查看更详细的操作和解释</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* URL to SVG filter */</span><br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">url</span>(&quot;<span class="hljs-selector-tag">filters</span><span class="hljs-selector-class">.svg</span><span class="hljs-selector-id">#filter-id</span>&quot;);<br><br><span class="hljs-comment">/* &lt;filter-function&gt; values */</span><br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">blur</span>(5<span class="hljs-selector-tag">px</span>);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">brightness</span>(0.4);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">contrast</span>(200%);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">drop-shadow</span>(16<span class="hljs-selector-tag">px</span> 16<span class="hljs-selector-tag">px</span> 20<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">blue</span>);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">grayscale</span>(50%);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">hue-rotate</span>(90<span class="hljs-selector-tag">deg</span>);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">invert</span>(75%);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">opacity</span>(25%);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">saturate</span>(30%);<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">sepia</span>(60%);<br><br><span class="hljs-comment">/* Multiple filters */</span><br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">contrast</span>(175%) <span class="hljs-selector-tag">brightness</span>(3%);<br><br><span class="hljs-comment">/* Global values */</span><br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">inherit</span>;<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">initial</span>;<br><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">unset</span>;<br></code></pre></td></tr></table></figure><p>这里再引用官方的一个例子，设置高斯模糊</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">filter</span>: <span class="hljs-selector-tag">blur</span>(<span class="hljs-selector-tag">radius</span>)<br></code></pre></td></tr></table></figure><p>给图像设置高斯模糊。radius 一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；如果没有设定值，则默认是 0；这个参数可设置绝对像素值，但不接受百分比值。效果如下：</p><p><img src="/images/%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A.png" alt="高斯模糊效果"></p><p>再看看我们置灰用到的<code>grayscale</code>，它表示将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。</p><p>这样其实我们通过设置值来确定灰度的比例，就可以实现置灰的效果，而想要全栈置灰，则将该样式添加到<code>html</code>元素上。</p><p>为了更好的兼容性，可以加上各主流浏览器的私有前缀，即CSDN的写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">-webkit-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">-moz-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">-ms-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">-o-filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="hljs-built_in">BasicImage</span>(grayscale=<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>灰色给了一种很浓的沉重感，昨天的心情也确实很沉重。</p><p>最后，愿英魂安息，山河无恙，人间皆安。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分享一道有趣的题</title>
    <link href="/2020/03/22/%E5%88%86%E4%BA%AB%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98/"/>
    <url>/2020/03/22/%E5%88%86%E4%BA%AB%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天在群里看到朋友发了一道有趣的题</p><p><img src="/images/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98.jpg"></p><p>就是如何让<code>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) === true</code>这个等式成立。一开始看到这个题觉得是无稽之谈，这不扯淡吗，一个变量能同时满足几个值？但是朋友这么问还真说不定有可能，于是开始一波思考。</p><a id="more"></a><p>首先分析一下等式左边的<code>a==1</code>，<code>a==2</code>，<code>a==3</code>，相等符号<code>==</code>会判断两个变量的值是否相等，如果不相等，则会涉及到变量类型的转换，全等符号<code>===</code>则会同时判断变量的值和类型，其中一个不相等，则结果为<code>false</code></p><p>然后我们假设等式已经成立，既然这个等式能够成立，那么变量<code>a</code>肯定不是一个普通的变量，至少<strong>基本数据类型</strong>满足不了这种骚操作，那么它应该是<strong>复杂数据类型</strong>。</p><p>那我们接着假定是对象，那么对象跟基本数据类型对比的时候，会有我们上面说的涉及到类型转换，对象会先转换成基本数据类型，这里就会触发原型上<code>toString()</code>方法，如下：</p><p><img src="/images/%E8%A7%A6%E5%8F%91toString.png" alt="触发toString"></p><p>我们给<code>a</code>重写覆盖了<code>toString</code>方法，以方便我们调试，可以看到，对象在判断转换过程中，会触发<code>toString</code>方法。那么我们就可以根据这个特性，对<code>a</code>进行一波骚操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br>i: <span class="hljs-number">1</span>,<br>    toString: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.i++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下：</p><p><img src="/images/%E7%AD%89%E5%BC%8F%E6%88%90%E7%AB%8B.png"></p><p>可以看到，<strong>等式成立！！！</strong>这说明确实可以存在这种情况的，不过现实中不建议这样重写去改变原本默认行为，可能会导致出现不可预料的错误。但是不可否认，这种骚操作的题，一定程度上可以反馈出我们对JS基础、还有一些底层操作的理解。学习路上，真的是任重而道远啊~</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析浏览器另外三大缓存</title>
    <link href="/2020/02/18/%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%A6%E5%A4%96%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98/"/>
    <url>/2020/02/18/%E6%B5%85%E6%9E%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%A6%E5%A4%96%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>上一篇分析了浏览器缓存类型之一：HTTP缓存，接下来简单分析一下浏览器另外的三大缓存机制：Memory Cache、Service Worker Cache以及Push Cache。</p></blockquote><a id="more"></a><h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>Memory Cache是指内存中的缓存，是浏览器尝试命中的优先级最高的缓存，其响应速度也是最快的。</p><p>哪些资源会被放进内存缓存呢？这个没有明确的规定，因为内存本身就是有限的，对于内存来讲，很多时候需要考虑内存的即时余量以及资源本身大小，根据日常开发观察的结果，base64格式的图片几乎是被放到内存缓存，而文件体积较小的JS、CSS文件，也有很大的几率可以写进内存缓存，至于体积比较大的，用一句俗话来讲，就是“庙小容不了大佛”，几乎是不可能给写进内存缓存的。</p><p>内存缓存的响应速度虽然很快，但是相应的，它的“寿命”是比较短的，当我们关闭tab之后，内存里的数据也将不复存在。</p><h3 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h3><p>service worker运行在worker上下文，因此它无法访问DOM，同时独立于主线程，可以在浏览器幕后帮我们实现消息推送、离线缓存等操作，而借助于service worker实现的缓存，就是离线缓存。</p><blockquote><p>PS：出于安全考量，Service workers只能由HTTPS承载。</p></blockquote><p>service worker需要先进行install（安装），之后会一直存在，并且只在active（激活）和working（工作）之间切换，直到我们主动终止。</p><p>下面看实践的例子，新建<code>index.html</code>和<code>index.js</code>两个文件</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>service worker test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">     <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) &#123;</span><br><span class="javascript">       <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">         navigator.serviceWorker.register(<span class="hljs-string">&#x27;./index.js&#x27;</span>, &#123;<span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;./&#x27;</span>&#125;)</span><br><span class="javascript">         .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="javascript">           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`注册成功`</span>)</span><br>         &#125;)<br><span class="javascript">         .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;</span><br><span class="javascript">           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`注册失败：<span class="hljs-subst">$&#123;err&#125;</span>`</span>)</span><br>         &#125;)<br>       &#125;)<br>     &#125; <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一步，先判断浏览器是否支持<code>serviceWorker</code>；</p><p>第二步，浏览器若支持，再通过<code>register</code>方法注册<code>index.js</code>文件，scope指定service worker控制内容的子目录，该参数为可选参数，默认为根目录；</p><p>第三步，通过返回的Promise，了解注册成功或失败</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><br><span class="hljs-built_in">this</span>.addEventListener(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.waitUntil(<br>    caches.open(<span class="hljs-string">&#x27;v1&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">cache</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> cache.addAll([<br>        <span class="hljs-string">&#x27;index.html&#x27;</span><br>      ])<br>    &#125;)<br>  )<br>&#125;)<br></code></pre></td></tr></table></figure><p>第一步，通过<code>install</code>方法，安装service worker；</p><p>第二步，这里要注意的是，从安装到激活这个过程需要一些时间，service worker标准提供一个<code>waitUntil</code>方法，当<code>oninstall</code>或者<code>onactivate</code>触发时被调用，接受一个promise。在这个 promise被成功resolve以前，功能性事件不会分发到service worker；</p><p>第三步，我们在<code>waitUntil</code>方法里面使用了<code>cache.open</code>来创建一个新的缓存v1，它返回一个promise，在被resolved之后调用<code>addAll</code>方法来添加要缓存的资源的路径；如果被rejected，service worker不会做任何操作。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>通过webstorm打开index.html，可以为我们开启一个本地服务器，运行后可以看到：</p><p>注册成功</p><p><img src="/images/%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F.png" alt="注册成功"></p><p>缓存成功</p><p><img src="/images/%E7%BC%93%E5%AD%98%E6%88%90%E5%8A%9F.png" alt="缓存成功"></p><h4 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h4><p>我们成功添加缓存之后，接下来就是要使用缓存。</p><p>Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以通过监听fetch事件来处理我们的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><br><span class="hljs-built_in">this</span>.addEventListener(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.respondWith(<br>    caches.match(event.request)<br>  )<br>&#125;)<br></code></pre></td></tr></table></figure><p>第一步，监听fetch事件；</p><p>第二步，通过<code>respondWith</code>方法劫持请求；</p><p>第三步，可以自定义我们的操作，当然最简单粗暴的就是直接返回我们缓存的资源</p><p>再刷新浏览器，可以看到，index.html来自于service worker cache</p><p><img src="/images/%E4%BD%BF%E7%94%A8serviceWorker%E7%BC%93%E5%AD%98.png" alt="使用serviceWorker缓存"></p><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>push cache（推送缓存）是比较新颖的东西，属于HTTP/2，当前面几种缓存没有命中的时候，才会询问推送缓存。</p><p>具体的可以查看Jake Archibald大神的<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP/2 push is tougher than I thought</a></p><p>文章中有部分结论：</p><ul><li>Push Cache 是缓存的最后一道防线。浏览器只有在 前面说到的几种缓存均未命中的情况下才会去询问 Push Cache；</li><li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放；</li><li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache；</li><li>Push Cache 中的缓存只能被使用一次</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>浏览器的缓存知识博大精深，就算不断在工作中和学习中实践，也只能说理解皮毛。而理解浏览器缓存，也仅仅是我们对页面性能优化的第一步，还有更多的操作等着我们。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析HTTP缓存</title>
    <link href="/2020/02/13/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2020/02/13/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>浏览器缓存机制有<strong>四个方面</strong>，按照资源获取优先级排列，分别是<code>Memory Cache</code>、<code>Service Worker Cache</code>、<code>HTTP Cache</code>、<code>Push Cache</code>。我们经常使用，也比较熟悉的是HTTP Cache。这里单独分析HTTP Cache。</p></blockquote><a id="more"></a><h3 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h3><p>HTTP Cache又分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存优先级比较高，未命中强缓存时才走协商缓存。</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存是通过http头的<code>expires</code>和<code>cache-control</code>来实现控制。当再发出请求时，浏览器会根据<code>expires</code>和<code>cache-control</code>来判断是否命中强缓存，若命中直接从缓存中获取资源，而不再与服务端进行通信。</p><p>在http1.0版本中，服务器响应时会返回一个缓存过期时间戳字段<code>expires</code>，再次发起请求时浏览器通过本地时间与<code>expires</code>时间戳对比，来判断缓存是否过期，这种依赖本地时间的方式会存在一个弊端，如果修改了本地时间，或者本地时间与服务端时间不同步，这将达不到我们预期的缓存效果。</p><p>因此，在http1.1版本中，引入了<code>expires</code>的替代方案：<code>Cache-Control</code>。<code>Cache-Control</code>能做<code>expires</code>做的事，也能做<code>expires</code>做不到的事情，目前<code>expires</code>还存在是为了做向下兼容。</p><p><code>Cache-Control</code>的格式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Cache-Control: max-age=<span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>在<code>Cache-Control</code>中，<code>max-age</code>字段表示资源最大缓存时间（秒），上面例子表示在3600秒内该资源都是有效的。<code>Cache-Control</code>表示的时间比<code>expires</code>时间戳更为准确，同时<code>Cache-Control</code>优先级更高，两者存在时以<code>Cache-Control</code>为准。</p><p><code>Cache-Control</code>还有其它的缓存方式：<code>no-cache</code>和<code>no-store</code>。</p><p>如果给资源设置了<code>no-cache</code>，则会绕开浏览器，直接询问服务器该资源是否过期，即走<strong>协商缓存</strong>。<code>no-store</code>顾名思义，就比较绝情了，不设置任何缓存，每次发起请求不经过浏览器与服务端缓存，直接想服务器发送请求，并下载完整的响应。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存，顾名思义就是浏览器与服务器合作的缓存策略，它依赖于浏览器与服务器之间的通信，浏览器需要向服务器询问缓存的相关信息，进而判断是读取本地缓存的资源还是重新发起请求，下载完整的响应。</p><h5 id="协商缓存的实现"><a href="#协商缓存的实现" class="headerlink" title="协商缓存的实现"></a>协商缓存的实现</h5><p><strong>Last-Modified</strong></p><p><code>Last-Modified</code>是一个时间戳，在启用协商缓存之后，会在首次请求的时候，随着Response Headers返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Last-Modified: Wed, <span class="hljs-number">12</span> Feb <span class="hljs-number">2020</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">28</span> GMT<br></code></pre></td></tr></table></figure><p>随后每次请求会带上<code>If-Modified-Since</code>时间戳字段，值为上一次Response返回的<code>Last-Modified</code>值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">If-Modified-Since: Wed, <span class="hljs-number">12</span> Feb <span class="hljs-number">2020</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">28</span> GMT<br></code></pre></td></tr></table></figure><p>服务器收到这个时间戳之后，会根据该时间戳与服务器的资源的最后修改时间对比，如果时间改变，则返回一个新的完整的响应，并在Response Headers返回新的<code>Last-Modified</code>值；如果时间没有变化，则返回一个304状态码，提示资源并未改动，然后重定向到浏览器缓存，Response Headers也不会再返回<code>Last-Modified</code>字段，如下图：</p><p><img src="/images/304.png" alt="304"></p><p>但是使用<code>Last-Modified</code>也会存在弊端：</p><ul><li>资源文件改动了，但是并没有改变内容，文件的最后修改时间会变化，导致该资源会被重新请求</li><li><code>If-Modified-Since</code>是以秒为单位做检验，如果改动文件的时间小于1000ms，那么该资源有可能被认为是未改变的，导致无法重新请求</li></ul><p>这两种情况反映了一个问题，无法准确感知文件是否发生改变。</p><p>为了解决该问题，<code>Etag</code>出现了。</p><p><code>Etag</code>是服务器为每个资源生成的唯一的<strong>标识字符串</strong>，这个标识字符串是基于文件内容编码的，文件内容不同，对应的 <code>Etag</code> 就是不同的，因此<code>Etag</code> 能够精准地感知文件的变化。</p><p><code>Etag</code> 和 <code>Last-Modified</code> 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这个样子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ETag: W/<span class="hljs-string">&quot;1q2w-108946715&quot;</span><br></code></pre></td></tr></table></figure><p>在下一次请求时，会带上与之相同值的字段<code>if-None-Match</code>，提供给服务器对比</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">If-None-Match: W/<span class="hljs-string">&quot;1q2w-108946715&quot;</span><br></code></pre></td></tr></table></figure><p>很明显，<code>Etag</code>有利也有弊，它的生成需要服务器付出额外的开销，会影响服务器的性能，<code>Etag</code>并不能直接代替<code>Last-Modified</code>，而是作为补充，它的优先级比<code>Last-Modified</code>高，两者共存时，以<code>Etag</code>为准。</p><h3 id="HTTP缓存策略"><a href="#HTTP缓存策略" class="headerlink" title="HTTP缓存策略"></a>HTTP缓存策略</h3><p>对于上面讲的知识点，要如何对应到实际的开发中呢，这边拿了谷歌官方的一张图：</p><p><img src="/images/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt="缓存策略"></p><p>这张图片清楚地给我们展示了缓存策略流程。</p><p>首先看看资源的可复用性，如果是不可复用的话，很干脆，直接把<code>Cache-control</code>设置为<code>no-store</code>，不需要任何形式的缓存。</p><p>如果是可复用的资源，那么看看是否需要每次都向服务器去验证缓存是否有效，如果需要，则设置<code>Cache-control</code>为<code>no-store</code>，不需要的，则进行下一步，考虑资源是否可被代理服务器缓存，根据情况设置<code>private</code>或<code>public</code>；接着考虑资源的过期时间，设置资源的<code>max-age</code>；最后一步配置协商缓存，设置<code>Last-Modified</code>和<code>Etag</code>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>HTTP缓存的知识点比较琐碎，很多人过段时间很容易忘记。只有多分析多总结，才能够把握这些知识。</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 -- Module</title>
    <link href="/2020/01/20/Module/"/>
    <url>/2020/01/20/Module/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>讲到模块化，大家可能对CommonJs、AMD、CMD等规范都比较熟悉，ES6也有Module的规范。本文是对Module理解的整理。那依然先是问题三连：ES6的Module是什么？用来解决什么问题？优点是什么？</p><a id="more"></a><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>使用不同方式加载的JS文件，与原先脚本（script）加载方式相对。模块的真正力量在于按需导出和导入，而不在于将所有内容放在同一个文件</p><h3 id="解决什么问题（切入点）"><a href="#解决什么问题（切入点）" class="headerlink" title="解决什么问题（切入点）"></a>解决什么问题（切入点）</h3><ol><li>命名冲突（作用域）</li><li>让JS应用变得更加有条理</li><li>安全问题</li></ol><h3 id="优点是什么"><a href="#优点是什么" class="headerlink" title="优点是什么"></a>优点是什么</h3><ol><li>自动运行在严格模式下，且无法跳出严格模式；</li><li>在模块的顶级作用域创建的变量，不会自动添加到共享的全局作用域，只存在于模块顶级作用域的内部；</li><li>模块顶级作用域的<code>this</code>为<code>undefined</code>；</li><li>模块中不允许<code>HTML</code>风格的注释，该问题是早期浏览器历史遗留特性；</li><li>要提供给外部访问的代码，模块必须导出它们；</li><li>模块可以由别的模块导入绑定。</li></ol><h3 id="基本导出"><a href="#基本导出" class="headerlink" title="基本导出"></a>基本导出</h3><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>我们可以在任意变量、函数、类声明之前加上<code>export</code>导出它们，没有被显式导出的将会在模块中保持私有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Ysom&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    constrcutor (name, sex) &#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.sex = sex<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 导出引用</span><br><span class="hljs-keyword">export</span> &#123; sayHello &#125;<br></code></pre></td></tr></table></figure><h3 id="基本导入"><a href="#基本导入" class="headerlink" title="基本导入"></a>基本导入</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>可以通过<code>import</code>来导入被导出的模块，<code>import</code>语句由两部分组成，被导入的<strong>标识符</strong>和导入标识符的<strong>来源</strong>：<code>import &#123; identifier1, identifier2 &#125; from &#39;./module1.js&#39;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入单个绑定</span><br><span class="hljs-keyword">import</span> &#123; sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br><span class="hljs-comment">// 导入多个绑定</span><br><span class="hljs-keyword">import</span> &#123; sum, sayHello &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br><span class="hljs-comment">// 完全导入一个模块 module所有的导出绑定在example 属于命名空间导入(namespace import)</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> example <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br></code></pre></td></tr></table></figure><p>需要注意的一点：无论使用多少次<code>import</code>引入模块，该模块只会执行一次。在导出的模块执行之后，已被实例化的模块会保留在内存中，随时可被其它<code>import</code>使用。同应用的其它模块，如使用<code>import</code>引入该模块，使用的也是同一个实例模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; sum &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br><span class="hljs-keyword">import</span> &#123; sayHello &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br><span class="hljs-comment">// 在这里modules.js只会执行一次，之后保留在内存中</span><br></code></pre></td></tr></table></figure><p>import和export有一个限制：无法在其它语句或表达式的内部使用，即必须在顶部作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// error</span><br>    <span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxx&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// error</span><br>    <span class="hljs-keyword">export</span> xx<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>题外话：在已完成的ES2020的提案中，有了新特性动态导入<a href="https://github.com/tc39/proposal-dynamic-import">dynamic-import</a>，可根据条件判断支持按需导入</p></blockquote><h3 id="默认导入-模块的默认值"><a href="#默认导入-模块的默认值" class="headerlink" title="默认导入-模块的默认值"></a>默认导入-模块的默认值</h3><p>我们可以通过<code>default</code>为每一个模块设置一个且只能一个默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;export&#x27;</span><br><span class="hljs-comment">// 1 默认导出可以不用给声明加上名称 因为代表整个模块导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;&#125;<br><span class="hljs-comment">// 2 也可先声明 再导出</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">num1, num2</span>) </span>&#123;&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> sum<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入模块默认值 默认值无需加上花括号&#123;&#125;</span><br><span class="hljs-keyword">import</span> sum <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br>sum(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)<br><span class="hljs-comment">// 导入默认值及其它导出功能 默认名称需在位于非默认名称之前</span><br><span class="hljs-keyword">import</span> sum, &#123; name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(name) <span class="hljs-comment">// export</span><br>sum(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)<br><span class="hljs-comment">// 重命名</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> sum, name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="绑定导入，再导出"><a href="#绑定导入，再导出" class="headerlink" title="绑定导入，再导出"></a>绑定导入，再导出</h3><p>有时候我们会需要将导入的部分功能，再导出去作为另一个模块，比如作为库，这时候可以这样操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// new-module.js</span><br><span class="hljs-comment">// 1 先导入 再导出</span><br><span class="hljs-keyword">import</span> &#123; identifier1, identifier2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./m1.js&#x27;</span><br><span class="hljs-keyword">export</span> &#123; identifier1, identifier2 &#125;<br><span class="hljs-comment">// 2 会进入模块查看sum, sayHello的定义，并导出</span><br><span class="hljs-keyword">export</span> &#123; sum, sayHello &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br><span class="hljs-comment">// 3 完全导出</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span><br></code></pre></td></tr></table></figure><p>完全导出需要注意一个问题，如果目标模块<code>module</code>包含了默认值，那么就无法在当前模块<code>new-module</code>再定义一个默认导出，始终遵守一个模块只能有一个默认导出的原则</p><h3 id="无绑定的导入"><a href="#无绑定的导入" class="headerlink" title="无绑定的导入"></a>无绑定的导入</h3><p>有时候我们会对全局作用域对象进行一些附加操作，虽然模块中的代码不会自动共享到全局，但是我们还是可以在模块中对一些JS内置对象如<code>Array</code>、<code>Object</code>等进行访问，并且对这些对象的修改，可以反映到其它模块中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// extendArray.js</span><br><span class="hljs-comment">// 给数组添加一个pushAll的方法</span><br><span class="hljs-built_in">Array</span>.prototype.pushAll = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items</span>) </span>&#123;<br>    <span class="hljs-comment">// 判断items是否为数组</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(items)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`arguments must be an array`</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.push(...items)<br>&#125;<br></code></pre></td></tr></table></figure><p>再通过<code>import &#39;./extendArray.js&#39; </code>将模块引入，这里虽然没有绑定的导出与导入，但依然是一个有效的模块，在引入该模块的模块中，所有的数组都可以使用<code>pushAll()</code>方法</p><p>这种无绑定的导入，最有可能创建用于在旧环境运行新语法时做向下兼容的<code>polyfill</code>和<code>shim</code></p><h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><blockquote><p>ES6定义了模块的语法，但未定义如何加载。</p></blockquote><h4 id="在web浏览器中使用模块"><a href="#在web浏览器中使用模块" class="headerlink" title="在web浏览器中使用模块"></a>在web浏览器中使用模块</h4><p>在ES6之前，已经存在多种方式可以在web应用中加载JS</p><ol><li>使用<code>&lt;script&gt;</code>标签以及<code>src</code>属性指定加载的位置，加载JS文件；</li><li>使用<code>&lt;script&gt;</code>标签但不使用<code>src</code>属性，嵌入内联的JS代码；</li><li>加载JS代码文件并作为<code>Worker</code>（例如<code>Web Worker</code>或<code>Service Worker</code>）来执行</li></ol><h5 id="通过script加载模块"><a href="#通过script加载模块" class="headerlink" title="通过script加载模块"></a>通过script加载模块</h5><p>在使用script标签时，设置type属性为module，告诉浏览器将引入的代码作为模块。且会自动应用defer属性，将模块文件下载完后，等待网页文档全部解析完，再按照模块引入顺序依次执行。如果需要异步加载模块，则可以手动加上async属性</p><h5 id="将模块作为Worker加载"><a href="#将模块作为Worker加载" class="headerlink" title="将模块作为Worker加载"></a>将模块作为Worker加载</h5><p>为了支持模块加载，HTML标准的开发者给worker添加了第二个参数，该参数时带有<code>type</code>属性的对象，默认值为<code>script</code>，可以设置为<code>module</code>，以此来加载模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 脚本方式</span><br><span class="hljs-keyword">let</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;script.js&#x27;</span>)<br><br><span class="hljs-comment">// 模块方式</span><br><span class="hljs-keyword">let</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;module.js&#x27;</span>)<br></code></pre></td></tr></table></figure><p>模块方式其中存在两点区别：</p><ol><li>worker脚本被限制只能从同源网页加载，worker模块不受限制；</li><li>worker脚本可以使用<code>self.importScripts()</code>方法来将额外脚本引入worker，worker模块上的<code>self.importScripts()</code>总是失败，因为应当换用成<code>import</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>振奋人心的ES2020新特性！</title>
    <link href="/2020/01/13/finished-proposals-ES2020/"/>
    <url>/2020/01/13/finished-proposals-ES2020/</url>
    
    <content type="html"><![CDATA[<p>ES2020已完成的<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">提案</a>中，有了比较振奋人心的新特性。下面来看看几个比较有意思的特性</p><h3 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h3><p>在JS的<code>Number</code>类型中，安全值的范围为<code>Number.MIN_SAFE_INTEGER</code>-<code>Number.MAX_SAFE_INTEGER</code>，即-(2<sup>53</sup>-1)~2<sup>53</sup>-1，超出该范围整数计算或表示将会丢失精度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> max_num = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER <span class="hljs-comment">// 9007199254740991</span><br><span class="hljs-keyword">let</span> more_num = max_num + <span class="hljs-number">1</span> <span class="hljs-comment">// 9007199254740992</span><br><span class="hljs-keyword">let</span> more_max_num = max_num + <span class="hljs-number">2</span> <span class="hljs-comment">// 9007199254740992</span><br></code></pre></td></tr></table></figure><p>可以看到，当数值超过安全范围时，就不会正确表示，甚至还有以下情况</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">9007199254740992</span> === <span class="hljs-number">9007199254740993</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>新规范<code>BigInt</code>就是用来解决大数计算问题，同时它也属于原始类型。可以在整数后面加上n或者BigInt函数来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接在整数后面加n</span><br><span class="hljs-keyword">let</span> bigNum = <span class="hljs-number">9007199254740993n</span><br><br><span class="hljs-comment">// 使用BigInt函数</span><br><span class="hljs-keyword">let</span> bigNum = BigInt(<span class="hljs-number">9007199254740993</span>)<br><span class="hljs-comment">// or </span><br><span class="hljs-keyword">let</span> bigNum = BigInt(<span class="hljs-string">&#x27;9007199254740993&#x27;</span>)<br><br><span class="hljs-comment">// 大数运算</span><br><span class="hljs-keyword">let</span> superNum = <span class="hljs-number">9007199254740993n</span> + <span class="hljs-number">9007199254740993n</span> <br><span class="hljs-comment">// 18014398509481986n</span><br><span class="hljs-keyword">typeof</span> superNum <span class="hljs-comment">// &#x27;bigInt&#x27;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，使用<code>BigInt</code>函数实例化大数时，会将参数进行Number类型的实例化，超出安全范围的数字可能会引起精度丢失</p><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>用过<code>Promise.all</code>的都知道，这方法有一个比较明显的缺陷，只要其中一个Promise被<code>reject</code>，整个<code>Promise.all</code>就会挂掉，剩下的Promise都会停止执行。例如在一个用户模块中，通过并发异步请求多个版块的数据，只要其中一个服务挂了，其它的版块也就不会拿到数据。很明显，这并不是我们想要的，我们希望并发的任务，不管是异常还是正常，都可以返回对应的状态和值，这样就可以最大限度地保证服务的可访问性。新特性<code>Promise.allSettled</code>就是来满足这一要求的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.allSettled([<br>    <span class="hljs-built_in">Promise</span>.reject(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fail&#x27;</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;服务异常&#x27;</span>&#125;),<br>    <span class="hljs-built_in">Promise</span>.resolve(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;suc&#x27;</span>, <span class="hljs-attr">data</span>: &#123;&#125;&#125;),<br>    <span class="hljs-built_in">Promise</span>.resolve(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;suc&#x27;</span>, <span class="hljs-attr">data</span>: &#123;&#125;&#125;)<br>]).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 0: &#123;status: &#x27;rejected&#x27;, reason: &#123;&#125;&#125;,</span><br><span class="hljs-comment">    * 1: &#123;status: &#x27;fulfilled&#x27;, value: &#123;&#125;&#125;,</span><br><span class="hljs-comment">    * 2: &#123;status: &#x27;fulfilled&#x27;, value: &#123;&#125;&#125;</span><br><span class="hljs-comment">    */</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>当服务异常时，会返回status和reason字段，reason值为reject的值，而当服务正常时，会返回status和value字段。可以通过filter函数来过滤出fulfilled状态的数据，从而实现服务正常的数据渲染</p><h3 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h3><p>一般我们很难写出可移植的js代码来访问全局对象，因为在不用的环境全局对象也不同。在web中，全局对象为<code>window</code>、<code>self</code>，在node中，为<code>global</code>，甚至很多时候会使用<code>this</code>来访问全局对象，但是<code>this</code>严重依赖上下文，还会存在各种改变<code>this</code>指向的情况，这会导致更加复杂。而现在，通过一个<code>globalThis</code>就可以轻松获取到当前环境下的全局对象，是不是很清爽？</p><h3 id="optional-Chaining"><a href="#optional-Chaining" class="headerlink" title="optional Chaining"></a>optional Chaining</h3><p>如果我们要使用到多层级对象中的某个属性，为了避免属性不存在时抛出错误，需要经过一系列前置的繁琐的判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = &#123;&#125;<br><span class="hljs-keyword">if</span> (data &amp;&amp; data.options &amp;&amp; data.options.name) &#123;<br>    <span class="hljs-keyword">let</span> name = data.options.name<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来很麻烦。有了<strong>可选链</strong>新特性后，只需简单一句代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = data?.options?.name<br></code></pre></td></tr></table></figure><p>判断<code>?</code>前的属性是否存在，存在才会继续查询<code>.</code>后面的属性。简化了大量前置校验，且更为安全</p><h3 id="Nullish-coalescing-Operator"><a href="#Nullish-coalescing-Operator" class="headerlink" title="Nullish coalescing Operator"></a>Nullish coalescing Operator</h3><p>在对某个变量或对象的属性赋值时，我们会经常做以下类似的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> defaultFlag = <span class="hljs-string">&#x27;default&#x27;</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    name: defaultFlag || <span class="hljs-string">&#x27;obj&#x27;</span>,<br>    value: <span class="hljs-number">18</span>,<br>    level: <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>defaultFlag</code>转换为布尔值是true的时候，就会采用<code>defaultFlag</code>代表的值，否则采用值<code>obj</code>，但是这会有一些问题，比如值为0的时候，<code>defaultFlag</code>的值就为false，这会跳过0直接赋值为后面的值，如果我们允许0的存在，那这里就会出现预想中的误差。再看新特性<strong>空值合并运算符</strong> <code>??</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> level = obj.level ?? <span class="hljs-string">&#x27;暂无等级&#x27;</span><br></code></pre></td></tr></table></figure><p>使用空值合并运算符之后，只有当值为<code>undefined</code>、<code>null</code>的时候，才会跳过，赋值为后面的值</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 -- Proxy</title>
    <link href="/2020/01/01/ES6----Proxy/"/>
    <url>/2020/01/01/ES6----Proxy/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文总结了<code>Proxy</code>代理的陷阱函数和对应的<code>Reflect</code>接口默认行为函数的用法。因为目前用的最多的技术栈是<code>Vue</code>，而<code>Vue3.0</code>版本其中关于响应式原理的核心是<code>Proxy</code>，因此有必要对<code>Proxy</code>做进一步的理解和总结。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>拦截对象：设置属性值行为。成功返回<code>true</code>，失败返回<code>false</code>。</p><p>默认行为实现：<code>Reflect.set()</code></p><a id="more"></a><p>接收参数：</p><ol><li><strong>trapTarget</strong>：设置属性的对象（代理的目标对象）</li><li><strong>key</strong>：属性的键</li><li><strong>value</strong>：属性的值</li><li><strong>receiver</strong>：操作发生的对象（通常指代理对象）</li></ol><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>拦截对象：获取属性值行为。</p><p>默认行为实现：<code>Reflect.get()</code></p><p>接收参数：</p><ol><li><strong>trapTarget</strong>：获取属性的对象（代理的目标对象）</li><li><strong>key</strong>：属性的键</li><li><strong>receiver</strong>：操作发生的对象（通常指代理对象）</li></ol><p>骚操作：属性不存在时可明确抛出错误，而不是返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> target = &#123;&#125;<br><span class="hljs-keyword">let</span> proxyTar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>    get (trapTarget, key, receiver) &#123;<br>        <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> receiver)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`property <span class="hljs-subst">$&#123;key&#125;</span> is not exist`</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(trapTarget, key, receiver)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p>拦截对象：<code>in</code>操作符。成功返回<code>true</code>，失败返回<code>false</code>。</p><p>默认行为实现：<code>Reflect.has()</code></p><p>接收参数：</p><ol><li><strong>trapTarget</strong>：读取属性的对象</li><li><strong>key</strong>：需要检查的属性的键</li></ol><p>骚操作：通过返回<code>false</code>，隐藏属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> target = &#123;<br>    name: <span class="hljs-string">&#x27;小叮当&#x27;</span>,<br>    _age: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">let</span> proxyTar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>    has (trapTarget, key) &#123;<br>        <span class="hljs-comment">// 隐藏_age属性</span><br>        <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;_age&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.has(trapTarget, key)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p>拦截对象：<code>delete</code>操作符。成功返回<code>true</code>，失败返回<code>false</code>。</p><p>默认行为实现：<code>Reflect.deleteProperty()</code></p><p>接收参数：</p><ol><li><strong>trapTarget</strong>：删除属性的对象</li><li><strong>key</strong>：需要删除的属性的键</li></ol><p>骚操作：通过返回<code>false</code>，设置属性不可删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> target = &#123;<br>    name: <span class="hljs-string">&#x27;小叮当&#x27;</span>,<br>    age: <span class="hljs-number">18</span>,<br>    idCard: <span class="hljs-string">&#x27;75423546574xxx&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> proxyTar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>    deleteProperty (trapTarget, key) &#123;<br>        <span class="hljs-comment">// idCard属性不可删除</span><br>        <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;idCard&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(trapTarget, key)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h3><p>拦截对象：<code>Object.getPrototypeOf()</code>。返回值必须是一个对象或者是<code>null</code>，其它类型返回值会引发错误。</p><p>默认行为实现：<code>Reflect.getPrototypeOf()</code></p><p>接收参数：</p><ol><li><strong>trapTarget</strong>：需要获取原型的对象</li></ol><p>骚操作：可通过返回<code>null</code>来隐藏对象原型</p><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h3><p>拦截对象：<code>Object.setPrototypeOf()</code>。操作不成功时应返回<code>false</code>以让<code>Object.setPrototypeOf()</code>抛出错误，若返回不为<code>false</code>，则认为操作成功。</p><p>默认行为实现：<code>Reflect.setPrototypeOf()</code></p><p>接受参数：</p><ol><li><strong>trapTarget</strong>：需要设置原型的对象</li><li><strong>proto</strong>：被用作原型的对象</li></ol><p>骚操作：可通过返回<code>false</code>使对象原型不可被设置</p><p><strong>为何存在<code>Reflect.getPrototypeOf()</code>、<code>Reflect.setPrototypeOf()</code>与<code>Object.getPrototypeOf()</code>、<code>Object.setPrototypeOf()</code>两组方法？</strong></p><p>两组方法作用虽然相似，但还是存在一些比较显著的差别：</p><ol><li>前者属于JS引擎底层操作，后者属于高级操作；</li><li><code>Reflect.getPrototypeOf()</code>接收的参数不是对象时会抛出错误；而<code>Object.getPrototypeOf()</code>操作前会先将参数转换为对象；</li><li><code>Reflect.setPrototypeOf()</code>会返回布尔值<code>true</code>或<code>false</code>表示成功或失败，<code>Object.setPrototypeOf()</code>操作失败时会报错，成功时会将第一个参数作为返回值；</li></ol><p>因此，Object两个原型操作方法并不适合用来实现代理陷阱的默认行为。</p><h3 id="对象可扩展性的陷阱函数"><a href="#对象可扩展性的陷阱函数" class="headerlink" title="对象可扩展性的陷阱函数"></a>对象可扩展性的陷阱函数</h3><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h3><p>拦截对象：<code>Object.preventExtensions()</code>。返回<code>true</code>或<code>false</code>表示操作成功或失败。</p><p>默认行为实现：<code>Reflect.preventExtensions()</code>。</p><p>接收参数：</p><ol><li><strong>trapTarget</strong>：设置不可扩展的对象</li></ol><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h3><p>拦截对象：<code>Object.isExtensible()</code>。返回<code>true</code>或<code>false</code>表示操作成功或失败。</p><p>默认行为实现：<code>Reflect.isExtensible()</code>。</p><p>接收参数：</p><ol><li><strong>trapTarget</strong>：设置可扩展的对象</li></ol><p><strong>为何存在<code>Reflect.preventExtensions()</code>、<code>Reflect.isExtensible()</code>与<code>Object.preventExtensions()</code>、<code>Object.isExtensible()</code>两组方法？</strong></p><p>两组方法几乎一致，但有一些差别：</p><ol><li>接收的参数不为对象时，<code>Object.isExtensible()</code>是返回<code>false</code>，而<code>Reflect.isExtensible()</code>会抛出错误；</li><li><code>Object.preventExtensions()</code>不管参数是否是对象，都会将参数值作为自身返回值，而<code>Reflect.preventExtensions() </code>方法则会在参数不是对象时抛出错误，在参数为对象时返回<code>true</code>或<code>false</code>表示操作成功或失败；</li><li>底层功能的方法与对应的高层方法相比，会进行更为严格的校验；</li></ol><h3 id="属性描述符的陷阱函数"><a href="#属性描述符的陷阱函数" class="headerlink" title="属性描述符的陷阱函数"></a>属性描述符的陷阱函数</h3><h3 id="definedProperty"><a href="#definedProperty" class="headerlink" title="definedProperty"></a>definedProperty</h3><p>拦截对象：<code>Object.defineProperty()</code>，返回<code>true</code>或<code>false</code>表示操作成功或失败。</p><p>默认行为实现：<code>Reflect.defineProperty()</code>。</p><p>接收参数：</p><ol><li><strong>tarpTarget</strong>：被定义属性的对象</li><li><strong>key</strong>：属性的键</li><li><strong>descriptor</strong>：为该属性准备的描述符对象</li></ol><p>骚操作：可通过主动返回<code>false</code>让<code>Object.defineProperty()</code>抛出错误失败，也可通过返回<code>true</code>而不调用<code>Reflect.defineProperty()</code>来让<code>Object.defineProperty()</code>静默失败。</p><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h3><p>拦截对象：<code>Object.getOwnPropertyDescriptor()</code>，返回对应的描述符。</p><p>默认行为实现：<code>Reflect.getOwnPropertyDescriptor()</code>。</p><p>接收参数：</p><ol><li><strong>tarpTarget</strong>：被检索属性的对象</li><li><strong>key</strong>：属性的键</li></ol><p><strong>为何存在<code>Reflect.defineProperty()</code>、<code>Reflect.getOwnPropertyDescriptor()</code>与<code>Object.defineProperty()</code>、<code>Object.getOwnPropertyDescriptor()</code>两组方法？</strong></p><p>两组方法几乎一致，但也有一些差别：</p><ol><li><code>Object.defineProperty()</code>返回第一个参数值，而<code>Reflect.defineProperty()</code>返回<code>true</code>或<code>false</code>;</li><li>第一个参数不是对象时，<code>Object.getOwnPropertyDescriptor()</code>会将第一个参数转为对象，而<code>Reflect.getOwnPropertyDescriptor()</code>会抛出错误；</li></ol><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p>拦截对象：内部方法<code>[[OwnPropertyKeys]]</code>，返回一个数组重写该行为。数组被用于四个方法：<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>、<code>Object.assign()</code>，也能影响到<code>for-in</code>循环。不是返回数组或类数组对象，会抛出错误。</p><p>默认行为实现：<code>Reflect.ownKeys()</code>，返回一个由全部自有属性的键构成的数组，无论键的类型是<strong>字符串</strong>还是<strong>符号</strong>。</p><p>接收参数：</p><ol><li><strong>trapTarget</strong>：获取属性的目标对象</li></ol><p>骚操作：可通过设置，不返回比如拥有下划线的属性（一般被定义为私有属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> target = &#123;<br>    name: <span class="hljs-string">&#x27;target&#x27;</span>,<br>    _name: <span class="hljs-string">&#x27;private_target&#x27;</span> <span class="hljs-comment">// 私有属性</span><br>&#125;<br><span class="hljs-keyword">let</span> proxyTarget = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, &#123;<br>    ownKeys (trapTarget) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.ownKeys(trapTarget).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            <span class="hljs-comment">// 可返回符号类型、字符类型且不包含下划线的属性</span><br>            <span class="hljs-keyword">return</span> typeOf key !== <span class="hljs-string">&#x27;string&#x27;</span> || key[<span class="hljs-number">0</span>] !== <span class="hljs-string">&#x27;_&#x27;</span><br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="apply和construct"><a href="#apply和construct" class="headerlink" title="apply和construct"></a>apply和construct</h3><p>拦截对象：内部方法<code>[[Call]]</code>和<code>[[Construct]]</code>，前者会在函数被直接调用时执行，而后者会在函数被使用<code>new</code>运算符调用时执行。</p><p>apply陷阱函数(<code>Reflect.apply()</code>同样)接收参数：</p><ol><li><strong>trapTarget</strong> ：被执行的函数（即代理的目标对象）；</li><li><strong>thisArg</strong> ：调用过程中函数内部的 this 值；</li><li><strong>argumentsList</strong> ：被传递给函数的参数数组。</li></ol><p>construct陷阱函数接收参数：</p><ol><li><strong>trapTarget</strong> ：被执行的函数（即代理的目标对象）；</li><li><strong>argumentsList</strong> ：被传递给函数的参数数组。</li></ol><p><code>Reflect.construct()</code>除了上述两个参数，还有第三个可选参数<code>newTarget</code>，此参数指定了函数内部<code>new.target</code>的值。</p><p>骚操作：可以验证函数的类型；还可以不使用<code>new</code>来调用构造器；还可以限制函数只能通过<code>new</code>来调用等等。。。</p><h3 id="撤销代理"><a href="#撤销代理" class="headerlink" title="撤销代理"></a>撤销代理</h3><p>一般代理创建之后不会被解绑，如果想要创建一个可被撤销的代理，可通过<code>Proxy.revocable()</code>方法，该方法跟<code>Proxy</code>构造器一样接收两个参数：</p><ol><li><strong>trapTarget</strong>：被代理的目标对象</li><li><strong>handler</strong>：代理处理器</li></ol><p>然后会返回一个包含以下属性的对象：</p><ol><li><strong>proxy</strong>：可被撤销的代理对象</li><li><strong>revoke</strong>：用于撤销代理的函数</li></ol><p>通过调用<code>revoke()</code>，就无法再对<code>proxy</code>进行更多的操作，任何跟<code>proxy</code>的交互都会触发陷阱函数，从而抛出错误。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript整理总结(持续更新)</title>
    <link href="/2019/12/14/JavaScript%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/"/>
    <url>/2019/12/14/JavaScript%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/</url>
    
    <content type="html"><![CDATA[<h3 id="数据类型、存储方式"><a href="#数据类型、存储方式" class="headerlink" title="数据类型、存储方式"></a>数据类型、存储方式</h3><ul><li><p>原始（基本）类型，变量存储的是在栈内存的值<code>string</code>、<code>number</code>、<code>boolean</code>、<code>undefined</code>、<code>null</code>、<code>symbol</code>、（以及提案新增的<code>BigInt</code>）</p></li><li><p>引用（复杂）类型，变量存储的是在栈内存中的指针（地址），指向存储的地址，地址所在的堆内存存放着值。引用类型都是<code>object</code></p></li></ul><h3 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h3><a id="more"></a><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><ul><li><p>原始类型：除了<code>null</code>判断为<code>object</code>，其它的原始类型可以正确判断</p></li><li><p>对象类型：除了函数判断为<code>function</code>，其它的对象类型都为<code>object</code></p></li></ul><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>判断操作符右边的函数的原型是否存在于左边的对象的原型链上可以准确判断引用类型，无法正确判断原始类型</p><h3 id="正确判断变量类型的方式"><a href="#正确判断变量类型的方式" class="headerlink" title="正确判断变量类型的方式"></a>正确判断变量类型的方式</h3><ol><li><p><code>Object.prototype.toString.apply(target)</code> // <code>&#39;[object xxx]&#39;</code>获取索引的第八位到最后一位</p></li><li><p>先通过<code>typeof</code>判断是否为复杂类型，是则使用<code>instanceof</code>判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">data &amp;&amp; (<span class="hljs-keyword">typeof</span>(data) === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span>(data) === <span class="hljs-string">&#x27;function&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimitiveUndefined</span> </span>&#123;<br>   <span class="hljs-keyword">static</span> [<span class="hljs-built_in">Symbol</span>.hasInstance](data) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;undefined&#x27;</span>;<br>   &#125;<br>&#125;<br><br>data <span class="hljs-keyword">instanceof</span> PrimitiveUndefined<br><span class="hljs-comment">// 其它基本类型...</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="、"><a href="#、" class="headerlink" title="==、==="></a>==、===</h3><ul><li><code>==</code>符号只判断两个变量的值是否相等，<code>===</code>判断两个变量的类型和值</li><li><code>==</code>判断过程中，若两变量的类型不同，则会涉及到变量类型转换</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在JS中，类型转换只有三种情况</p><ol><li><p>转换为布尔值</p></li><li><p>转换为数字</p></li><li><p>转换为字符串</p></li></ol><p>下面图为转换规则</p><p><img src="/images/%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99.png" alt="转换规则"></p><h3 id="var、let、const"><a href="#var、let、const" class="headerlink" title="var、let、const"></a>var、let、const</h3><ul><li><p><code>var</code>声明的变量会被提升到作用域顶部，声明了全局变量则会挂载在window上面</p></li><li><p><code>let</code>跟<code>const</code>声明的变量存在暂时性死区，因此在变量声明前调用会报错</p></li><li><p><code>const</code>声明的变量是常量，为基础类型时值不能改变，复杂类型时地址不能改变</p></li></ul><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><ol><li><p>变量还没有被声明，但是可以被使用（值为<code>undefined</code>），提升的是声明（<code>var</code>声明）</p></li><li><p>函数也会被提升到作用域顶部，因此函数可以在声明之前调用，且函数提升优先于变量提升</p></li></ol><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ol><li><p>指向全局对象window</p></li><li><p>指向调用方法的对象</p></li><li><p>指向new操作符赋值后的对象</p></li><li><p>箭头函数没有this，也无法使用bind，this指向包裹该箭头函数的第一个普通函数</p></li><li><p>函数绑定多层bind的情况，由第一个bind决定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fn.bind().bind(a)()<br></code></pre></td></tr></table></figure></li><li><p>多个规则下this指向优先级：<code>new</code> &gt; <code>bind</code> &gt; <code>obj.fn</code> &gt; <code>fn</code></p></li></ol><h3 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h3><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h4><blockquote><p>闭包是函数和声明该函数的词法环境的组合 –MDN</p></blockquote><p>我的理解是，函数+该函数体可以访问的变量总和；函数不一定是在另一个函数里面声明，它也可以在外部声明，在另一个函数内部重新赋值</p><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><p>闭包的最多用途还是在于隐藏变量，常用于实现私有变量</p><h3 id="深、浅拷贝"><a href="#深、浅拷贝" class="headerlink" title="深、浅拷贝"></a>深、浅拷贝</h3><blockquote><p>深、浅拷贝的区别就是拷贝的值存在引用类型时，浅拷贝会把地址复制，而深拷贝不会</p></blockquote><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a><code>Object.assign()</code></h5><h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="...扩展运算符"></a><code>...</code>扩展运算符</h5><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a><code>JSON.parse(JSON.stringify(obj))</code></h5><p>局限性：</p><ol><li><p>不能序列化undefined、函数和symbol，会忽略</p></li><li><p>存在对象循环引用时，会报错</p></li></ol><h5 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a><code>MessageChannel</code></h5><p>当有内置类型，且不包含函数时使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MesCalDeepClone</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> &#123;port1, port2&#125; = <span class="hljs-keyword">new</span> MessageChannel()<br>      port2.onmessage = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> resolve(ev.data)<br>      port1.postMessage(obj)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>原型<code>__proto__</code>是一个对象，里面预设了一些函数和属性，包括了构造函数<code>constructor</code>；而构造函数拥有<code>prototype</code>属性，指回了原型对象，通过构造函数生成的实例对象，会自动将构造函数的原型设置为实例对象的原型。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>对象拥有原型对象，而原型对象也会拥有自己的原型，依次类推形成一条原型链，直到原型对象为<code>null</code>时结束即<code>Object.prototype.__proto__</code></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>在新的对象上复用现有对象的属性和方法，有助于避免重复代码和重复数据。</p></blockquote><h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>将函数A的原型赋值为函数B的实例，函数B的实例具有函数的全部属性以及指向超类的原型，以此实现原型继承。</p><p>这里借用《js忍者秘籍》第二版里面的一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Person.prototype.dance = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ninja</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// Ninja的原型赋值为Person的实例</span><br>Ninja.prototype = <span class="hljs-keyword">new</span> Person()<br></code></pre></td></tr></table></figure><p><img src="/images/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E4%BE%8B%E5%AD%90.png" alt="img"></p><p>这里有一个要注意的地方，当把<code>Ninja</code>的原型设置为<code>Person</code>的实例对象之后，<code>Ninja</code>和它原来的原型失去了联系，现有的原型的构造函数<code>constructor</code>也是指向<code>Person</code>而不是指向<code>Ninja</code>，所以需要做一步操作，重新建立起Ninja实例与Ninja的联系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.definedProperty(Ninja.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;<br>  enumerable: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可枚举</span><br>  value: Ninja, <span class="hljs-comment">// 值为Ninja</span><br>  writable: <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><p>class的出现是为了解决什么问题？为了让其它面向对象语言开发者适应和熟悉，ES6增加了关键字class来模拟类，class是语法糖，它的底层实现原理还是<strong>原型继承</strong>，使用<code>extends</code>也可以更优雅地继承</p><h3 id="new操作符的过程"><a href="#new操作符的过程" class="headerlink" title="new操作符的过程"></a>new操作符的过程</h3><ol><li>创建一个空对象</li><li>将该空对象作为上下文<code>this</code>传入构造函数</li><li>对该对象进行一系列初始化</li><li>返回该对象或函数指定的其它对象（非对象会忽略）</li></ol><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环中包含着几个比较重要的概念：</p><p>任务：宏任务、微任务</p><p>事件队列：宏任务队列、微任务队列</p><h3 id="用setTimeout延迟执行事件、setInterval间隔执行事件"><a href="#用setTimeout延迟执行事件、setInterval间隔执行事件" class="headerlink" title="用setTimeout延迟执行事件、setInterval间隔执行事件"></a>用setTimeout延迟执行事件、setInterval间隔执行事件</h3><ol><li><code>setTimeout</code>：延迟设定的时间执行，实际延迟时间大于等于设定的时间</li><li><code>setInterval</code>：间隔设定的时间执行，实际执行次数并不等于时间内间隔时间次数；当宏任务队列里面已经存在等待执行的该间隔任务，则不会再将该间隔任务添加进宏任务队列</li></ol><h3 id="事件捕获、冒泡"><a href="#事件捕获、冒泡" class="headerlink" title="事件捕获、冒泡"></a>事件捕获、冒泡</h3><ol><li><strong>捕获</strong>：事件自顶向下传递，从顶部元素到目标元素</li><li><strong>冒泡</strong>：事件自底向上传递，从目标元素到顶部元素若没指定捕获模式，则事件默认为冒泡模式 </li></ol><h3 id="事件处理器中的this和event-target的区别"><a href="#事件处理器中的this和event-target的区别" class="headerlink" title="事件处理器中的this和event.target的区别"></a>事件处理器中的this和event.target的区别</h3><ol><li><code>this</code>指向注册事件处理器的元素</li><li><code>event.target</code>指向事件发生的元素</li></ol><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>通过内置的<code>CustomEvent</code>构造函数和<code>dispatchEvent</code>方法实现自定义事件的<strong>创建</strong>和<strong>分发</strong>；</p><p>自定义事件的优势是<strong>代码解耦</strong>，可以编写共享代码，且更易于维护、调试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>  /*<br>  * @params<br>  * target绑定事件的对象名称 eventName事件名称 eventDetail事件参数<br>  */<br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">triggerEvent</span> (<span class="hljs-params">target, eventName, eventDetail</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> CustomEvent(eventName, &#123;</span><br>      detail: eventDetail<br>    &#125;)<br><span class="javascript">    <span class="hljs-comment">// 向指定元素派发事件</span></span><br>    target.dispatchEvent(event)<br>  &#125;<br><span class="javascript">  <span class="hljs-comment">// 给document绑定myEvent事件</span></span><br><span class="javascript">  triggerEvent(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;myEvent&#x27;</span>, &#123;<span class="hljs-attr">customName</span>: <span class="hljs-string">&#x27;my-event&#x27;</span>&#125;)</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020快到了，面对复盘的疾风吧！！！</title>
    <link href="/2019/12/09/2020%E5%BF%AB%E5%88%B0%E4%BA%86%EF%BC%8C%E9%9D%A2%E5%AF%B9%E5%A4%8D%E7%9B%98%E7%9A%84%E7%96%BE%E9%A3%8E%E5%90%A7%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <url>/2019/12/09/2020%E5%BF%AB%E5%88%B0%E4%BA%86%EF%BC%8C%E9%9D%A2%E5%AF%B9%E5%A4%8D%E7%9B%98%E7%9A%84%E7%96%BE%E9%A3%8E%E5%90%A7%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>还有20来天就是2020年了，今年的你技术有提升吗？体重下降了多少？19年末的你是不是19年初想象中的你呢？</p><p>对于我来说，“每逢佳节倍思亲，每到年底必操心”，最近本来想趁着年底，做一波基础技术复盘，优先选了js进行复盘，结果越复知识点越多，想整理成一篇博文篇幅又太长，想整成什么js知识点复盘上中下又太繁琐麻烦的样子，太难了，难于上青天啊~</p><p>但是青天可以不上，复盘清单还是要列的，做一些知识点的复盘总结，计划尽量月底完成（maybe吧，哈哈哈~）</p><a id="more"></a><p>第一个要复盘的，肯定是前端三剑客了</p><ol><li>HTML</li><li>CSS</li><li>JavaScript</li></ol><p>接下来就是工作中的技术栈和部分学习内容了</p><ol><li>Vue（双向绑定、响应式原理、组件设计、组件通信等）</li><li>Vuex+Vue-Router等Vue全家桶</li><li>微信小程序</li><li>计算机网络（TCP、HTTP、HTTP2、HTTP3等）</li><li>数据结构（这一块处于学习阶段，列出来鞭策自己）</li><li>NodeJS（这一块处于学习阶段，列出来鞭策自己）</li></ol><p>OMG，果然是“每到年底必操心”，大脑随便飘过的东西就已经这么多了，还有部分没有整理出来的比如<code>webpack</code>、<code>typescript</code>、web安全、性能优化等等，这也反映出，现在的weber需要掌握的知识点多、知识面广，并且广且深也是一个要求趋势了~</p><p>最后，暂且就给自己定这样的复盘小目标吧！后面能想到啥重要的，再补充~</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端幸福感是如何炼成的（下）</title>
    <link href="/2019/11/17/%E5%89%8D%E7%AB%AF%E5%B9%B8%E7%A6%8F%E6%84%9F%E6%98%AF%E5%A6%82%E4%BD%95%E7%82%BC%E6%88%90%E7%9A%84%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2019/11/17/%E5%89%8D%E7%AB%AF%E5%B9%B8%E7%A6%8F%E6%84%9F%E6%98%AF%E5%A6%82%E4%BD%95%E7%82%BC%E6%88%90%E7%9A%84%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>上一篇总结了前端对外沟通输出以及外在幸福感的炼成，这一篇主要是对内在幸福感的总结</p></blockquote><p>内在的幸福感影响因素有很多，总结最主要有以下几类：</p><ul><li>重复业务多，键盘只用ctrl+cv，空有搬砖感，毫无成就感</li><li>搬砖搬得多，稍微来加点挑战性的，逻辑绕不过，就说顶不住</li><li>面对技术的高速迭代，无从下手，茫然失措，最后迷失方向脱离前端坑路</li></ul><p>总结出问题，那就可以很容易找到解决方法了</p><a id="more"></a><h2 id="减少重复工作，提高编码质量"><a href="#减少重复工作，提高编码质量" class="headerlink" title="减少重复工作，提高编码质量"></a>减少重复工作，提高编码质量</h2><p>大家在工作中肯定会经常遇到重复的、或者功能类似的业务，一般的操作估计就是一顿cv，疯狂复制粘贴，完事。但是这种就是单纯的体力活，久而久之，就会觉得枯燥乏味，没新鲜感、成就感，慢慢就会对工作失去热情。</p><p>这种情况，简而言之，在多处地方出现的代码，能被copy来使用的，就要想一下是否可以抽离逻辑，封装复用。而封装一般分为两种情况，<strong>配置</strong>和<strong>组件</strong></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>我们开发某一个端的应用时，经常会有一两种主题色，页面结构会有常用的布局样式，按钮等等也会有常用的样式，对于这些常用的样式，我们可以通过写成统一的css变量和类，放在一个tools文件来实现样式复用，这里采用<code>less</code>预处理器</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// tools.less</span><br><br><span class="hljs-comment">// 主题类</span><br><span class="hljs-variable">@happy-theme:</span> orange;<br><span class="hljs-variable">@sad-theme:</span> gray;<br><span class="hljs-variable">@danger-theme:</span> red;<br><br><span class="hljs-comment">// 布局类</span><br><span class="hljs-selector-class">.flex-align</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.flex-between</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: between;<br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.flex-center</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; test.vue<br><br>&lt;template&gt;<br>&lt;!-- 将div设置成flex居中布局 --&gt;<br>&lt;div class&#x3D;&quot;test-div flex-center&quot;&gt;&lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;style lang&#x3D;&quot;less&quot;&gt;<br>@import &#39;tools.less&#39;;<br>    &#x2F;&#x2F; 将div背景颜色设置成happy主题<br>    .test-div &#123;<br>        background: @happy-theme;<br>    &#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p>可以看到，引入了该工具文件实现样式复用，后续如果需求有更改，需要更换样式主题的，也只需在一个地方更改即可</p><h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><p>通常我们调用后端接口的时候，后端会根据不同情况来返回不同的响应res code，比如<code>0001</code>表示请求成功，正常返回数据，<code>0002</code>表示请求成功，无数据，<code>1000</code>表示请求失败等，显然这里也可以做成配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> CODELIST = [<br>    <span class="hljs-string">&#x27;0001&#x27;</span>: <span class="hljs-string">&#x27;suc&#x27;</span>,<br>    <span class="hljs-string">&#x27;0002&#x27;</span>: <span class="hljs-string">&#x27;no data&#x27;</span>,<br>    <span class="hljs-string">&#x27;1000&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span><br>]<br><br>axios.get(<span class="hljs-string">&#x27;/getData&#x27;</span>, &#123;<span class="hljs-attr">params</span>: &#123;&#125;&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (CODELIST[res.code] === <span class="hljs-string">&#x27;suc&#x27;</span>) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CODELIST[res.code] === <span class="hljs-string">&#x27;no data&#x27;</span>) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>将返回码映射成文件，与不同项目不同团队对接的时候，也只是修改映射表就搞定了~</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>说到组件大家应该也都不陌生了，组件化思想现在更是用得多姿多彩，那么重合的功能业务，我们就可以封装成组件，供不同的页面使用</p><p>比如后台管理端页面，常见的结构就是表单查询+工具栏菜单+表格列表+分页，如果有10个页面（真实情况往往不止），我们是不是要创建10遍重合度90%以上的代码？这个时候要考虑能不能抽离逻辑，做成一个组件，然后往这个组件传参数，来让它实现不同的功能。<a href="https://github.com/Ysom/component-tools/tree/master/easy-page">esay-page组件源码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; parent.vue<br>&lt;template&gt;<br>&lt;easy-page ref&#x3D;&quot;easyPage&quot; :formData&#x3D;&quot;form&quot; :columns&#x3D;&quot;column&quot;<br>               :layout&#x3D;&quot;[&#39;form&#39;, &#39;toolbar&#39;, &#39;table&#39;, &#39;pagination&#39;]&quot; <br>               :getApi&#x3D;&quot;getApi&quot;&gt;<br>    &lt;&#x2F;easy-page&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>        const columns &#x3D; [<br>        &#123;label: &#39;序号&#39;, prop: &#39;index&#39;&#125;,<br>        &#123;label: &#39;姓名&#39;, prop: &#39;name&#39;&#125;<br>        ]<br>        data () &#123;<br>            return &#123;<br>                form: &#123;&#125;,<br>                columns,<br>                getApi: &#39;&#x2F;getData&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>通过这样一个组件，就可以实现简单的表单查询+工具栏+表格+分页，通过参数也可以控制页面结构。</p><p>还有类似上传功能，element-ui等UI库已经帮我们实现了很多，但是业务往往没有那么简单，我们需要基于已经实现的功能去进行二次封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; easy-upload.vue<br>&lt;template&gt;<br>&lt;el-upload&gt;&lt;&#x2F;el-upload&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>        props: &#123;<br>            &#x2F;&#x2F; 二次封装需要的参数<br>        &#125;,<br>        data () &#123;<br>            return &#123;&#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; parent.vue<br>&lt;template&gt;<br>&lt;easy-upload :setting&#x3D;&quot;setting&quot;&gt;&lt;&#x2F;easy-upload&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import EasyUpload from &#39;easy-upload.vue&#39;<br>export default &#123;<br>data () &#123;<br>return &#123;<br>setting: &#123;&#125; &#x2F;&#x2F; 自定义配置<br>&#125;<br>&#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>一次封装，就能在多处进行灵活性更强的使用，而在二次封装的过程中一些逻辑处理，可比搬砖有趣多了</p><h2 id="学习数据结构，拓展思维"><a href="#学习数据结构，拓展思维" class="headerlink" title="学习数据结构，拓展思维"></a>学习数据结构，拓展思维</h2><p>很多前端同事都会在google、百度、知乎等提问，“<strong>前端是否应该学习数据结构</strong>”，“<strong>前端学算法有用吗</strong>”等等问题，我觉得问这种问题，是还没从根本上理解代码存在的意义，每一个开发工程师都是通过代码跟机器打交道的，而数据结构就是数据、代码的一种结构化，是数据组织方法，不学数据结构，不学算法，怎么跟机器进行更深层次的交流？跟机器交流好比跟人沟通，好的语言组织能让我们事半功半，适合的数据结构也能让性能更加优越。</p><p>说到底，我们的业务都是基于各种不同的数据结构来完成的，只不过有一些平时写的逻辑较简单，会忽略了其实也是用到数据结构来实现的，不学数据结构，不学算法，不会知道可以用双端队列来做回文字符串检查，不会知道可以用循环链表来实现小时候爱玩的“击鼓传花”游戏，不会知道撤销、回滚是怎么实现。</p><p>回到总结，数据结构不是学不学的问题，是要往多深学，起码最基本的<code>栈</code>、<code>队列</code>、<code>链表</code>、<code>树</code>、<code>图</code>等都要了解，至于深度，就取决你对自己的要求以及工作中的需求</p><h2 id="阅读源码，提高逻辑"><a href="#阅读源码，提高逻辑" class="headerlink" title="阅读源码，提高逻辑"></a>阅读源码，提高逻辑</h2><p>提高幸福感的另一件事，就是阅读源码了。可能有人会问，啥，阅读源码幸福？不是很痛苦？是的，源码一开始看确实很痛苦，尤其是优秀的项目一般架构比较复杂，想看也不知从何下手，但是我们可以见招拆招，从部分模块看起，比如<code>vue</code>中，可以看双向绑定，可以看响应式设计等等，从某个模块看起，能有效降低源码阅读难度。</p><p>而且一个优秀的框架、库是经过了时间和用户的考验，阅读源码也是我们近距离接触大神的途径，我们可以从源码中看出大神他们的设计思想，思考方法，开发逻辑等等，我们自己创造不了牛逼框架，还学习不了？</p><h2 id="关注行情，了解趋势"><a href="#关注行情，了解趋势" class="headerlink" title="关注行情，了解趋势"></a>关注行情，了解趋势</h2><blockquote><p>当今这个时代，努力奔跑只能保持原地不动，而停滞不前就会逐步落后</p></blockquote><p>前端的发展大家有目共睹，可谓是日新月异，这个时候的我们，只能多多关注技术发展，来扩充自己的眼界，不然别人问起什么是大前端，什么时候是前端微服务，我们都是一脸懵逼，眼界将会决定我们在这条路上能走多远，走多久，如果没有幸福感，没有兴趣支撑我们前进，心越空，越容易被焦虑感填满，我们很容易就会被洪流冲走，心中有方向，前进才不会迷失。</p><h2 id="定时review，做一个“铲屎官”"><a href="#定时review，做一个“铲屎官”" class="headerlink" title="定时review，做一个“铲屎官”"></a>定时review，做一个“铲屎官”</h2><p>最后要讲的一点，不管开发的时候对自己写的代码有多熟悉，都要写上注释，这是为后面自己或者同事review的时候做好前置工作。还有就是要定时对自己的代码做review，或者让朋友、同事帮我们review，因为不管啥时候，我们回过头来看自己的代码，都有一种在看shi的感觉，对吧？而review的过程，就是一个铲屎的过程，手握review铲，哪里有shi铲哪里，老板再也不用担心我巨坑了！一边review一边骂自己当时为啥那么sb，写出这么shi的代码，一边优化提高自己的能力，所以，review可以帮我们更好地认识自己，也能更好地提高自己~</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇从几个方面做了提升内在幸福感的总结，也是这一年多来的心得体会，可能总结不是很到位，会有很多遗漏，但就像上面说的，当我以后回过头来看这篇文章的时候，我是在review，是在优化，我还是在继续提升。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>风一吹不回来</title>
    <link href="/2019/11/07/%E9%A3%8E%E4%B8%80%E5%90%B9%E4%B8%8D%E5%9B%9E%E6%9D%A5/"/>
    <url>/2019/11/07/%E9%A3%8E%E4%B8%80%E5%90%B9%E4%B8%8D%E5%9B%9E%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<p>前几天和一个大学朋友聊起近况，他也是潮汕人，也喜欢喝茶，也喜欢看动漫，我们有很多共同的话题可以聊，当然最后话题还是回到了工作当中，我们感叹工作的压力，感慨毕业后经历的酸甜苦辣，然后不约而同地怀念起那段大学时光：一起上下课，在宿舍一起喝茶，周末还能早起在宿舍楼下打羽毛球。。。</p><p>是的，人总会怀念从前的时光，而被我们怀念的那段时光里的我们，却在忙于感慨其它事情，就像未来的某个时间里，我会怀念和感慨现在。人就是一个矛盾体，经常不懂得珍惜眼前的风景，然后又揣着患得患失的怀念继续走下去。</p><a id="more"></a><p>“听过许多大道理，依旧过不好这一生”，懂得很多道理，但是依旧处于矛盾、迷茫之中，这或许是人的本质，人非圣贤孰能无过，人就是人，人非神，非仙，自然没有完美一说。如果世上存在一个完美的人，那么他应该很孤独，很悲凉吧，处于世而离于世， 眼光所到之处，皆为荒凉，身处世界之巅，而不胜寒。</p><p>还讨论，如果可以回到过去，回到我们怀念的时光， 把每一刻都过到理想中的样子 ，那么我们还会像现在一样去怀念从前吗？显然不会。错过的就是错过，失去的就是失去，因为遗憾，我们才会铭记，当我们每段经历都过得很自然很平淡的时候，我们还会铭刻于心，去怀念吗？</p><p>感想了那么多，最后，我还是愿揣着怀念，珍惜当下，一步一脚印地赏完春夏秋冬。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>响应式原理-2.x版本（下）</title>
    <link href="/2019/10/14/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86-2.x%E7%89%88%E6%9C%AC%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2019/10/14/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86-2.x%E7%89%88%E6%9C%AC%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>上一篇分析了<strong>data</strong>的初始化过程以及做的一些操作，这一篇分析<strong>依赖收集</strong>和<strong>派发更新</strong>。</p><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>先看下<code>getter</code>的代码</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: <span class="hljs-built_in">Object</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  key: string,</span></span><br><span class="hljs-function"><span class="hljs-params">  val: any,</span></span><br><span class="hljs-function"><span class="hljs-params">  customSetter?: ?<span class="hljs-built_in">Function</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  shallow?: boolean</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br><br>  <span class="hljs-keyword">const</span> property = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, key)<br>  <span class="hljs-keyword">if</span> (property &amp;&amp; property.configurable === <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// cater for pre-defined getter/setters</span><br>  <span class="hljs-keyword">const</span> getter = property &amp;&amp; property.get<br>  <span class="hljs-keyword">const</span> setter = property &amp;&amp; property.set<br>  <span class="hljs-keyword">if</span> ((!getter || setter) &amp;&amp; <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key]<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> childOb = !shallow &amp;&amp; observe(val)<br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 重点看get这部分  </span><br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val<br>      <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>        dep.depend()<br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          childOb.dep.depend()<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>            dependArray(value)<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>getter</code>的逻辑里面，关键的两步是<code>const dep = new Dep()</code>和<code>dep.depend()</code>，第一步是实例化一个<code>Dep</code>实例，第二步就是实现依赖收集。</p><p>先看第一步，<code>Dep</code>的实现，代码路径<code>/src/core/observer/dep.js</code></p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> type Watcher <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./watcher&#x27;</span><br><span class="hljs-keyword">import</span> &#123; remove &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span><br><br><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A dep is an observable that can have multiple</span><br><span class="hljs-comment"> * directives subscribing to it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> target: ?Watcher;<br>  id: number;<br>  subs: <span class="hljs-built_in">Array</span>&lt;Watcher&gt;;<br><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">this</span>.id = uid++<br>    <span class="hljs-built_in">this</span>.subs = []<br>  &#125;<br>  <span class="hljs-comment">// 添加观察者</span><br>  addSub (sub: Watcher) &#123;<br>    <span class="hljs-built_in">this</span>.subs.push(sub)<br>  &#125;<br>  <span class="hljs-comment">// 移除观察者</span><br>  removeSub (sub: Watcher) &#123;<br>    remove(<span class="hljs-built_in">this</span>.subs, sub)<br>  &#125;<br>  <span class="hljs-comment">// 依赖收集 存在target时添加观察者对象</span><br>  depend () &#123;<br>    <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>      Dep.target.addDep(<span class="hljs-built_in">this</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 派发更新 省略 下面有用到</span><br>  notify () &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// the current target watcher being evaluated.</span><br><span class="hljs-comment">// this is globally unique because there could be only one</span><br><span class="hljs-comment">// watcher being evaluated at any time.</span><br>Dep.target = <span class="hljs-literal">null</span><br><span class="hljs-keyword">const</span> targetStack = []<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushTarget</span> (<span class="hljs-params">_target: ?Watcher</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (Dep.target) targetStack.push(Dep.target)<br>  Dep.target = _target<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popTarget</span> (<span class="hljs-params"></span>) </span>&#123;<br>  Dep.target = targetStack.pop()<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>Dep</code>是对<code>subs</code>数组的操作，而<code>subs</code>是<code>watcher</code>数组，所以<code>Dep</code>其实是对<code>watchers</code>的管理。</p><p>接着看watcher的逻辑，代码路径<code>/src/core/observer/watcher.js</code></p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A watcher parses an expression, collects dependencies,</span><br><span class="hljs-comment"> * and fires callback when the expression value changes.</span><br><span class="hljs-comment"> * This is used for both the $watch() api and directives.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  deps: <span class="hljs-built_in">Array</span>&lt;Dep&gt;;<br>  newDeps: <span class="hljs-built_in">Array</span>&lt;Dep&gt;;  <br>  <span class="hljs-comment">// 此处省略一堆类型声明, 具体在源码查看</span><br>  <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span><br><span class="hljs-params">    vm: Component,</span><br><span class="hljs-params">    expOrFn: string | <span class="hljs-built_in">Function</span>,</span><br><span class="hljs-params">    cb: <span class="hljs-built_in">Function</span>,</span><br><span class="hljs-params">    options?: ?<span class="hljs-built_in">Object</span>,</span><br><span class="hljs-params">    isRenderWatcher?: boolean</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-built_in">this</span>.vm = vm<br>    <span class="hljs-keyword">if</span> (isRenderWatcher) &#123;<br>      vm._watcher = <span class="hljs-built_in">this</span><br>    &#125;<br>    vm._watchers.push(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-comment">// options</span><br>    <span class="hljs-keyword">if</span> (options) &#123;<br>      <span class="hljs-built_in">this</span>.deep = !!options.deep<br>      <span class="hljs-built_in">this</span>.user = !!options.user<br>      <span class="hljs-built_in">this</span>.computed = !!options.computed<br>      <span class="hljs-built_in">this</span>.sync = !!options.sync<br>      <span class="hljs-built_in">this</span>.before = options.before<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.deep = <span class="hljs-built_in">this</span>.user = <span class="hljs-built_in">this</span>.computed = <span class="hljs-built_in">this</span>.sync = <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-built_in">this</span>.cb = cb<br>    <span class="hljs-built_in">this</span>.id = ++uid <span class="hljs-comment">// uid for batching</span><br>    <span class="hljs-built_in">this</span>.active = <span class="hljs-literal">true</span><br>    <span class="hljs-built_in">this</span>.dirty = <span class="hljs-built_in">this</span>.computed <span class="hljs-comment">// for computed watchers</span><br>    <span class="hljs-built_in">this</span>.deps = []<br>    <span class="hljs-built_in">this</span>.newDeps = []<br>    <span class="hljs-built_in">this</span>.depIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>    <span class="hljs-built_in">this</span>.newDepIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br>    <span class="hljs-built_in">this</span>.expression = process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span><br>      ? expOrFn.toString()<br>      : <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment">// parse expression for getter</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-built_in">this</span>.getter = expOrFn<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.getter = parsePath(expOrFn)<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.getter) &#123;<br>        <span class="hljs-built_in">this</span>.getter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>        process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(<br>          <span class="hljs-string">`Failed watching path: &quot;<span class="hljs-subst">$&#123;expOrFn&#125;</span>&quot; `</span> +<br>          <span class="hljs-string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +<br>          <span class="hljs-string">&#x27;For full control, use a function instead.&#x27;</span>,<br>          vm<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.computed) &#123;<br>      <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>      <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.get()<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="hljs-comment">   */</span><br>  get () &#123;<br>    <span class="hljs-comment">// 入栈 缓存Watcher  </span><br>    pushTarget(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-keyword">let</span> value<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">this</span>.vm<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 触发依赖收集</span><br>      value = <span class="hljs-built_in">this</span>.getter.call(vm, vm)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.user) &#123;<br>        handleError(e, vm, <span class="hljs-string">`getter for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.expression&#125;</span>&quot;`</span>)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> e<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// &quot;touch&quot; every property so they are all tracked as</span><br>      <span class="hljs-comment">// dependencies for deep watching</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.deep) &#123;<br>        <span class="hljs-comment">// 递归对象或数组 触发getter  </span><br>        traverse(value)<br>      &#125;<br>      <span class="hljs-comment">// 出栈 恢复Watcher</span><br>      popTarget()<br>      <span class="hljs-comment">// 清除不需要的依赖 逻辑实现在下面</span><br>      <span class="hljs-built_in">this</span>.cleanupDeps()<br>    &#125;<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Add a dependency to this directive.</span><br><span class="hljs-comment">   */</span><br>  addDep (dep: Dep) &#123;<br>    <span class="hljs-keyword">const</span> id = dep.id<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(id)) &#123;<br>      <span class="hljs-built_in">this</span>.newDepIds.add(id)<br>      <span class="hljs-built_in">this</span>.newDeps.push(dep)<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.depIds.has(id)) &#123;<br>        dep.addSub(<span class="hljs-built_in">this</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Clean up for dependency collection.</span><br><span class="hljs-comment">   */</span><br>  cleanupDeps () &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.deps.length<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-built_in">this</span>.deps[i]<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(dep.id)) &#123;<br>        dep.removeSub(<span class="hljs-built_in">this</span>)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> tmp = <span class="hljs-built_in">this</span>.depIds<br>    <span class="hljs-built_in">this</span>.depIds = <span class="hljs-built_in">this</span>.newDepIds<br>    <span class="hljs-built_in">this</span>.newDepIds = tmp<br>    <span class="hljs-built_in">this</span>.newDepIds.clear()<br>    tmp = <span class="hljs-built_in">this</span>.deps<br>    <span class="hljs-built_in">this</span>.deps = <span class="hljs-built_in">this</span>.newDeps<br>    <span class="hljs-built_in">this</span>.newDeps = tmp<br>    <span class="hljs-built_in">this</span>.newDeps.length = <span class="hljs-number">0</span><br>  &#125;<br>  <span class="hljs-comment">// 后面省略</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看到，实例化一个<code>Watcher</code>时，会执行<code>get</code>函数，通过<code>pushTarget(this)</code>将当前<code>Watcher</code>入栈，然后又执行<code>this.getter.call(vm, vm)</code>，这里的<code>getter</code>对应了<code>updateComponent</code> 函数，这里会执行一句关键代码<code>vm._update(vm._render(), hydrating)</code>，<code>vm._render()</code>会访问<code>vm</code>上面的数据，这里就会触发所有数据的getter，完成依赖收集。</p><p>触发依赖收集之后，根据上面代码里的注释，<code>vue</code>还做了三步操作</p><ol><li>如果存在<code>deep</code>属性，说明存在<strong>深度依赖关系</strong>，采用<strong>递归</strong>进行依赖收集</li><li>执行<code>popTarget()</code>出栈，恢复<code>watcher</code>成上一状态</li><li>完成新订阅，执行<code>cleanupDeps()</code>，清除旧订阅，也就是清除旧依赖</li></ol><h2 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h2><p>看下<code>setter</code>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val<br>    <span class="hljs-comment">/* eslint-disable no-self-compare */</span><br>    <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">/* eslint-enable no-self-compare */</span><br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;<br>        customSetter()<br>    &#125;<br>    <span class="hljs-comment">// #7981: for accessor properties without setter</span><br>    <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> (setter) &#123;<br>        setter.call(obj, newVal)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        val = newVal<br>    &#125;<br>    <span class="hljs-comment">// shallow为false时 将新值设置成响应式对象</span><br>    childOb = !shallow &amp;&amp; observe(newVal)<br>    <span class="hljs-comment">// 通知订阅者</span><br>    dep.notify()<br>&#125;<br></code></pre></td></tr></table></figure><p>值发生变化时，会调用<code>dep</code>的<code>notify</code>方法，看下<code>Dep</code>对<code>notify</code>的定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 派发更新</span><br>notify () &#123;<br>    <span class="hljs-comment">// stabilize the subscriber list first</span><br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-built_in">this</span>.subs.slice()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;<br>        subs[i].update()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了每个<code>watcher</code>的<code>update</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">update () &#123;<br>    <span class="hljs-comment">/* istanbul ignore else */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.lazy) &#123;<br>        <span class="hljs-built_in">this</span>.dirty = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// 同步时执行</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sync) &#123;<br>        <span class="hljs-built_in">this</span>.run()<br>    <span class="hljs-comment">// 推送到观察者队列    </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        queueWatcher(<span class="hljs-built_in">this</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里关注<code>run</code>和<code>queueWatcher</code></p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// run 定义在watcher里面</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Scheduler job interface.</span><br><span class="hljs-comment">   * Will be called by the scheduler.</span><br><span class="hljs-comment">   */</span><br>  run () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.active) &#123;<br>      <span class="hljs-keyword">const</span> value = <span class="hljs-built_in">this</span>.get()<br>      <span class="hljs-keyword">if</span> (<br>        value !== <span class="hljs-built_in">this</span>.value ||<br>        <span class="hljs-comment">// Deep watchers and watchers on Object/Arrays should fire even</span><br>        <span class="hljs-comment">// when the value is the same, because the value may</span><br>        <span class="hljs-comment">// have mutated.</span><br>        isObject(value) ||<br>        <span class="hljs-built_in">this</span>.deep<br>      ) &#123;<br>        <span class="hljs-comment">// set new value</span><br>        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-built_in">this</span>.value<br>        <span class="hljs-built_in">this</span>.value = value<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.user) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.cb.call(<span class="hljs-built_in">this</span>.vm, value, oldValue)<br>          &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            handleError(e, <span class="hljs-built_in">this</span>.vm, <span class="hljs-string">`callback for watcher &quot;<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.expression&#125;</span>&quot;`</span>)<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">this</span>.cb.call(<span class="hljs-built_in">this</span>.vm, value, oldValue)<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>run</code>的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有<code>deep</code>等判断，满足其中之一就进行回调，而在通过<code>this.get()</code>拿值的时候，就会触发执行<code>getter</code>，这也是响应式数据修改时触发渲染的原因。</p><h3 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h3><p>代码路径 <code>src/core/observer/scheduler.js</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> queue: <span class="hljs-built_in">Array</span>&lt;Watcher&gt; = []<br><span class="hljs-keyword">const</span> activatedChildren: <span class="hljs-built_in">Array</span>&lt;Component&gt; = []<br><span class="hljs-keyword">let</span> has: &#123; [key: number]: ?<span class="hljs-literal">true</span> &#125; = &#123;&#125;<br><span class="hljs-keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;<br><span class="hljs-keyword">let</span> waiting = <span class="hljs-literal">false</span><br><span class="hljs-keyword">let</span> flushing = <span class="hljs-literal">false</span><br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push a watcher into the watcher queue.</span><br><span class="hljs-comment"> * Jobs with duplicate IDs will be skipped unless it&#x27;s</span><br><span class="hljs-comment"> * pushed when the queue is being flushed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueWatcher</span> (<span class="hljs-params">watcher: Watcher</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> id = watcher.id<br>  <span class="hljs-comment">// 保证每个watcher只会被添加一次</span><br>  <span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) &#123;<br>    has[id] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">if</span> (!flushing) &#123;<br>      queue.push(watcher)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// if already flushing, splice the watcher based on its id</span><br>      <span class="hljs-comment">// if already past its id, it will be run next immediately.</span><br>      <span class="hljs-keyword">let</span> i = queue.length - <span class="hljs-number">1</span><br>      <span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;<br>        i--<br>      &#125;<br>      queue.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher)<br>    &#125;<br>    <span class="hljs-comment">// queue the flush</span><br>    <span class="hljs-keyword">if</span> (!waiting) &#123;<br>      waiting = <span class="hljs-literal">true</span><br>      <span class="hljs-comment">// 同步</span><br>      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;<br>        flushSchedulerQueue()<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-comment">// 在下一个tick 异步执行flushSchedulerQueue</span><br>      nextTick(flushSchedulerQueue)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>vue</code>在派发更新的时候使用了<strong>队列</strong>，这样做的好处就是每次数据改变时不会马上触发<code>watcher</code>的回调，会先将<code>watcher</code>添加到队列里，然后在<code>nextTick</code>后执行<code>flushSchedulerQueue</code></p><h3 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h3><p>代码路径 <code>src/core/observer/scheduler.js</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Flush both queues and run the watchers.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSchedulerQueue</span> (<span class="hljs-params"></span>) </span>&#123;<br>  currentFlushTimestamp = getNow()<br>  flushing = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">let</span> watcher, id<br><br>  <span class="hljs-comment">// Sort queue before flush.</span><br>  <span class="hljs-comment">// This ensures that:</span><br>  <span class="hljs-comment">// 1. Components are updated from parent to child. (because parent is always</span><br>  <span class="hljs-comment">//    created before the child)</span><br>  <span class="hljs-comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span><br>  <span class="hljs-comment">//    user watchers are created before the render watcher)</span><br>  <span class="hljs-comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span><br>  <span class="hljs-comment">//    its watchers can be skipped.</span><br>  <span class="hljs-comment">// 队列排序 原因如上注释</span><br>  queue.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.id - b.id)<br><br>  <span class="hljs-comment">// do not cache length because more watchers might be pushed</span><br>  <span class="hljs-comment">// as we run existing watchers</span><br>  <span class="hljs-comment">// 队列遍历  </span><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.length; index++) &#123;<br>    watcher = queue[index]<br>    <span class="hljs-keyword">if</span> (watcher.before) &#123;<br>      watcher.before()<br>    &#125;<br>    id = watcher.id<br>    has[id] = <span class="hljs-literal">null</span><br>    watcher.run()<br>    <span class="hljs-comment">// in dev build, check and stop circular updates.</span><br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; has[id] != <span class="hljs-literal">null</span>) &#123;<br>      circular[id] = (circular[id] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>      <span class="hljs-keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;<br>        warn(<br>          <span class="hljs-string">&#x27;You may have an infinite update loop &#x27;</span> + (<br>            watcher.user<br>              ? <span class="hljs-string">`in watcher with expression &quot;<span class="hljs-subst">$&#123;watcher.expression&#125;</span>&quot;`</span><br>              : <span class="hljs-string">`in a component render function.`</span><br>          ),<br>          watcher.vm<br>        )<br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// keep copies of post queues before resetting state</span><br>  <span class="hljs-keyword">const</span> activatedQueue = activatedChildren.slice()<br>  <span class="hljs-keyword">const</span> updatedQueue = queue.slice()<br><br>  resetSchedulerState()<br><br>  <span class="hljs-comment">// call component updated and activated hooks</span><br>  callActivatedHooks(activatedQueue)<br>  callUpdatedHooks(updatedQueue)<br><br>  <span class="hljs-comment">// devtool hook</span><br>  <span class="hljs-comment">/* istanbul ignore if */</span><br>  <span class="hljs-keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;<br>    devtools.emit(<span class="hljs-string">&#x27;flush&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>flushSchedulerQueue</code>在这里做了两件事，<strong>队列排序</strong>和<strong>队列遍历</strong>。</p><p>队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。</p><p>然后对排序后的队列进行遍历，拿到<code>watcher</code>执行<code>run</code>方法，<code>run</code>已在上面分析。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了<code>proxy</code>来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>响应式原理-vue2.x版（上）</title>
    <link href="/2019/10/11/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86-2.x%E7%89%88%E6%9C%AC%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2019/10/11/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86-2.x%E7%89%88%E6%9C%AC%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用<strong>ES5</strong>的<code>Object.defineProperty</code>，而新版本3.0则是使用<strong>ES6</strong>的<code>proxy</code></p></blockquote><h2 id="2-x实现原理"><a href="#2-x实现原理" class="headerlink" title="2.x实现原理"></a>2.x实现原理</h2><p>在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理：</p><ol><li><p>将一个对象作为data选项（组件是data函数返回对象）</p></li><li><p>遍历data里面所有的属性，通过<code>Object.defineProperty</code>将属性转为<strong>getter/setter</strong></p></li><li><p>每个组件都有一个<code>watcher</code>，它用来记录接触过的属性，并将其收集为依赖，当依赖的<strong>setter</strong>变更时，通知<code>watcher</code>，使与其有关联的组件更新</p></li><li><p>异步更新</p></li></ol><h2 id="初始化data"><a href="#初始化data" class="headerlink" title="初始化data"></a>初始化data</h2><p>首先对<strong>data</strong>进行初始化<code>initData</code>，代码路径<code>/src/core/instance/state.js</code></p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initData</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> data = vm.$options.data<br>  data = vm._data = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span><br>    ? getData(data, vm)<br>    : data || &#123;&#125;<br>  <span class="hljs-keyword">if</span> (!isPlainObject(data)) &#123;<br>    data = &#123;&#125;<br>    process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(<br>      <span class="hljs-string">&#x27;data functions should return an object:\n&#x27;</span> +<br>      <span class="hljs-string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,<br>      vm<br>    )<br>  &#125;<br>  <span class="hljs-comment">// proxy data on instance</span><br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(data)<br>  <span class="hljs-keyword">const</span> props = vm.$options.props<br>  <span class="hljs-keyword">const</span> methods = vm.$options.methods<br>  <span class="hljs-keyword">let</span> i = keys.length<br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;<br>        warn(<br>          <span class="hljs-string">`Method &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,<br>          vm<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;<br>      process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; warn(<br>        <span class="hljs-string">`The data property &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +<br>        <span class="hljs-string">`Use prop default value instead.`</span>,<br>        vm<br>      )<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved(key)) &#123;<br>      proxy(vm, <span class="hljs-string">`_data`</span>, key)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// observe data</span><br>  observe(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>data的初始化主要做两件事：</p><ol><li>对data的所有属性遍历，先检查属性是否已定义为<strong>method</strong>或<strong>prop</strong>，否则通过一个<strong>proxy函数</strong>（不是ES6的proxy），把<code>vm._data.xxx</code>代理到<code>vm.xxx</code></li><li>调用<strong>observe</strong>实现对data的监测，把data变成响应式</li></ol><p>下面先看自定义的代理函数proxy</p><h3 id="代理函数proxy"><a href="#代理函数proxy" class="headerlink" title="代理函数proxy"></a>代理函数proxy</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sharedPropertyDefinition = &#123;<br>  enumerable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">true</span>,<br>  get: noop,<br>  set: noop<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxy</span> (<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, sourceKey: string, key: string</span>) </span>&#123;<br>  sharedPropertyDefinition.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[sourceKey][key]<br>  &#125;<br>  sharedPropertyDefinition.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span> (<span class="hljs-params">val</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>[sourceKey][key] = val<br>  &#125;<br>  <span class="hljs-built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>proxy函数的作用是通过<code>Object.defineProperty</code>，将<code>target[sourceKey][key]</code>的读写变成<code>target[key]</code>的读写。而<code>vm._prop.xxx</code>、<code>vm._data.xxx</code>可以访问到<code>props</code>、<code>data</code>里面的属性，因此通过proxy函数之后，<code>vm._prop.xxx</code>、<code>vm._data.xxx</code>就变成<code>vm.xxx</code>的读写了，这也是为什么props的属性和data的属性一样，可以通过<code>vm.xxx</code>来访问。</p><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p><strong>observe</strong>的作用是监测数据的变化，代码路径<code>/src/core/observer/index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Attempt to create an observer instance for a value,</span><br><span class="hljs-comment"> * returns the new observer if successfully observed,</span><br><span class="hljs-comment"> * or the existing observer if the value already has one.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value: any, asRootData: ?boolean</span>): <span class="hljs-title">Observer</span> | <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> ob: Observer | <span class="hljs-keyword">void</span><br>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;<br>    ob = value.__ob__<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>    shouldObserve &amp;&amp;<br>    !isServerRendering() &amp;&amp;<br>    (<span class="hljs-built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;<br>    <span class="hljs-built_in">Object</span>.isExtensible(value) &amp;&amp;<br>    !value._isVue<br>  ) &#123;<br>    ob = <span class="hljs-keyword">new</span> Observer(value)<br>  &#125;<br>  <span class="hljs-keyword">if</span> (asRootData &amp;&amp; ob) &#123;<br>    ob.vmCount++<br>  &#125;<br>  <span class="hljs-keyword">return</span> ob<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>代码路径<code>/src/core/observer/index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Observer class that is attached to each observed</span><br><span class="hljs-comment"> * object. Once attached, the observer converts the target</span><br><span class="hljs-comment"> * object&#x27;s property keys into getter/setters that</span><br><span class="hljs-comment"> * collect dependencies and dispatch updates.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  value: any;<br>  dep: Dep;<br>  vmCount: number; <span class="hljs-comment">// number of vms that have this object as root $data</span><br><br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">value: any</span>) &#123;<br>    <span class="hljs-built_in">this</span>.value = value<br>    <span class="hljs-comment">// 实例化Dep对象</span><br>    <span class="hljs-built_in">this</span>.dep = <span class="hljs-keyword">new</span> Dep()<br>    <span class="hljs-built_in">this</span>.vmCount = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 将自身属性添加到value对象的__ob__属性  </span><br>    def(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-built_in">this</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>      <span class="hljs-keyword">if</span> (hasProto) &#123;<br>        protoAugment(value, arrayMethods)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        copyAugment(value, arrayMethods, arrayKeys)<br>      &#125;<br>      <span class="hljs-built_in">this</span>.observeArray(value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.walk(value)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Walk through all properties and convert them into</span><br><span class="hljs-comment">   * getter/setters. This method should only be called when</span><br><span class="hljs-comment">   * value type is Object.</span><br><span class="hljs-comment">   */</span><br>  walk (obj: <span class="hljs-built_in">Object</span>) &#123;<br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>      defineReactive(obj, keys[i])<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Observe a list of Array items.</span><br><span class="hljs-comment">   */</span><br>  observeArray (items: <span class="hljs-built_in">Array</span>&lt;any&gt;) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123;<br>      observe(items[i])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<strong>Observer</strong>的构造函数里，先实例化一个<code>Dep</code>对象，用<code>def</code>函数（defineProperty的迷你版），将自身实例添加到value对象的<code>__ob__</code>属性，接下来判断value是数组还是对象，如果是数组，则调用<code>observeArray</code>，如果是对象，则调用<code>walk</code>函数。</p><p>接下来看一下<code>defineReactive</code>这个函数，代码路径<code>/src/core/observer/index.js</code></p><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Define a reactive property on an Object.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: <span class="hljs-built_in">Object</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  key: string,</span></span><br><span class="hljs-function"><span class="hljs-params">  val: any,</span></span><br><span class="hljs-function"><span class="hljs-params">  customSetter?: ?<span class="hljs-built_in">Function</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  shallow?: boolean</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 实例化Dep对象</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br>  <span class="hljs-comment">// 获取对象属性描述符</span><br>  <span class="hljs-keyword">const</span> property = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, key)<br>  <span class="hljs-keyword">if</span> (property &amp;&amp; property.configurable === <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// cater for pre-defined getter/setters</span><br>  <span class="hljs-keyword">const</span> getter = property &amp;&amp; property.get<br>  <span class="hljs-keyword">const</span> setter = property &amp;&amp; property.set<br>  <span class="hljs-keyword">if</span> ((!getter || setter) &amp;&amp; <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key]<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> childOb = !shallow &amp;&amp; observe(val)<br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val<br>      <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>        dep.depend()<br>        <span class="hljs-keyword">if</span> (childOb) &#123;<br>          childOb.dep.depend()<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>            dependArray(value)<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;<br>      <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val<br>      <span class="hljs-comment">/* eslint-disable no-self-compare */</span><br>      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-comment">/* eslint-enable no-self-compare */</span><br>      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;<br>        customSetter()<br>      &#125;<br>      <span class="hljs-comment">// #7981: for accessor properties without setter</span><br>      <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (setter) &#123;<br>        setter.call(obj, newVal)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        val = newVal<br>      &#125;<br>      childOb = !shallow &amp;&amp; observe(newVal)<br>      dep.notify()<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码可以看到，<strong>defineReactive</strong>先实例化一个<code>Dep</code>对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用<code>observe</code>方法，确保每个属性都能被监测到，最后通过<code>defineProperty</code>给属性加上用于<strong>收集依赖</strong>的<code>getter</code>和<strong>派发更新</strong>的<code>setter</code>。</p><p>到了这里，<strong>data</strong>的初始化已经完成，后面接着对<strong>收集依赖</strong>和<strong>派发更新</strong>做分析。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3.0，它来了，它带着Pre-Alpha来了</title>
    <link href="/2019/10/07/Vue3.0%E5%AE%83%E6%9D%A5%E4%BA%86%EF%BC%8C%E5%B8%A6%E7%9D%80Pre-Alpha%E6%9D%A5%E4%BA%86/"/>
    <url>/2019/10/07/Vue3.0%E5%AE%83%E6%9D%A5%E4%BA%86%EF%BC%8C%E5%B8%A6%E7%9D%80Pre-Alpha%E6%9D%A5%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>10月5号凌晨，尤雨溪大大发布了<a href="https://github.com/vuejs/vue-next">vue3.0源码</a></p></blockquote><p><img src="/images/sina_yyx.jpg" alt="尤雨溪sina微博"></p><p>现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西</p><h3 id="整体状态"><a href="#整体状态" class="headerlink" title="整体状态"></a>整体状态</h3><ul><li>目前发布的vue3.0是<code>Pre-Alpha</code>版本，后续还有<code>Alpha</code>、<code>Beta</code>版本</li><li>打包后的代码是ES2015+，不支持IE11</li><li>拥抱TypeScript，98%代码使用了TypeScript编写</li></ul><a id="more"></a><h3 id="代码目录"><a href="#代码目录" class="headerlink" title="代码目录"></a>代码目录</h3><p><img src="/images/vue-next-code-tree.png" alt="目录树结构"></p><p>由上图看到（安装了<code>Octotree</code>插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个<code>packages</code>目录，里面包含了vue3.0主要实现的功能：</p><ul><li><strong>compiler-core</strong>：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件</li><li><strong>compiler-dom</strong>：针对浏览器而写的编译器</li><li><strong>reactivity</strong>：数据响应式系统。一个单独的系统，可以与任何框架配合使用</li><li><strong>runtime-core</strong>：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API</li><li><strong>runtime-dom</strong>： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等</li><li><strong>runtime-test</strong>：一个专门为了测试而写的轻量级 runtime</li><li><strong>server-renderer</strong>：用于 SSR（还未实现）</li><li><strong>shared</strong>：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法</li><li><strong>template-explorer</strong>：用于模板编译输出</li><li><strong>vue</strong>： 用于构建「完整构建」版本</li></ul><p>由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端幸福感是如何炼成的（上）</title>
    <link href="/2019/10/04/%E5%89%8D%E7%AB%AF%E5%B9%B8%E7%A6%8F%E6%84%9F%E6%98%AF%E5%A6%82%E4%BD%95%E7%82%BC%E6%88%90%E7%9A%84%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2019/10/04/%E5%89%8D%E7%AB%AF%E5%B9%B8%E7%A6%8F%E6%84%9F%E6%98%AF%E5%A6%82%E4%BD%95%E7%82%BC%E6%88%90%E7%9A%84%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？</p></blockquote><p>近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成<strong>外在因素</strong>和<strong>内在因素（技巧、技术提升）</strong>两方面，这里分享<strong>外在因素</strong>。</p><h3 id="重要的几个点"><a href="#重要的几个点" class="headerlink" title="重要的几个点"></a>重要的几个点</h3><a id="more"></a><p>在说外在因素之前，先看以下一些点：</p><ul><li>熟知业务，熟悉产品原型</li><li>积极参加项目评审</li><li>技术评估，了解技术实现的细节，确定技术边界</li><li>全局视野，业务、技术拓展性</li></ul><p>不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？</p><h3 id="于产品而言"><a href="#于产品而言" class="headerlink" title="于产品而言"></a>于产品而言</h3><blockquote><p>熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。</p></blockquote><p>很多时候技术跟产品的撕x，都是因为沟通不顺畅。</p><p>我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。</p><p>前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。</p><h3 id="于后端而言"><a href="#于后端而言" class="headerlink" title="于后端而言"></a>于后端而言</h3><p>前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？</p><ul><li>发现潜在的坑与隐藏的业务，及时让后端同学补充接口</li><li>制定接口文档规范，提高对接效率</li><li>接口提供时间节点（很重要！防止接口拖延！）</li><li>数据模拟，提前对接</li></ul><p>这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过<code>yApi</code>、<code>mock</code>、<code>easy-mock</code>等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。</p><h3 id="于测试而言"><a href="#于测试而言" class="headerlink" title="于测试而言"></a>于测试而言</h3><p>当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？<strong>主动提供复杂的交互测试指引</strong>。</p><p>很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回归初心，重新出发</title>
    <link href="/2019/09/24/%E5%9B%9E%E5%BD%92%E5%88%9D%E5%BF%83%EF%BC%8C%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/"/>
    <url>/2019/09/24/%E5%9B%9E%E5%BD%92%E5%88%9D%E5%BF%83%EF%BC%8C%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>很长时间没有写博客，之前有基于<strong>hexo</strong>+<strong>NextT</strong>搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。</p><p>现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。</p><a id="more"></a><p>现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。</p><p>现在重新基于<del><strong>hexo</strong>+<strong>icarus</strong></del>（2020/12/13切换新主题**<a href="https://hexo.fluid-dev.com/">fluid</a>**）来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
