{"pages":[{"title":"关于我","text":"95的骚年一枚，有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门 喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前安静，用Eason的歌词来形容，大概就是外向的孤独患者？ 地地道道的超爱喝茶的潮汕小伙子，一天能喝三四泡茶，特喜欢家乡的凤凰茶！那种独属家乡的味道，一杯就能融进生活，趟进心里~","link":"/about/index.html"}],"posts":[{"title":"2020快到了，面对复盘的疾风吧！！！","text":"还有20来天就是2020年了，今年的你技术有提升吗？体重下降了多少？19年末的你是不是19年初想象中的你呢？ 对于我来说，“每逢佳节倍思亲，每到年底必操心”，最近本来想趁着年底，做一波基础技术复盘，优先选了js进行复盘，结果越复知识点越多，想整理成一篇博文篇幅又太长，想整成什么js知识点复盘上中下又太繁琐麻烦的样子，太难了，难于上青天啊~ 但是青天可以不上，复盘清单还是要列的，做一些知识点的复盘总结，计划尽量月底完成（maybe吧，哈哈哈~） 第一个要复盘的，肯定是前端三剑客了 HTML CSS JavaScript 接下来就是工作中的技术栈和部分学习内容了 Vue（双向绑定、响应式原理、组件设计、组件通信等） Vuex+Vue-Router等Vue全家桶 微信小程序 计算机网络（TCP、HTTP、HTTP2、HTTP3等） 数据结构（这一块处于学习阶段，列出来鞭策自己） NodeJS（这一块处于学习阶段，列出来鞭策自己） OMG，果然是“每到年底必操心”，大脑随便飘过的东西就已经这么多了，还有部分没有整理出来的比如webpack、typescript、web安全、性能优化等等，这也反映出，现在的weber需要掌握的知识点多、知识面广，并且广且深也是一个要求趋势了~ 最后，暂且就给自己定这样的复盘小目标吧！后面能想到啥重要的，再补充~","link":"/2019/12/09/2020快到了，面对复盘的疾风吧！！！/"},{"title":"ES6 -- Module","text":"前言讲到模块化，大家可能对CommonJs、AMD、CMD等规范都比较熟悉，ES6也有Module的规范。本文是对Module理解的整理。那依然先是问题三连：ES6的Module是什么？用来解决什么问题？优点是什么？ 是什么？使用不同方式加载的JS文件，与原先脚本（script）加载方式相对。模块的真正力量在于按需导出和导入，而不在于将所有内容放在同一个文件 解决什么问题（切入点） 命名冲突（作用域） 让JS应用变得更加有条理 安全问题 优点是什么 自动运行在严格模式下，且无法跳出严格模式； 在模块的顶级作用域创建的变量，不会自动添加到共享的全局作用域，只存在于模块顶级作用域的内部； 模块顶级作用域的this为undefined； 模块中不允许HTML风格的注释，该问题是早期浏览器历史遗留特性； 要提供给外部访问的代码，模块必须导出它们； 模块可以由别的模块导入绑定。 基本导出export我们可以在任意变量、函数、类声明之前加上export导出它们，没有被显式导出的将会在模块中保持私有 1234567891011121314151617// module.jsexport let name = 'Ysom'export function sum (num1, num2) { return num1 + num2}export class Person { constrcutor (name, sex) { this.name = name this.sex = sex }}function sayHello () { console.log('hello world')}// 导出引用export { sayHello } 基本导入import可以通过import来导入被导出的模块，import语句由两部分组成，被导入的标识符和导入标识符的来源：import { identifier1, identifier2 } from './module1.js' 123456// 导入单个绑定import { sum } from './module.js'// 导入多个绑定import { sum, sayHello } from './module.js'// 完全导入一个模块 module所有的导出绑定在example 属于命名空间导入(namespace import)import * as example from './module.js' 需要注意的一点：无论使用多少次import引入模块，该模块只会执行一次。在导出的模块执行之后，已被实例化的模块会保留在内存中，随时可被其它import使用。同应用的其它模块，如使用import引入该模块，使用的也是同一个实例模块 123import { sum } from './module.js'import { sayHello } from './module.js'// 在这里modules.js只会执行一次，之后保留在内存中 import和export有一个限制：无法在其它语句或表达式的内部使用，即必须在顶部作用域 12345678if (true) { // error import xx from './xxx'}if (true) { // error export xx} 题外话：在已完成的ES2020的提案中，有了新特性动态导入dynamic-import，可根据条件判断支持按需导入 默认导入-模块的默认值我们可以通过default为每一个模块设置一个且只能一个默认值 1234567// 普通导出export let name = 'export'// 1 默认导出可以不用给声明加上名称 因为代表整个模块导出export default function (num1, num2) {}// 2 也可先声明 再导出function sum (num1, num2) {}export default sum 123456789// 导入模块默认值 默认值无需加上花括号{}import sum from './module.js'sum(1, 11)// 导入默认值及其它导出功能 默认名称需在位于非默认名称之前import sum, { name } from './module.js'console.log(name) // exportsum(1, 11)// 重命名import { default as sum, name } from './module.js' 绑定导入，再导出有时候我们会需要将导入的部分功能，再导出去作为另一个模块，比如作为库，这时候可以这样操作 12345678// new-module.js// 1 先导入 再导出import { identifier1, identifier2 } from './m1.js'export { identifier1, identifier2 }// 2 会进入模块查看sum, sayHello的定义，并导出export { sum, sayHello } from './module.js'// 3 完全导出export * from './module.js' 完全导出需要注意一个问题，如果目标模块module包含了默认值，那么就无法在当前模块new-module再定义一个默认导出，始终遵守一个模块只能有一个默认导出的原则 无绑定的导入有时候我们会对全局作用域对象进行一些附加操作，虽然模块中的代码不会自动共享到全局，但是我们还是可以在模块中对一些JS内置对象如Array、Object等进行访问，并且对这些对象的修改，可以反映到其它模块中 123456789// extendArray.js// 给数组添加一个pushAll的方法Array.prototype.pushAll = function (items) { // 判断items是否为数组 if (!Array.isArray(items)) { throw TypeError(`arguments must be an array`) } return this.push(...items)} 再通过import './extendArray.js'将模块引入，这里虽然没有绑定的导出与导入，但依然是一个有效的模块，在引入该模块的模块中，所有的数组都可以使用pushAll()方法 这种无绑定的导入，最有可能创建用于在旧环境运行新语法时做向下兼容的polyfill和shim 加载方式 ES6定义了模块的语法，但未定义如何加载。 在web浏览器中使用模块在ES6之前，已经存在多种方式可以在web应用中加载JS 使用&lt;script&gt;标签以及src属性指定加载的位置，加载JS文件； 使用&lt;script&gt;标签但不使用src属性，嵌入内联的JS代码； 加载JS代码文件并作为Worker（例如Web Worker或Service Worker）来执行 通过script加载模块在使用script标签时，设置type属性为module，告诉浏览器将引入的代码作为模块。且会自动应用defer属性，将模块文件下载完后，等待网页文档全部解析完，再按照模块引入顺序依次执行。如果需要异步加载模块，则可以手动加上async属性 将模块作为Worker加载为了支持模块加载，HTML标准的开发者给worker添加了第二个参数，该参数时带有type属性的对象，默认值为script，可以设置为module，以此来加载模块 12345// 脚本方式let worker = new Worker('script.js')// 模块方式let worker = new Worker('module.js') 模块方式其中存在两点区别： worker脚本被限制只能从同源网页加载，worker模块不受限制； worker脚本可以使用self.importScripts()方法来将额外脚本引入worker，worker模块上的self.importScripts()总是失败，因为应当换用成import","link":"/2020/01/20/Module/"},{"title":"JavaScript整理总结(持续更新)","text":"数据类型、存储方式 原始（基本）类型，变量存储的是在栈内存的值string、number、boolean、undefined、null、symbol、（以及提案新增的BigInt） 引用（复杂）类型，变量存储的是在栈内存中的指针（地址），指向存储的地址，地址所在的堆内存存放着值。引用类型都是object typeof和instanceof typeof 原始类型：除了null判断为object，其它的原始类型可以正确判断 对象类型：除了函数判断为function，其它的对象类型都为object instanceof判断操作符右边的函数的原型是否存在于左边的对象的原型链上可以准确判断引用类型，无法正确判断原始类型 正确判断变量类型的方式 Object.prototype.toString.apply(target) // '[object xxx]'获取索引的第八位到最后一位 先通过typeof判断是否为复杂类型，是则使用instanceof判断 12345678910data &amp;&amp; (typeof(data) === 'object' || typeof(data) === 'function')class PrimitiveUndefined { static [Symbol.hasInstance](data) { return typeof data === 'undefined'; }}data instanceof PrimitiveUndefined// 其它基本类型... ==、=== ==符号只判断两个变量的值是否相等，===判断两个变量的类型和值 ==判断过程中，若两变量的类型不同，则会涉及到变量类型转换 类型转换在JS中，类型转换只有三种情况 转换为布尔值 转换为数字 转换为字符串 下面图为转换规则 var、let、const var声明的变量会被提升到作用域顶部，声明了全局变量则会挂载在window上面 let跟const声明的变量存在暂时性死区，因此在变量声明前调用会报错 const声明的变量是常量，为基础类型时值不能改变，复杂类型时地址不能改变 变量提升 变量还没有被声明，但是可以被使用（值为undefined），提升的是声明（var声明） 函数也会被提升到作用域顶部，因此函数可以在声明之前调用，且函数提升优先于变量提升 this指向 指向全局对象window 指向调用方法的对象 指向new操作符赋值后的对象 箭头函数没有this，也无法使用bind，this指向包裹该箭头函数的第一个普通函数 函数绑定多层bind的情况，由第一个bind决定 1fn.bind().bind(a)() 多个规则下this指向优先级：new &gt; bind &gt; obj.fn &gt; fn apply、call、bindapplycallbind闭包闭包是什么 闭包是函数和声明该函数的词法环境的组合 –MDN 我的理解是，函数+该函数体可以访问的变量总和；函数不一定是在另一个函数里面声明，它也可以在外部声明，在另一个函数内部重新赋值 闭包的作用闭包的最多用途还是在于隐藏变量，常用于实现私有变量 深、浅拷贝 深、浅拷贝的区别就是拷贝的值存在引用类型时，浅拷贝会把地址复制，而深拷贝不会 浅拷贝Object.assign()...扩展运算符深拷贝JSON.parse(JSON.stringify(obj))局限性： 不能序列化undefined、函数和symbol，会忽略 存在对象循环引用时，会报错 MessageChannel当有内置类型，且不包含函数时使用 1234567function MesCalDeepClone (obj) { return new Promise((resolve) =&gt; { let {port1, port2} = new MessageChannel() port2.onmessage = (ev) =&gt; resolve(ev.data) port1.postMessage(obj) })} 原型原型__proto__是一个对象，里面预设了一些函数和属性，包括了构造函数constructor；而构造函数拥有prototype属性，指回了原型对象，通过构造函数生成的实例对象，会自动将构造函数的原型设置为实例对象的原型。 原型链对象拥有原型对象，而原型对象也会拥有自己的原型，依次类推形成一条原型链，直到原型对象为null时结束即Object.prototype.__proto__ 继承 在新的对象上复用现有对象的属性和方法，有助于避免重复代码和重复数据。 原型继承将函数A的原型赋值为函数B的实例，函数B的实例具有函数的全部属性以及指向超类的原型，以此实现原型继承。 这里借用《js忍者秘籍》第二版里面的一个例子 12345function Person () {}Person.prototype.dance = function () {}function Ninja () {}// Ninja的原型赋值为Person的实例Ninja.prototype = new Person() 这里有一个要注意的地方，当把Ninja的原型设置为Person的实例对象之后，Ninja和它原来的原型失去了联系，现有的原型的构造函数constructor也是指向Person而不是指向Ninja，所以需要做一步操作，重新建立起Ninja实例与Ninja的联系 12345Object.definedProperty(Ninja.prototype, 'constructor', { enumerable: false, // 不可枚举 value: Ninja, // 值为Ninja writable: true}) classclass的出现是为了解决什么问题？为了让其它面向对象语言开发者适应和熟悉，ES6增加了关键字class来模拟类，class是语法糖，它的底层实现原理还是原型继承，使用extends也可以更优雅地继承 new操作符的过程 创建一个空对象 将该空对象作为上下文this传入构造函数 对该对象进行一系列初始化 返回该对象或函数指定的其它对象（非对象会忽略） 事件循环事件循环中包含着几个比较重要的概念： 任务：宏任务、微任务 事件队列：宏任务队列、微任务队列 用setTimeout延迟执行事件、setInterval间隔执行事件 setTimeout：延迟设定的时间执行，实际延迟时间大于等于设定的时间 setInterval：间隔设定的时间执行，实际执行次数并不等于时间内间隔时间次数；当宏任务队列里面已经存在等待执行的该间隔任务，则不会再将该间隔任务添加进宏任务队列 事件捕获、冒泡 捕获：事件自顶向下传递，从顶部元素到目标元素 冒泡：事件自底向上传递，从目标元素到顶部元素若没指定捕获模式，则事件默认为冒泡模式 事件处理器中的this和event.target的区别 this指向注册事件处理器的元素 event.target指向事件发生的元素 自定义事件通过内置的CustomEvent构造函数和dispatchEvent方法实现自定义事件的创建和分发； 自定义事件的优势是代码解耦，可以编写共享代码，且更易于维护、调试 123456789101112131415&lt;script&gt; /* * @params * target绑定事件的对象名称 eventName事件名称 eventDetail事件参数 */ function triggerEvent (target, eventName, eventDetail) { let event = new CustomEvent(eventName, { detail: eventDetail }) // 向指定元素派发事件 target.dispatchEvent(event) } // 给document绑定myEvent事件 triggerEvent(document, 'myEvent', {customName: 'my-event'})&lt;/script&gt;","link":"/2019/12/14/JavaScript整理总结(持续更新)/"},{"title":"《程序员修炼之道》--务实的哲学","text":"《程修道》第一章讲的是务实的哲学，内容的安排觉得很巧妙，不像传统的书籍那样，上来直接跟你说某个概念，而是通过“哲学”一词来表达“务实”本身所具有的高度以及“务实”是给我们带来的是思想和心理层面的改变和进化的，也让读者对务实有更多的兴趣和探索欲。 这一章由7部分组成，分别是“人生是你的”、“我的源码被猫吃了”，“软件的熵”，“石头做的汤和煮熟的青蛙”，“够好即可的软件”，“知识组合”和“交流”。 这里挑感触比较多的部分做记录。 我的源码被猫吃了看到这个标题的时候是不是觉得很搞笑，猫竟然能吃源码？？？ 现实中猫肯定是没法把源码吃掉的，这个比喻说的是，当下很多找借口、甩锅、不敢担当的现象。 承担责任。不管在工作中还是生活中，我们都需要承担责任，责任意味着我们对某事积极认同，当我们决定对一个结果承担责任时，意味着我们将承接相关的义务，当我们在这期间犯了错，做了错误的决定，写了一个潜藏的BUG导致线上事故，我们都要诚实地去承担，并且尝试给出选择，给出解决方案。 提供选择，别找借口。我们很多人经常在出现错误的时候找各种各样的借口来搪塞老板、领导或者同事，想以此来减轻自己犯错后应承担的后果：为什么项目会延期，为什么线上会出现大BUG。如果想找借口，最好是在心里把跟领导的对话过一遍，看看你给出的借口有没有说服力，如果没有，还是老老实实地考虑“有没有试过这样的方案，或者另外的方案”，在找借口前，还有没有其它解决方案可以试试的？我觉得最基本的处理方式，应该是承担责任，说出原因，然后提供解决方案给领导选择，而不是把问题抛给领导。 更好地改进。如果真的出现问题，我们最终目的还是要解决问题。是一段老代码引起的坑？那么是不是要进行优化或者重构，跟领导讲一下重构的价值；如果是业务不熟悉造成的，我们是不是应该花多一些时间去了解业务，了解原型；为了防止错误的再次发生，我们可不可以引入更好的测试或者增加一些自动化流程；等等这些，都是一些改进的方案。","link":"/2020/05/09/《程序员修炼之道》--务实的哲学/"},{"title":"Vue3.0，它来了","text":"10月5号凌晨，尤雨溪大大发布了vue3.0源码 现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西 整体状态 目前发布的vue3.0是Pre-Alpha版本，后续还有Alpha、Beta版本 打包后的代码是ES2015+，不支持IE11 拥抱TypeScript，98%代码使用了TypeScript编写 代码目录 由上图看到（安装了Octotree插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个packages目录，里面包含了vue3.0主要实现的功能： compiler-core：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件 compiler-dom：针对浏览器而写的编译器 reactivity：数据响应式系统。一个单独的系统，可以与任何框架配合使用 runtime-core：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API runtime-dom： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等 runtime-test：一个专门为了测试而写的轻量级 runtime server-renderer：用于 SSR（还未实现） shared：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法 template-explorer：用于模板编译输出 vue： 用于构建「完整构建」版本 由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。","link":"/2019/10/07/Vue3.0它来了，带着Pre-Alpha来了/"},{"title":"振奋人心的ES2020新特性！","text":"ES2020已完成的提案中，有了比较振奋人心的新特性。下面来看看几个比较有意思的特性 BigInt在JS的Number类型中，安全值的范围为Number.MIN_SAFE_INTEGER-Number.MAX_SAFE_INTEGER，即-(253-1)~253-1，超出该范围整数计算或表示将会丢失精度 123let max_num = Number.MAX_SAFE_INTEGER // 9007199254740991let more_num = max_num + 1 // 9007199254740992let more_max_num = max_num + 2 // 9007199254740992 可以看到，当数值超过安全范围时，就不会正确表示，甚至还有以下情况 19007199254740992 === 9007199254740993 // true 新规范BigInt就是用来解决大数计算问题，同时它也属于原始类型。可以在整数后面加上n或者BigInt函数来实现 123456789101112// 直接在整数后面加nlet bigNum = 9007199254740993n// 使用BigInt函数let bigNum = BigInt(9007199254740993)// or let bigNum = BigInt('9007199254740993')// 大数运算let superNum = 9007199254740993n + 9007199254740993n // 18014398509481986ntypeof superNum // 'bigInt' 需要注意的是，使用BigInt函数实例化大数时，会将参数进行Number类型的实例化，超出安全范围的数字可能会引起精度丢失 Promise.allSettled用过Promise.all的都知道，这方法有一个比较明显的缺陷，只要其中一个Promise被reject，整个Promise.all就会挂掉，剩下的Promise都会停止执行。例如在一个用户模块中，通过并发异步请求多个版块的数据，只要其中一个服务挂了，其它的版块也就不会拿到数据。很明显，这并不是我们想要的，我们希望并发的任务，不管是异常还是正常，都可以返回对应的状态和值，这样就可以最大限度地保证服务的可访问性。新特性Promise.allSettled就是来满足这一要求的 1234567891011Promise.allSettled([ Promise.reject({status: 'fail', msg: '服务异常'}), Promise.resolve({status: 'suc', data: {}}), Promise.resolve({status: 'suc', data: {}})]).then(result =&gt; { /* * 0: {status: 'rejected', reason: {}}, * 1: {status: 'fulfilled', value: {}}, * 2: {status: 'fulfilled', value: {}} */}) 当服务异常时，会返回status和reason字段，reason值为reject的值，而当服务正常时，会返回status和value字段。可以通过filter函数来过滤出fulfilled状态的数据，从而实现服务正常的数据渲染 globalThis一般我们很难写出可移植的js代码来访问全局对象，因为在不用的环境全局对象也不同。在web中，全局对象为window、self，在node中，为global，甚至很多时候会使用this来访问全局对象，但是this严重依赖上下文，还会存在各种改变this指向的情况，这会导致更加复杂。而现在，通过一个globalThis就可以轻松获取到当前环境下的全局对象，是不是很清爽？ optional Chaining如果我们要使用到多层级对象中的某个属性，为了避免属性不存在时抛出错误，需要经过一系列前置的繁琐的判断 1234let data = {}if (data &amp;&amp; data.options &amp;&amp; data.options.name) { let name = data.options.name} 看起来很麻烦。有了可选链新特性后，只需简单一句代码 1let name = data?.options?.name 判断?前的属性是否存在，存在才会继续查询.后面的属性。简化了大量前置校验，且更为安全 Nullish coalescing Operator在对某个变量或对象的属性赋值时，我们会经常做以下类似的操作 123456let defaultFlag = 'default'let obj = { name: defaultFlag || 'obj', value: 18, level: 0} 当defaultFlag转换为布尔值是true的时候，就会采用defaultFlag代表的值，否则采用值obj，但是这会有一些问题，比如值为0的时候，defaultFlag的值就为false，这会跳过0直接赋值为后面的值，如果我们允许0的存在，那这里就会出现预想中的误差。再看新特性空值合并运算符 ?? 1let level = obj.level ?? '暂无等级' 使用空值合并运算符之后，只有当值为undefined、null的时候，才会跳过，赋值为后面的值","link":"/2020/01/13/finished-proposals-ES2020/"},{"title":"vue3.0-beta尝鲜","text":"前言尤大大前段时间发布了vue3.0-beta版本，现在趁着五一假期尝尝鲜，记录一下。 vue3设计更新点先回顾官方提出的vue3.0设计目标 更小 全局 API 和内置组件 支持 tree-shaking 常驻代码大小控制在 10kb gzipped 左右 更快 基于 Proxy 的变动侦测 Virtual DOM 重构 编译器架构重构，更多的编译时优化 加强API设计一致性 加强TypeScript支持 提高自身可维护性 代码采用 monorepo 结构，内部分层更清晰 TypeScript 使得外部贡献者更有信心做改动 开放更多底层功能 开始创建项目12345678// 升级vue-cli到4.0版本cnpm install -g @vue/cli// 创建项目（注意，这里的vue版本还是2.x）vue create vue-3.0-beta-test// 切换到项目目录 通过vue add 命令添加3.0版本vue add vue-next 然后打开项目，可以看到vue的版本已经变成^3.0.0-beta.1，还有一些插件版本的更新和新增了两个插件 对比项目结构再从项目的整体结构来看，对比2.x版本基本没有变化，主要看下变化了的main.js文件 通过图片可以看到，这里只解构出一个createApp函数，因为vue3.0支持tree-shaking，可以把每一个用到的API抽取出来，让vue变得更小 Composition API原先是叫Vue-Function-API，后面经社区意见收集，更改为Vue-Composition-API，这里面有几个变化比较大的： 生命周期钩子 reactive API ref API watch API computed API 生命周期在3.0中，生命周期发生了很大变化： 2.x 3.0 beforeCreate setup created setup beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeDestroy onBeforeUnmount destroyed onUnmounted reactive 该API作用是创建响应式对象，类似之前在data中声明变量 12345678910111213141516171819202122// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;h3&gt;{{ info.msg }}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive } from &quot;vue&quot;;export default { name: &quot;App&quot;, setup() { let info = reactive({ msg: `vue3.0-beta尝鲜` }); return { info }; }};&lt;/script&gt; 效果： ref 创建一个包装式对象，含有一个响应式属性value，通过修改value来修改值 123456789101112131415161718192021222324252627// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;h3&gt;{{ info.msg }}&lt;/h3&gt; &lt;h3&gt;{{ tip }}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive, ref } from &quot;vue&quot;;export default { name: &quot;App&quot;, setup() { let info = reactive({ msg: `vue3.0-beta尝鲜` }); let tip = ref(`value of ref`); // 通过修改value属性来修改值 tip.value = `change ref of value`; return { info, tip }; }};&lt;/script&gt; 效果： 事件处理3.0没有methods对象，也是写在setup里面 12345678910111213141516171819202122232425262728293031323334// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;h3&gt;{{ info.msg }}&lt;/h3&gt; &lt;h3&gt;tip：{{ tip }}&lt;/h3&gt; &lt;input v-model=&quot;inputValue&quot; /&gt; &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive, ref } from &quot;vue&quot;;export default { name: &quot;App&quot;, setup() { let info = reactive({ msg: `vue3.0-beta尝鲜` }); let tip = ref(`value of ref`); tip.value = `change ref of value`; let inputValue = ref(&quot;&quot;); const handleClick = () =&gt; { tip.value = inputValue.value; }; return { info, tip, inputValue, handleClick }; }};&lt;/script&gt; 上面写了一个方法，绑定一个点击事件来改变变量tip的值，效果如图： onMounted钩子我们在vue项目中用得最多的生命钩子就是created和mounted，在created发送请求，接收、处理参数之类，在mounted页面渲染后进行相关的业务处理，在上面有提过，现在beforeCreate和created 都是setup了，现在看下新的onMounted怎么用： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;h3&gt;{{ info.msg }}&lt;/h3&gt; &lt;h3&gt;tip：{{ tip }}&lt;/h3&gt; &lt;input v-model=&quot;inputValue&quot; /&gt; &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive, ref, onMounted } from &quot;vue&quot;;export default { name: &quot;App&quot;, setup() { // 省略上面例子的代码 // ... onMounted(() =&gt; { console.log(`mounted`); // 页面渲染完 获取所有h3元素 let h3List = document.querySelectorAll(&quot;h3&quot;); console.log({ h3List: h3List }); }); return { // ... }; }};&lt;/script&gt; computed12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;h3&gt;{{ info.msg }}&lt;/h3&gt; &lt;h3&gt;tip：{{ tip }}&lt;/h3&gt; &lt;h3&gt;computed num：{{ num }}&lt;/h3&gt; &lt;input v-model=&quot;inputValue&quot; /&gt; &lt;button @click=&quot;handleClick&quot;&gt;click me&lt;/button&gt; &lt;button @click=&quot;incrementNum&quot;&gt;increment&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive, ref, onMounted, computed } from &quot;vue&quot;;export default { name: &quot;App&quot;, setup() { // ... let initNum = ref(0); const incrementNum = () =&gt; { initNum.value++; }; // 让num成为计算属性 let num = computed(() =&gt; { return initNum.value * 2; }); return { // ... incrementNum, num }; }};&lt;/script&gt; 看下效果： 总结从上面的例子可以看到，3.0的语法更加简洁精炼！总的来说，3.0会兼容2.x，我们的学习成本基本就只集中在composition这一块，而更具体、更详细的内容，可访问composition-api，上面还有很丰富的内容等着我们探索，包括对TypeScript的更好支持等。","link":"/2020/05/02/vue3.0-beta尝鲜/"},{"title":"分享一道有趣的题","text":"今天在群里看到朋友发了一道有趣的题 就是如何让(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) === true这个等式成立。一开始看到这个题觉得是无稽之谈，这不扯淡吗，一个变量能同时满足几个值？但是朋友这么问还真说不定有可能，于是开始一波思考。 首先分析一下等式左边的a==1，a==2，a==3，相等符号==会判断两个变量的值是否相等，如果不相等，则会涉及到变量类型的转换，全等符号===则会同时判断变量的值和类型，其中一个不相等，则结果为false 然后我们假设等式已经成立，既然这个等式能够成立，那么变量a肯定不是一个普通的变量，至少基本数据类型满足不了这种骚操作，那么它应该是复杂数据类型。 那我们接着假定是对象，那么对象跟基本数据类型对比的时候，会有我们上面说的涉及到类型转换，对象会先转换成基本数据类型，这里就会触发原型上toString()方法，如下： 我们给a重写覆盖了toString方法，以方便我们调试，可以看到，对象在判断转换过程中，会触发toString方法。那么我们就可以根据这个特性，对a进行一波骚操作： 123456var a = { i: 1, toString: function() { return this.i++ }} 运行一下： 可以看到，等式成立！！！这说明确实可以存在这种情况的，不过现实中不建议这样重写去改变原本默认行为，可能会导致出现不可预料的错误。但是不可否认，这种骚操作的题，一定程度上可以反馈出我们对JS基础、还有一些底层操作的理解。学习路上，真的是任重而道远啊~","link":"/2020/03/22/分享一道有趣的题/"},{"title":"前端幸福感是如何炼成的（上）","text":"前言 做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？ 近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成外在因素和内在因素（技巧、技术提升）两方面，这里分享外在因素。 重要的几个点 在说外在因素之前，先看以下一些点： 熟知业务，熟悉产品原型 积极参加项目评审 技术评估，了解技术实现的细节，确定技术边界 全局视野，业务、技术拓展性 不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？ 于产品而言 熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。 很多时候技术跟产品的撕x，都是因为沟通不顺畅。 我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。 前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。 于后端而言前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？ 发现潜在的坑与隐藏的业务，及时让后端同学补充接口 制定接口文档规范，提高对接效率 接口提供时间节点（很重要！防止接口拖延！） 数据模拟，提前对接 这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过yApi、mock、easy-mock等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。 于测试而言当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？主动提供复杂的交互测试指引。 很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。 结语最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。","link":"/2019/10/04/前端幸福感是如何炼成的/"},{"title":"回归初心，重新出发","text":"很长时间没有写博客，之前有基于hexo+NextT搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。 现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。 现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。 现在重新基于hexo+icarus来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。","link":"/2019/09/24/回归初心，重新出发/"},{"title":"浅析HTTP缓存","text":"前言 浏览器缓存机制有四个方面，按照资源获取优先级排列，分别是Memory Cache、Service Worker Cache、HTTP Cache、Push Cache。我们经常使用，也比较熟悉的是HTTP Cache。这里单独分析HTTP Cache。 HTTP CacheHTTP Cache又分为强缓存和协商缓存，强缓存优先级比较高，未命中强缓存时才走协商缓存。 强缓存强缓存是通过http头的expires和cache-control来实现控制。当再发出请求时，浏览器会根据expires和cache-control来判断是否命中强缓存，若命中直接从缓存中获取资源，而不再与服务端进行通信。 在http1.0版本中，服务器响应时会返回一个缓存过期时间戳字段expires，再次发起请求时浏览器通过本地时间与expires时间戳对比，来判断缓存是否过期，这种依赖本地时间的方式会存在一个弊端，如果修改了本地时间，或者本地时间与服务端时间不同步，这将达不到我们预期的缓存效果。 因此，在http1.1版本中，引入了expires的替代方案：Cache-Control。Cache-Control能做expires做的事，也能做expires做不到的事情，目前expires还存在是为了做向下兼容。 Cache-Control的格式为： 1Cache-Control: max-age=3600 在Cache-Control中，max-age字段表示资源最大缓存时间（秒），上面例子表示在3600秒内该资源都是有效的。Cache-Control表示的时间比expires时间戳更为准确，同时Cache-Control优先级更高，两者存在时以Cache-Control为准。 Cache-Control还有其它的缓存方式：no-cache和no-store。 如果给资源设置了no-cache，则会绕开浏览器，直接询问服务器该资源是否过期，即走协商缓存。no-store顾名思义，就比较绝情了，不设置任何缓存，每次发起请求不经过浏览器与服务端缓存，直接想服务器发送请求，并下载完整的响应。 协商缓存协商缓存，顾名思义就是浏览器与服务器合作的缓存策略，它依赖于浏览器与服务器之间的通信，浏览器需要向服务器询问缓存的相关信息，进而判断是读取本地缓存的资源还是重新发起请求，下载完整的响应。 协商缓存的实现Last-Modified Last-Modified是一个时间戳，在启用协商缓存之后，会在首次请求的时候，随着Response Headers返回 1Last-Modified: Wed, 12 Feb 2020 09:21:28 GMT 随后每次请求会带上If-Modified-Since时间戳字段，值为上一次Response返回的Last-Modified值 1If-Modified-Since: Wed, 12 Feb 2020 09:21:28 GMT 服务器收到这个时间戳之后，会根据该时间戳与服务器的资源的最后修改时间对比，如果时间改变，则返回一个新的完整的响应，并在Response Headers返回新的Last-Modified值；如果时间没有变化，则返回一个304状态码，提示资源并未改动，然后重定向到浏览器缓存，Response Headers也不会再返回Last-Modified字段，如下图： 但是使用Last-Modified也会存在弊端： 资源文件改动了，但是并没有改变内容，文件的最后修改时间会变化，导致该资源会被重新请求 If-Modified-Since是以秒为单位做检验，如果改动文件的时间小于1000ms，那么该资源有可能被认为是未改变的，导致无法重新请求 这两种情况反映了一个问题，无法准确感知文件是否发生改变。 为了解决该问题，Etag出现了。 Etag是服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，文件内容不同，对应的 Etag 就是不同的，因此Etag 能够精准地感知文件的变化。 Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这个样子 1ETag: W/\"1q2w-108946715\" 在下一次请求时，会带上与之相同值的字段if-None-Match，提供给服务器对比 1If-None-Match: W/\"1q2w-108946715\" 很明显，Etag有利也有弊，它的生成需要服务器付出额外的开销，会影响服务器的性能，Etag并不能直接代替Last-Modified，而是作为补充，它的优先级比Last-Modified高，两者共存时，以Etag为准。 HTTP缓存策略对于上面讲的知识点，要如何对应到实际的开发中呢，这边拿了谷歌官方的一张图： 这张图片清楚地给我们展示了缓存策略流程。 首先看看资源的可复用性，如果是不可复用的话，很干脆，直接把Cache-control设置为no-store，不需要任何形式的缓存。 如果是可复用的资源，那么看看是否需要每次都向服务器去验证缓存是否有效，如果需要，则设置Cache-control为no-store，不需要的，则进行下一步，考虑资源是否可被代理服务器缓存，根据情况设置private或public；接着考虑资源的过期时间，设置资源的max-age；最后一步配置协商缓存，设置Last-Modified和Etag。 结语HTTP缓存的知识点比较琐碎，很多人过段时间很容易忘记。只有多分析多总结，才能够把握这些知识。","link":"/2020/02/13/浅析HTTP缓存/"},{"title":"浅析浏览器另外三大缓存","text":"前言 上一篇分析了浏览器缓存类型之一：HTTP缓存，接下来简单分析一下浏览器另外的三大缓存机制：Memory Cache、Service Worker Cache以及Push Cache。 Memory CacheMemory Cache是指内存中的缓存，是浏览器尝试命中的优先级最高的缓存，其响应速度也是最快的。 哪些资源会被放进内存缓存呢？这个没有明确的规定，因为内存本身就是有限的，对于内存来讲，很多时候需要考虑内存的即时余量以及资源本身大小，根据日常开发观察的结果，base64格式的图片几乎是被放到内存缓存，而文件体积较小的JS、CSS文件，也有很大的几率可以写进内存缓存，至于体积比较大的，用一句俗话来讲，就是“庙小容不了大佛”，几乎是不可能给写进内存缓存的。 内存缓存的响应速度虽然很快，但是相应的，它的“寿命”是比较短的，当我们关闭tab之后，内存里的数据也将不复存在。 Service Worker Cacheservice worker运行在worker上下文，因此它无法访问DOM，同时独立于主线程，可以在浏览器幕后帮我们实现消息推送、离线缓存等操作，而借助于service worker实现的缓存，就是离线缓存。 PS：出于安全考量，Service workers只能由HTTPS承载。 service worker需要先进行install（安装），之后会一直存在，并且只在active（激活）和working（工作）之间切换，直到我们主动终止。 下面看实践的例子，新建index.html和index.js两个文件 注册1234567891011121314151617181920212223242526&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;service worker test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if ('serviceWorker' in navigator) { window.addEventListener('load', () =&gt; { navigator.serviceWorker.register('./index.js', {scope: './'}) .then((res) =&gt; { console.log(`注册成功`) }) .catch(err =&gt; { console.log(`注册失败：${err}`) }) }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第一步，先判断浏览器是否支持serviceWorker； 第二步，浏览器若支持，再通过register方法注册index.js文件，scope指定service worker控制内容的子目录，该参数为可选参数，默认为根目录； 第三步，通过返回的Promise，了解注册成功或失败 安装1234567891011// index.jsthis.addEventListener('install', (event) =&gt; { event.waitUntil( caches.open('v1').then((cache) =&gt; { return cache.addAll([ 'index.html' ]) }) )}) 第一步，通过install方法，安装service worker； 第二步，这里要注意的是，从安装到激活这个过程需要一些时间，service worker标准提供一个waitUntil方法，当oninstall或者onactivate触发时被调用，接受一个promise。在这个 promise被成功resolve以前，功能性事件不会分发到service worker； 第三步，我们在waitUntil方法里面使用了cache.open来创建一个新的缓存v1，它返回一个promise，在被resolved之后调用addAll方法来添加要缓存的资源的路径；如果被rejected，service worker不会做任何操作。 运行通过webstorm打开index.html，可以为我们开启一个本地服务器，运行后可以看到： 注册成功 缓存成功 使用缓存我们成功添加缓存之后，接下来就是要使用缓存。 Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以通过监听fetch事件来处理我们的操作。 1234567// index.jsthis.addEventListener('fetch', (event) =&gt; { event.respondWith( caches.match(event.request) )}) 第一步，监听fetch事件； 第二步，通过respondWith方法劫持请求； 第三步，可以自定义我们的操作，当然最简单粗暴的就是直接返回我们缓存的资源 再刷新浏览器，可以看到，index.html来自于service worker cache Push Cachepush cache（推送缓存）是比较新颖的东西，属于HTTP/2，当前面几种缓存没有命中的时候，才会询问推送缓存。 具体的可以查看Jake Archibald大神的HTTP/2 push is tougher than I thought 文章中有部分结论： Push Cache 是缓存的最后一道防线。浏览器只有在 前面说到的几种缓存均未命中的情况下才会去询问 Push Cache； Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放； 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache； Push Cache 中的缓存只能被使用一次 结语浏览器的缓存知识博大精深，就算不断在工作中和学习中实践，也只能说理解皮毛。而理解浏览器缓存，也仅仅是我们对页面性能优化的第一步，还有更多的操作等着我们。","link":"/2020/02/18/浅析浏览器另外三大缓存/"},{"title":"《程序员修炼之道》","text":"前言最近买了《程序员修炼之道（第二版）-通向务实的最高境界》这本书，第一版是在2004年3月出版的《程序员修炼之道-从小工到专家》，听说是一本神书，90%程序员都看过（我就是那10%的一员(￣ω￣;)），还颠覆了很多IT界大牛的技术生涯。时隔16年，即今年2020年4月份出版了现在的第二版，除了回顾、更新前一版所引用的技术，两位作者还充分借鉴这16年来增加的丰富经验来重新审视前一版所推崇的时间背后的种种假设，构成了一本更胜第一版的神书。 为什么阅读这本书除了书籍本身所携带的光环和知名度之外，吸引我的还是这个书名。 《程序员修炼之道》，让我想到了星爷的《演员的自我修养》，星爷本身就是一个励志、传奇故事，他的电影可以说是很多人的美好回忆，所以这种异曲同工之妙，是第一个吸引点； 第二吸引点是书的副题，“通向务实的最高境界”，“务实”一词，给我的感触就是现实中已经越来越少有这种精神了，不单是开发，映射到各种各样的行业，“浮躁”反而是当前更多人的心态。前端开发，给人也是这种“浮躁”的感觉，培训班、自学生出来的各种不合格的初级前端，嘴里喊着“别更新了，我已经学不动了”，开发中各种骚操作，种种现象。包括我自己也算是比较浮躁，所以探索“务实”对我来说，格外的有吸引力。 阅读计划“是骡子是马拉出来溜溜”，是不是好书要读过才知道，所以自己已经开始阅读这本书，然后打算在个人博客记录、分享阅读后的感想，通过读+想+写，来让自己距离务实更近一些。 最后，瞄一眼书的样貌","link":"/2020/05/07/《程序员修炼之道》/"},{"title":"ES6 -- Proxy","text":"前言本文总结了Proxy代理的陷阱函数和对应的Reflect接口默认行为函数的用法。因为目前用的最多的技术栈是Vue，而Vue3.0版本其中关于响应式原理的核心是Proxy，因此有必要对Proxy做进一步的理解和总结。 set拦截对象：设置属性值行为。成功返回true，失败返回false。 默认行为实现：Reflect.set() 接收参数： trapTarget：设置属性的对象（代理的目标对象） key：属性的键 value：属性的值 receiver：操作发生的对象（通常指代理对象） get拦截对象：获取属性值行为。 默认行为实现：Reflect.get() 接收参数： trapTarget：获取属性的对象（代理的目标对象） key：属性的键 receiver：操作发生的对象（通常指代理对象） 骚操作：属性不存在时可明确抛出错误，而不是返回undefined 123456789let target = {}let proxyTar = new Proxy(target, { get (trapTarget, key, receiver) { if (!(key in receiver)) { throw new TypeError(`property ${key} is not exist`) } return Reflect.get(trapTarget, key, receiver) }}) has拦截对象：in操作符。成功返回true，失败返回false。 默认行为实现：Reflect.has() 接收参数： trapTarget：读取属性的对象 key：需要检查的属性的键 骚操作：通过返回false，隐藏属性 12345678910111213let target = { name: '小叮当', _age: 18}let proxyTar = new Proxy(target, { has (trapTarget, key) { // 隐藏_age属性 if (key === '_age') { return false } return Reflect.has(trapTarget, key) }}) deleteProperty拦截对象：delete操作符。成功返回true，失败返回false。 默认行为实现：Reflect.deleteProperty() 接收参数： trapTarget：删除属性的对象 key：需要删除的属性的键 骚操作：通过返回false，设置属性不可删除 1234567891011121314let target = { name: '小叮当', age: 18, idCard: '75423546574xxx'}let proxyTar = new Proxy(target, { deleteProperty (trapTarget, key) { // idCard属性不可删除 if (key === 'idCard') { return false } return Reflect.deleteProperty(trapTarget, key) }}) getPrototypeOf拦截对象：Object.getPrototypeOf()。返回值必须是一个对象或者是null，其它类型返回值会引发错误。 默认行为实现：Reflect.getPrototypeOf() 接收参数： trapTarget：需要获取原型的对象 骚操作：可通过返回null来隐藏对象原型 setPrototypeOf拦截对象：Object.setPrototypeOf()。操作不成功时应返回false以让Object.setPrototypeOf()抛出错误，若返回不为false，则认为操作成功。 默认行为实现：Reflect.setPrototypeOf() 接受参数： trapTarget：需要设置原型的对象 proto：被用作原型的对象 骚操作：可通过返回false使对象原型不可被设置 为何存在Reflect.getPrototypeOf()、Reflect.setPrototypeOf()与Object.getPrototypeOf()、Object.setPrototypeOf()两组方法？ 两组方法作用虽然相似，但还是存在一些比较显著的差别： 前者属于JS引擎底层操作，后者属于高级操作； Reflect.getPrototypeOf()接收的参数不是对象时会抛出错误；而Object.getPrototypeOf()操作前会先将参数转换为对象； Reflect.setPrototypeOf()会返回布尔值true或false表示成功或失败，Object.setPrototypeOf()操作失败时会报错，成功时会将第一个参数作为返回值； 因此，Object两个原型操作方法并不适合用来实现代理陷阱的默认行为。 对象可扩展性的陷阱函数preventExtensions拦截对象：Object.preventExtensions()。返回true或false表示操作成功或失败。 默认行为实现：Reflect.preventExtensions()。 接收参数： trapTarget：设置不可扩展的对象 isExtensible拦截对象：Object.isExtensible()。返回true或false表示操作成功或失败。 默认行为实现：Reflect.isExtensible()。 接收参数： trapTarget：设置可扩展的对象 为何存在Reflect.preventExtensions()、Reflect.isExtensible()与Object.preventExtensions()、Object.isExtensible()两组方法？ 两组方法几乎一致，但有一些差别： 接收的参数不为对象时，Object.isExtensible()是返回false，而Reflect.isExtensible()会抛出错误； Object.preventExtensions()不管参数是否是对象，都会将参数值作为自身返回值，而Reflect.preventExtensions()方法则会在参数不是对象时抛出错误，在参数为对象时返回true或false表示操作成功或失败； 底层功能的方法与对应的高层方法相比，会进行更为严格的校验； 属性描述符的陷阱函数definedProperty拦截对象：Object.defineProperty()，返回true或false表示操作成功或失败。 默认行为实现：Reflect.defineProperty()。 接收参数： tarpTarget：被定义属性的对象 key：属性的键 descriptor：为该属性准备的描述符对象 骚操作：可通过主动返回false让Object.defineProperty()抛出错误失败，也可通过返回true而不调用Reflect.defineProperty()来让Object.defineProperty()静默失败。 getOwnPropertyDescriptor拦截对象：Object.getOwnPropertyDescriptor()，返回对应的描述符。 默认行为实现：Reflect.getOwnPropertyDescriptor()。 接收参数： tarpTarget：被检索属性的对象 key：属性的键 为何存在Reflect.defineProperty()、Reflect.getOwnPropertyDescriptor()与Object.defineProperty()、Object.getOwnPropertyDescriptor()两组方法？ 两组方法几乎一致，但也有一些差别： Object.defineProperty()返回第一个参数值，而Reflect.defineProperty()返回true或false; 第一个参数不是对象时，Object.getOwnPropertyDescriptor()会将第一个参数转为对象，而Reflect.getOwnPropertyDescriptor()会抛出错误； ownKeys拦截对象：内部方法[[OwnPropertyKeys]]，返回一个数组重写该行为。数组被用于四个方法：Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.assign()，也能影响到for-in循环。不是返回数组或类数组对象，会抛出错误。 默认行为实现：Reflect.ownKeys()，返回一个由全部自有属性的键构成的数组，无论键的类型是字符串还是符号。 接收参数： trapTarget：获取属性的目标对象 骚操作：可通过设置，不返回比如拥有下划线的属性（一般被定义为私有属性） 123456789101112let target = { name: 'target', _name: 'private_target' // 私有属性}let proxyTarget = new Proxy(target, { ownKeys (trapTarget) { return Reflect.ownKeys(trapTarget).filter(key =&gt; { // 可返回符号类型、字符类型且不包含下划线的属性 return typeOf key !== 'string' || key[0] !== '_' }) }}) apply和construct拦截对象：内部方法[[Call]]和[[Construct]]，前者会在函数被直接调用时执行，而后者会在函数被使用new运算符调用时执行。 apply陷阱函数(Reflect.apply()同样)接收参数： trapTarget ：被执行的函数（即代理的目标对象）； thisArg ：调用过程中函数内部的 this 值； argumentsList ：被传递给函数的参数数组。 construct陷阱函数接收参数： trapTarget ：被执行的函数（即代理的目标对象）； argumentsList ：被传递给函数的参数数组。 Reflect.construct()除了上述两个参数，还有第三个可选参数newTarget，此参数指定了函数内部new.target的值。 骚操作：可以验证函数的类型；还可以不使用new来调用构造器；还可以限制函数只能通过new来调用等等。。。 撤销代理一般代理创建之后不会被解绑，如果想要创建一个可被撤销的代理，可通过Proxy.revocable()方法，该方法跟Proxy构造器一样接收两个参数： trapTarget：被代理的目标对象 handler：代理处理器 然后会返回一个包含以下属性的对象： proxy：可被撤销的代理对象 revoke：用于撤销代理的函数 通过调用revoke()，就无法再对proxy进行更多的操作，任何跟proxy的交互都会触发陷阱函数，从而抛出错误。","link":"/2020/01/01/ES6----Proxy/"},{"title":"响应式原理-vue2.x版（上）","text":"10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用ES5的Object.defineProperty，而新版本3.0则是使用ES6的proxy 2.x实现原理在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理： 将一个对象作为data选项（组件是data函数返回对象） 遍历data里面所有的属性，通过Object.defineProperty将属性转为getter/setter 每个组件都有一个watcher，它用来记录接触过的属性，并将其收集为依赖，当依赖的setter变更时，通知watcher，使与其有关联的组件更新 异步更新 初始化data首先对data进行初始化initData，代码路径/src/core/instance/state.js 1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm: Component) { let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { const key = keys[i] if (process.env.NODE_ENV !== 'production') { if (methods &amp;&amp; hasOwn(methods, key)) { warn( `Method \"${key}\" has already been defined as a data property.`, vm ) } } if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { proxy(vm, `_data`, key) } } // observe data observe(data, true /* asRootData */)} data的初始化主要做两件事： 对data的所有属性遍历，先检查属性是否已定义为method或prop，否则通过一个proxy函数（不是ES6的proxy），把vm._data.xxx代理到vm.xxx 调用observe实现对data的监测，把data变成响应式 下面先看自定义的代理函数proxy 代理函数proxy12345678910111213141516const sharedPropertyDefinition = { enumerable: true, configurable: true, get: noop, set: noop}export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition)} proxy函数的作用是通过Object.defineProperty，将target[sourceKey][key]的读写变成target[key]的读写。而vm._prop.xxx、vm._data.xxx可以访问到props、data里面的属性，因此通过proxy函数之后，vm._prop.xxx、vm._data.xxx就变成vm.xxx的读写了，这也是为什么props的属性和data的属性一样，可以通过vm.xxx来访问。 observeobserve的作用是监测数据的变化，代码路径/src/core/observer/index.js 1234567891011121314151617181920212223242526/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */export function observe (value: any, asRootData: ?boolean): Observer | void { if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { ob = new Observer(value) } if (asRootData &amp;&amp; ob) { ob.vmCount++ } return ob} Observer代码路径/src/core/observer/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) { this.value = value // 实例化Dep对象 this.dep = new Dep() this.vmCount = 0 // 将自身属性添加到value对象的__ob__属性 def(value, '__ob__', this) if (Array.isArray(value)) { if (hasProto) { protoAugment(value, arrayMethods) } else { copyAugment(value, arrayMethods, arrayKeys) } this.observeArray(value) } else { this.walk(value) } } /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 在Observer的构造函数里，先实例化一个Dep对象，用def函数（defineProperty的迷你版），将自身实例添加到value对象的__ob__属性，接下来判断value是数组还是对象，如果是数组，则调用observeArray，如果是对象，则调用walk函数。 接下来看一下defineReactive这个函数，代码路径/src/core/observer/index.js defineReactive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Define a reactive property on an Object. */export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { // 实例化Dep对象 const dep = new Dep() // 获取对象属性描述符 const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } })} 从代码可以看到，defineReactive先实例化一个Dep对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用observe方法，确保每个属性都能被监测到，最后通过defineProperty给属性加上用于收集依赖的getter和派发更新的setter。 到了这里，data的初始化已经完成，后面接着对收集依赖和派发更新做分析。","link":"/2019/10/11/响应式原理-2.x版本（上）/"},{"title":"前端幸福感是如何炼成的（下）","text":"前言 上一篇总结了前端对外沟通输出以及外在幸福感的炼成，这一篇主要是对内在幸福感的总结 内在的幸福感影响因素有很多，总结最主要有以下几类： 重复业务多，键盘只用ctrl+cv，空有搬砖感，毫无成就感 搬砖搬得多，稍微来加点挑战性的，逻辑绕不过，就说顶不住 面对技术的高速迭代，无从下手，茫然失措，最后迷失方向脱离前端坑路 总结出问题，那就可以很容易找到解决方法了 减少重复工作，提高编码质量大家在工作中肯定会经常遇到重复的、或者功能类似的业务，一般的操作估计就是一顿cv，疯狂复制粘贴，完事。但是这种就是单纯的体力活，久而久之，就会觉得枯燥乏味，没新鲜感、成就感，慢慢就会对工作失去热情。 这种情况，简而言之，在多处地方出现的代码，能被copy来使用的，就要想一下是否可以抽离逻辑，封装复用。而封装一般分为两种情况，配置和组件 配置CSS我们开发某一个端的应用时，经常会有一两种主题色，页面结构会有常用的布局样式，按钮等等也会有常用的样式，对于这些常用的样式，我们可以通过写成统一的css变量和类，放在一个tools文件来实现样式复用，这里采用less预处理器 12345678910111213141516171819202122// tools.less// 主题类@happy-theme: orange;@sad-theme: gray;@danger-theme: red;// 布局类.flex-align { display: flex; align-items: center;}.flex-between { display: flex; justify-content: between; align-items: center;}.flex-center { display: flex; justify-content: center; align-items: center;} 12345678910111213// test.vue&lt;template&gt; &lt;!-- 将div设置成flex居中布局 --&gt; &lt;div class=&quot;test-div flex-center&quot;&gt;&lt;/div&gt;&lt;/template&gt; &lt;style lang=&quot;less&quot;&gt; @import &apos;tools.less&apos;; // 将div背景颜色设置成happy主题 .test-div { background: @happy-theme; }&lt;/style&gt; 可以看到，引入了该工具文件实现样式复用，后续如果需求有更改，需要更换样式主题的，也只需在一个地方更改即可 JS通常我们调用后端接口的时候，后端会根据不同情况来返回不同的响应res code，比如0001表示请求成功，正常返回数据，0002表示请求成功，无数据，1000表示请求失败等，显然这里也可以做成配置 123456789101112131415const CODELIST = [ '0001': 'suc', '0002': 'no data', '1000': 'error']axios.get('/getData', {params: {}}).then(res =&gt; { if (CODELIST[res.code] === 'suc') { ... } else if (CODELIST[res.code] === 'no data') { ... } else { ... }}) 将返回码映射成文件，与不同项目不同团队对接的时候，也只是修改映射表就搞定了~ 组件说到组件大家应该也都不陌生了，组件化思想现在更是用得多姿多彩，那么重合的功能业务，我们就可以封装成组件，供不同的页面使用 比如后台管理端页面，常见的结构就是表单查询+工具栏菜单+表格列表+分页，如果有10个页面（真实情况往往不止），我们是不是要创建10遍重合度90%以上的代码？这个时候要考虑能不能抽离逻辑，做成一个组件，然后往这个组件传参数，来让它实现不同的功能。esay-page组件源码 1234567891011121314151617181920212223// parent.vue&lt;template&gt; &lt;easy-page ref=&quot;easyPage&quot; :formData=&quot;form&quot; :columns=&quot;column&quot; :layout=&quot;[&apos;form&apos;, &apos;toolbar&apos;, &apos;table&apos;, &apos;pagination&apos;]&quot; :getApi=&quot;getApi&quot;&gt; &lt;/easy-page&gt; &lt;/template&gt;&lt;script&gt; export default { const columns = [ {label: &apos;序号&apos;, prop: &apos;index&apos;}, {label: &apos;姓名&apos;, prop: &apos;name&apos;} ] data () { return { form: {}, columns, getApi: &apos;/getData&apos; } } }&lt;/script&gt; 通过这样一个组件，就可以实现简单的表单查询+工具栏+表格+分页，通过参数也可以控制页面结构。 还有类似上传功能，element-ui等UI库已经帮我们实现了很多，但是业务往往没有那么简单，我们需要基于已经实现的功能去进行二次封装 123456789101112131415// easy-upload.vue&lt;template&gt; &lt;el-upload&gt;&lt;/el-upload&gt;&lt;/template&gt;&lt;script&gt; export default { props: { // 二次封装需要的参数 }, data () { return {} } }&lt;/script&gt; 123456789101112131415// parent.vue&lt;template&gt; &lt;easy-upload :setting=&quot;setting&quot;&gt;&lt;/easy-upload&gt;&lt;/template&gt;&lt;script&gt;import EasyUpload from &apos;easy-upload.vue&apos;export default { data () { return { setting: {} // 自定义配置 } }}&lt;/script&gt; 一次封装，就能在多处进行灵活性更强的使用，而在二次封装的过程中一些逻辑处理，可比搬砖有趣多了 学习数据结构，拓展思维很多前端同事都会在google、百度、知乎等提问，“前端是否应该学习数据结构”，“前端学算法有用吗”等等问题，我觉得问这种问题，是还没从根本上理解代码存在的意义，每一个开发工程师都是通过代码跟机器打交道的，而数据结构就是数据、代码的一种结构化，是数据组织方法，不学数据结构，不学算法，怎么跟机器进行更深层次的交流？跟机器交流好比跟人沟通，好的语言组织能让我们事半功半，适合的数据结构也能让性能更加优越。 说到底，我们的业务都是基于各种不同的数据结构来完成的，只不过有一些平时写的逻辑较简单，会忽略了其实也是用到数据结构来实现的，不学数据结构，不学算法，不会知道可以用双端队列来做回文字符串检查，不会知道可以用循环链表来实现小时候爱玩的“击鼓传花”游戏，不会知道撤销、回滚是怎么实现。 回到总结，数据结构不是学不学的问题，是要往多深学，起码最基本的栈、队列、链表、树、图等都要了解，至于深度，就取决你对自己的要求以及工作中的需求 阅读源码，提高逻辑提高幸福感的另一件事，就是阅读源码了。可能有人会问，啥，阅读源码幸福？不是很痛苦？是的，源码一开始看确实很痛苦，尤其是优秀的项目一般架构比较复杂，想看也不知从何下手，但是我们可以见招拆招，从部分模块看起，比如vue中，可以看双向绑定，可以看响应式设计等等，从某个模块看起，能有效降低源码阅读难度。 而且一个优秀的框架、库是经过了时间和用户的考验，阅读源码也是我们近距离接触大神的途径，我们可以从源码中看出大神他们的设计思想，思考方法，开发逻辑等等，我们自己创造不了牛逼框架，还学习不了？ 关注行情，了解趋势 当今这个时代，努力奔跑只能保持原地不动，而停滞不前就会逐步落后 前端的发展大家有目共睹，可谓是日新月异，这个时候的我们，只能多多关注技术发展，来扩充自己的眼界，不然别人问起什么是大前端，什么时候是前端微服务，我们都是一脸懵逼，眼界将会决定我们在这条路上能走多远，走多久，如果没有幸福感，没有兴趣支撑我们前进，心越空，越容易被焦虑感填满，我们很容易就会被洪流冲走，心中有方向，前进才不会迷失。 定时review，做一个“铲屎官”最后要讲的一点，不管开发的时候对自己写的代码有多熟悉，都要写上注释，这是为后面自己或者同事review的时候做好前置工作。还有就是要定时对自己的代码做review，或者让朋友、同事帮我们review，因为不管啥时候，我们回过头来看自己的代码，都有一种在看shi的感觉，对吧？而review的过程，就是一个铲屎的过程，手握review铲，哪里有shi铲哪里，老板再也不用担心我巨坑了！一边review一边骂自己当时为啥那么sb，写出这么shi的代码，一边优化提高自己的能力，所以，review可以帮我们更好地认识自己，也能更好地提高自己~ 结语本篇从几个方面做了提升内在幸福感的总结，也是这一年多来的心得体会，可能总结不是很到位，会有很多遗漏，但就像上面说的，当我以后回过头来看这篇文章的时候，我是在review，是在优化，我还是在继续提升。","link":"/2019/11/17/前端幸福感是如何炼成的（下）/"},{"title":"响应式原理-2.x版本（下）","text":"上一篇分析了data的初始化过程以及做的一些操作，这一篇分析依赖收集和派发更新。 依赖收集先看下getter的代码 123456789101112131415161718192021222324252627282930313233343536373839404142export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, // 重点看get这部分 get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, // ... })} 在getter的逻辑里面，关键的两步是const dep = new Dep()和dep.depend()，第一步是实例化一个Dep实例，第二步就是实现依赖收集。 先看第一步，Dep的实现，代码路径/src/core/observer/dep.js Dep12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import type Watcher from './watcher'import { remove } from '../util/index'let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. */export default class Dep { static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () { this.id = uid++ this.subs = [] } // 添加观察者 addSub (sub: Watcher) { this.subs.push(sub) } // 移除观察者 removeSub (sub: Watcher) { remove(this.subs, sub) } // 依赖收集 存在target时添加观察者对象 depend () { if (Dep.target) { Dep.target.addDep(this) } } // 派发更新 省略 下面有用到 notify () { // ... }}// the current target watcher being evaluated.// this is globally unique because there could be only one// watcher being evaluated at any time.Dep.target = nullconst targetStack = []export function pushTarget (_target: ?Watcher) { if (Dep.target) targetStack.push(Dep.target) Dep.target = _target}export function popTarget () { Dep.target = targetStack.pop()} 可以看到，Dep是对subs数组的操作，而subs是watcher数组，所以Dep其实是对watchers的管理。 接着看watcher的逻辑，代码路径/src/core/observer/watcher.js Watcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137let uid = 0/** * A watcher parses an expression, collects dependencies, * and fires callback when the expression value changes. * This is used for both the $watch() api and directives. */export default class Watcher { deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; // 此处省略一堆类型声明, 具体在源码查看 // ... constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm if (isRenderWatcher) { vm._watcher = this } vm._watchers.push(this) // options if (options) { this.deep = !!options.deep this.user = !!options.user this.computed = !!options.computed this.sync = !!options.sync this.before = options.before } else { this.deep = this.user = this.computed = this.sync = false } this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.computed // for computed watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter if (typeof expOrFn === 'function') { this.getter = expOrFn } else { this.getter = parsePath(expOrFn) if (!this.getter) { this.getter = function () {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"${expOrFn}\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) } } if (this.computed) { this.value = undefined this.dep = new Dep() } else { this.value = this.get() } } /** * Evaluate the getter, and re-collect dependencies. */ get () { // 入栈 缓存Watcher pushTarget(this) let value const vm = this.vm try { // 触发依赖收集 value = this.getter.call(vm, vm) } catch (e) { if (this.user) { handleError(e, vm, `getter for watcher \"${this.expression}\"`) } else { throw e } } finally { // \"touch\" every property so they are all tracked as // dependencies for deep watching if (this.deep) { // 递归对象或数组 触发getter traverse(value) } // 出栈 恢复Watcher popTarget() // 清除不需要的依赖 逻辑实现在下面 this.cleanupDeps() } return value } /** * Add a dependency to this directive. */ addDep (dep: Dep) { const id = dep.id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { dep.addSub(this) } } } /** * Clean up for dependency collection. */ cleanupDeps () { let i = this.deps.length while (i--) { const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) { dep.removeSub(this) } } let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } // 后面省略 // ...} 从代码可以看到，实例化一个Watcher时，会执行get函数，通过pushTarget(this)将当前Watcher入栈，然后又执行this.getter.call(vm, vm)，这里的getter对应了updateComponent 函数，这里会执行一句关键代码vm._update(vm._render(), hydrating)，vm._render()会访问vm上面的数据，这里就会触发所有数据的getter，完成依赖收集。 触发依赖收集之后，根据上面代码里的注释，vue还做了三步操作 如果存在deep属性，说明存在深度依赖关系，采用递归进行依赖收集 执行popTarget()出栈，恢复watcher成上一状态 完成新订阅，执行cleanupDeps()，清除旧订阅，也就是清除旧依赖 派发更新看下setter代码 12345678910111213141516171819202122set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } // shallow为false时 将新值设置成响应式对象 childOb = !shallow &amp;&amp; observe(newVal) // 通知订阅者 dep.notify()} 值发生变化时，会调用dep的notify方法，看下Dep对notify的定义 12345678// 派发更新notify () { // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() }} 这里调用了每个watcher的update方法 123456789101112update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true // 同步时执行 } else if (this.sync) { this.run() // 推送到观察者队列 } else { queueWatcher(this) }} 这里关注run和queueWatcher run12345678910111213141516171819202122232425262728293031// run 定义在watcher里面/** * Scheduler job interface. * Will be called by the scheduler. */ run () { if (this.active) { const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) { // set new value const oldValue = this.value this.value = value if (this.user) { try { this.cb.call(this.vm, value, oldValue) } catch (e) { handleError(e, this.vm, `callback for watcher \"${this.expression}\"`) } } else { this.cb.call(this.vm, value, oldValue) } } } } run的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有deep等判断，满足其中之一就进行回调，而在通过this.get()拿值的时候，就会触发执行getter，这也是响应式数据修改时触发渲染的原因。 queueWatcher代码路径 src/core/observer/scheduler.js 123456789101112131415161718192021222324252627282930313233343536373839404142const queue: Array&lt;Watcher&gt; = []const activatedChildren: Array&lt;Component&gt; = []let has: { [key: number]: ?true } = {}let circular: { [key: number]: number } = {}let waiting = falselet flushing = falselet index = 0/** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */export function queueWatcher (watcher: Watcher) { const id = watcher.id // 保证每个watcher只会被添加一次 if (has[id] == null) { has[id] = true if (!flushing) { queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true // 同步 if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) { flushSchedulerQueue() return } // 在下一个tick 异步执行flushSchedulerQueue nextTick(flushSchedulerQueue) } }} vue在派发更新的时候使用了队列，这样做的好处就是每次数据改变时不会马上触发watcher的回调，会先将watcher添加到队列里，然后在nextTick后执行flushSchedulerQueue flushSchedulerQueue代码路径 src/core/observer/scheduler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Flush both queues and run the watchers. */function flushSchedulerQueue () { currentFlushTimestamp = getNow() flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. // 队列排序 原因如上注释 queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers // 队列遍历 for (index = 0; index &lt; queue.length; index++) { watcher = queue[index] if (watcher.before) { watcher.before() } id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) { circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) { warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.` ), watcher.vm ) break } } } // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) { devtools.emit('flush') }} flushSchedulerQueue在这里做了两件事，队列排序和队列遍历。 队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。 然后对排序后的队列进行遍历，拿到watcher执行run方法，run已在上面分析。 结语通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了proxy来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~","link":"/2019/10/14/响应式原理-2.x版本（下）/"},{"title":"风一吹不回来","text":"前几天和一个大学朋友聊起近况，他也是潮汕人，也喜欢喝茶，也喜欢看动漫，我们有很多共同的话题可以聊，当然最后话题还是回到了工作当中，我们感叹工作的压力，感慨毕业后经历的酸甜苦辣，然后不约而同地怀念起那段大学时光：一起上下课，在宿舍一起喝茶，周末还能早起在宿舍楼下打羽毛球。。。 是的，人总会怀念从前的时光，而被我们怀念的那段时光里的我们，却在忙于感慨其它事情，就像未来的某个时间里，我会怀念和感慨现在。人就是一个矛盾体，经常不懂得珍惜眼前的风景，然后又揣着患得患失的怀念继续走下去。 “听过许多大道理，依旧过不好这一生”，懂得很多道理，但是依旧处于矛盾、迷茫之中，这或许是人的本质，人非圣贤孰能无过，人就是人，人非神，非仙，自然没有完美一说。如果世上存在一个完美的人，那么他应该很孤独，很悲凉吧，处于世而离于世， 眼光所到之处，皆为荒凉，身处世界之巅，而不胜寒。 还讨论，如果可以回到过去，回到我们怀念的时光， 把每一刻都过到理想中的样子 ，那么我们还会像现在一样去怀念从前吗？显然不会。错过的就是错过，失去的就是失去，因为遗憾，我们才会铭记，当我们每段经历都过得很自然很平淡的时候，我们还会铭刻于心，去怀念吗？ 感想了那么多，最后，我还是愿揣着怀念，珍惜当下，一步一脚印地赏完春夏秋冬。","link":"/2019/11/07/风一吹不回来/"},{"title":"致敬英雄，主流网站置灰的探索","text":"2020年4月4号，清明节，全国下降半旗，北京时间十点整，全国默哀3分钟，停止一切娱乐性活动，致敬为国、为民而逝世的英雄。 国内的很多主流网站，为致敬英雄将网站全站置灰。如： 这种置灰包括了图片、按钮、文字等，那是怎样实现的呢？ 一种思路是通过对每个元素都加上统一的样式，但是这种成本太高，而且要做到没有遗漏，是一件比较费精力的事情。 另一种思路是通过主题样式设置，即设置为灰色主题，但是我们知道，主题样式会有对应的配色设计，像这种置灰是单一的，直接全体置灰，没有一些配色显示突出的设计。 上面两种方案是可以实现的，只是不符合我们程序猿简洁、高效的理念。 那有没有一种方案，靠一个属性，一个方法直接设置，就能对全站起到这样一个效果呢？如果有的话，毫无疑问这种方案是最省时省力的。 带着这种疑问，我们利用开发者工具，看了几个主流网站的代码，貌似还真的有一个属性可以实现我们的想法 1234567891011121314// b站html.gray { -webkit-filter: grayscale(.95);}// CSDN博客html { -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);} 把这些个样式勾选掉，网站果然就恢复了原来的配色，看来这种置灰操作，确实可以由属性来操控，而且跟filter属性脱不了干系。 搜下MDN，可以看到对filter的解释： CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。 也就是说，这个属性可以用来做滤镜操作。 这里展示一下所有属性设置的代码，建议前往官网查看更详细的操作和解释 12345678910111213141516171819202122/* URL to SVG filter */filter: url(\"filters.svg#filter-id\");/* &lt;filter-function&gt; values */filter: blur(5px);filter: brightness(0.4);filter: contrast(200%);filter: drop-shadow(16px 16px 20px blue);filter: grayscale(50%);filter: hue-rotate(90deg);filter: invert(75%);filter: opacity(25%);filter: saturate(30%);filter: sepia(60%);/* Multiple filters */filter: contrast(175%) brightness(3%);/* Global values */filter: inherit;filter: initial;filter: unset; 这里再引用官方的一个例子，设置高斯模糊 1filter: blur(radius) 给图像设置高斯模糊。radius 一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；如果没有设定值，则默认是 0；这个参数可设置绝对像素值，但不接受百分比值。效果如下： 再看看我们置灰用到的grayscale，它表示将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。 这样其实我们通过设置值来确定灰度的比例，就可以实现置灰的效果，而想要全栈置灰，则将该样式添加到html元素上。 为了更好的兼容性，可以加上各主流浏览器的私有前缀，即CSDN的写法 12345678html { -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);} 灰色给了一种很浓的沉重感，昨天的心情也确实很沉重。 最后，愿英魂安息，山河无恙，人间皆安。","link":"/2020/04/05/致敬英雄，主流网站置灰的探索/"}],"tags":[{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"务实","slug":"务实","link":"/tags/务实/"},{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"感想","slug":"感想","link":"/tags/感想/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"缓存","slug":"缓存","link":"/tags/缓存/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"代码人生","slug":"代码人生","link":"/categories/代码人生/"},{"name":"生活","slug":"生活","link":"/categories/生活/"},{"name":"网络","slug":"网络","link":"/categories/网络/"}]}