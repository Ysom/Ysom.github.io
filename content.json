{"pages":[{"title":"关于我","text":"95的骚年一枚，有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门。 喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前贼安静，用Eason的歌词来讲，大概是外向的孤独患者？ 超爱超爱超爱喝茶，一天能喝三四泡那种，特喜欢家乡的凤凰茶~独属家乡的味道，一杯就能融进生活，趟进心里。","link":"/about/index.html"}],"posts":[{"title":"Vue3.0，它来了","text":"10月5号凌晨，尤雨溪大大发布了vue3.0源码 现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西 整体状态 目前发布的vue3.0是Pre-Alpha版本，后续还有Alpha、Beta版本 打包后的代码是ES2015+，不支持IE11 拥抱TypeScript，98%代码使用了TypeScript编写 代码目录 由上图看到（安装了Octotree插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个packages目录，里面包含了vue3.0主要实现的功能： compiler-core：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件 compiler-dom：针对浏览器而写的编译器 reactivity：数据响应式系统。一个单独的系统，可以与任何框架配合使用 runtime-core：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API runtime-dom： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等 runtime-test：一个专门为了测试而写的轻量级 runtime server-renderer：用于 SSR（还未实现） shared：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法 template-explorer：用于模板编译输出 vue： 用于构建「完整构建」版本 由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。","link":"/2019/10/07/Vue3.0它来了，带着Pre-Alpha来了/"},{"title":"前端幸福感是如何炼成的（上）","text":"前言 做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？ 近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成外在因素和内在因素（技巧、技术提升）两方面，这里分享外在因素。 重要的几个点在说外在因素之前，先看以下一些点： 熟知业务，熟悉产品原型 积极参加项目评审 技术评估，了解技术实现的细节，确定技术边界 全局视野，业务、技术拓展性 不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？ 于产品而言 熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。 很多时候技术跟产品的撕x，都是因为沟通不顺畅。 我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。 前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。 于后端而言前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？ 发现潜在的坑与隐藏的业务，及时让后端同学补充接口 制定接口文档规范，提高对接效率 接口提供时间节点（很重要！防止接口拖延！） 数据模拟，提前对接 这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过yApi、mock、easy-mock等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。 于测试而言当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？主动提供复杂的交互测试指引。 很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。 结语最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。","link":"/2019/10/04/前端幸福感是如何炼成的/"},{"title":"回归初心，重新出发","text":"很长时间没有写博客，之前有基于hexo+NextT搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。 现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。 现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。 现在重新基于hexo+icarus来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。","link":"/2019/09/24/回归初心，重新出发/"},{"title":"响应式原理-vue2.x版（上）","text":"10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用ES5的Object.defineProperty，而新版本3.0则是使用ES6的proxy 2.x实现原理在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理： 将一个对象作为data选项（组件是data函数返回对象） 遍历data里面所有的属性，通过Object.defineProperty将属性转为getter/setter 每个组件都有一个watcher，它用来记录接触过的属性，并将其收集为依赖，当依赖的setter变更时，通知watcher，使与其有关联的组件更新 异步更新 初始化data首先对data进行初始化initData，代码路径/src/core/instance/state.js 1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm: Component) { let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { const key = keys[i] if (process.env.NODE_ENV !== 'production') { if (methods &amp;&amp; hasOwn(methods, key)) { warn( `Method \"${key}\" has already been defined as a data property.`, vm ) } } if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { proxy(vm, `_data`, key) } } // observe data observe(data, true /* asRootData */)} data的初始化主要做两件事： 对data的所有属性遍历，先检查属性是否已定义为method或prop，否则通过一个proxy函数（不是ES6的proxy），把vm._data.xxx代理到vm.xxx 调用observe实现对data的监测，把data变成响应式 下面先看自定义的代理函数proxy 代理函数proxy12345678910111213141516const sharedPropertyDefinition = { enumerable: true, configurable: true, get: noop, set: noop}export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition)} proxy函数的作用是通过Object.defineProperty，将target[sourceKey][key]的读写变成target[key]的读写。而vm._prop.xxx、vm._data.xxx可以访问到props、data里面的属性，因此通过proxy函数之后，vm._prop.xxx、vm._data.xxx就变成vm.xxx的读写了，这也是为什么props的属性和data的属性一样，可以通过vm.xxx来访问。 observeobserve的作用是监测数据的变化，代码路径/src/core/observer/index.js 1234567891011121314151617181920212223242526/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */export function observe (value: any, asRootData: ?boolean): Observer | void { if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { ob = new Observer(value) } if (asRootData &amp;&amp; ob) { ob.vmCount++ } return ob} Observer代码路径/src/core/observer/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) { this.value = value // 实例化Dep对象 this.dep = new Dep() this.vmCount = 0 // 将自身属性添加到value对象的__ob__属性 def(value, '__ob__', this) if (Array.isArray(value)) { if (hasProto) { protoAugment(value, arrayMethods) } else { copyAugment(value, arrayMethods, arrayKeys) } this.observeArray(value) } else { this.walk(value) } } /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 在Observer的构造函数里，先实例化一个Dep对象，用def函数（defineProperty的迷你版），将自身实例添加到value对象的__ob__属性，接下来判断value是数组还是对象，如果是数组，则调用observeArray，如果是对象，则调用walk函数。 接下来看一下defineReactive这个函数，代码路径/src/core/observer/index.js defineReactive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Define a reactive property on an Object. */export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { // 实例化Dep对象 const dep = new Dep() // 获取对象属性描述符 const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } })} 从代码可以看到，defineReactive先实例化一个Dep对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用observe方法，确保每个属性都能被监测到，最后通过defineProperty给属性加上用于收集依赖的getter和派发更新的setter。 到了这里，data的初始化已经完成，后面接着对收集依赖和派发更新做分析。","link":"/2019/10/11/响应式原理-2.x版本（上）/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"感想","slug":"感想","link":"/tags/感想/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"生活","slug":"生活","link":"/categories/生活/"}]}