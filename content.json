{"pages":[{"title":"关于我","text":"95的骚年一枚，有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门 喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前安静，用Eason的歌词来形容，大概就是外向的孤独患者？ 地地道道的超爱喝茶的潮汕小伙子，一天能喝三四泡茶，特喜欢家乡的凤凰茶！那种独属家乡的味道，一杯就能融进生活，趟进心里~","link":"/about/index.html"}],"posts":[{"title":"2020快到了，面对复盘的疾风吧！！！","text":"还有20来天就是2020年了，今年的你技术有提升吗？体重下降了多少？19年末的你是不是19年初想象中的你呢？ 对于我来说，“每逢佳节倍思亲，每到年底必操心”，最近本来想趁着年底，做一波基础技术复盘，优先选了js进行复盘，结果越复知识点越多，想整理成一篇博文篇幅又太长，想整成什么js知识点复盘上中下又太繁琐麻烦的样子，太难了，难于上青天啊~ 但是青天可以不上，复盘清单还是要列的，做一些知识点的复盘总结，计划尽量月底完成（maybe吧，哈哈哈~） 第一个要复盘的，肯定是前端三剑客了 HTML CSS JavaScript 接下来就是工作中的技术栈和部分学习内容了 Vue（双向绑定、响应式原理、组件设计、组件通信等） Vuex+Vue-Router等Vue全家桶 微信小程序 计算机网络（TCP、HTTP、HTTP2、HTTP3等） 数据结构（这一块处于学习阶段，列出来鞭策自己） NodeJS（这一块处于学习阶段，列出来鞭策自己） OMG，果然是“每到年底必操心”，大脑随便飘过的东西就已经这么多了，还有部分没有整理出来的比如webpack、安全防范、性能优化等等，这也侧面反映出，现在的weber需要掌握的知识点、知识面太广了，并且广且深也是一个要求趋势~ 最后，暂且就给自己定这样的复盘小目标吧！后面能想到啥重要的，再补充~","link":"/2019/12/09/2020快到了，面对复盘的疾风吧！！！/"},{"title":"JavaScript整理总结(持续更新)","text":"数据类型、存储方式 原始（基本）类型，变量存储的是在栈内存的值string、number、boolean、undefined、null、symbol、（以及提案新增的BigInt） 引用（复杂）类型，变量存储的是在栈内存中的指针（地址），指向存储的地址，地址所在的堆内存存放着值。引用类型都是object typeof和instanceoftypeof 原始类型：除了null判断为object，其它的原始类型可以正确判断 对象类型：除了函数判断为function，其它的对象类型都为object instanceof判断操作符右边的函数的原型是否存在于左边的对象的原型链上可以准确判断引用类型，无法正确判断原始类型 正确判断变量类型的方式 Object.prototype.toString.apply(target) // '[object xxx]'获取索引的第八位到最后一位 先通过typeof判断是否为复杂类型，是则使用instanceof判断 12345678910data &amp;&amp; (typeof(data) === 'object' || typeof(data) === 'function')class PrimitiveUndefined { static [Symbol.hasInstance](data) { return typeof data === 'undefined'; }}data instanceof PrimitiveUndefined// 其它基本类型... ==、=== ==符号只判断两个变量的值是否相等，===判断两个变量的类型和值 ==判断过程中，若两变量的类型不同，则会涉及到变量类型转换 var、let、const var声明的变量会被提升到作用域顶部，声明了全局变量则会挂载在window上面 let跟const声明的变量存在暂时性死区，因此在变量声明前调用会报错 const声明的变量是常量，为基础类型时值不能改变，复杂类型时地址不能改变 变量提升 变量还没有被声明，但是可以被使用（值为undefined），提升的是声明（var声明） 函数也会被提升到作用域顶部，因此函数可以在声明之前调用，且函数提升优先于变量提升 this指向 指向全局对象window 指向调用方法的对象 指向new操作符赋值后的对象 箭头函数没有this，也无法使用bind，this指向包裹该箭头函数的第一个普通函数 函数绑定多层bind的情况，由第一个bind决定 1fn.bind().bind(a)() 多个规则下this指向优先级：new &gt; bind &gt; obj.fn &gt; fn","link":"/2019/12/14/JavaScript整理总结(持续更新)/"},{"title":"Vue3.0，它来了","text":"10月5号凌晨，尤雨溪大大发布了vue3.0源码 现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西 整体状态 目前发布的vue3.0是Pre-Alpha版本，后续还有Alpha、Beta版本 打包后的代码是ES2015+，不支持IE11 拥抱TypeScript，98%代码使用了TypeScript编写 代码目录 由上图看到（安装了Octotree插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个packages目录，里面包含了vue3.0主要实现的功能： compiler-core：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件 compiler-dom：针对浏览器而写的编译器 reactivity：数据响应式系统。一个单独的系统，可以与任何框架配合使用 runtime-core：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API runtime-dom： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等 runtime-test：一个专门为了测试而写的轻量级 runtime server-renderer：用于 SSR（还未实现） shared：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法 template-explorer：用于模板编译输出 vue： 用于构建「完整构建」版本 由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。","link":"/2019/10/07/Vue3.0它来了，带着Pre-Alpha来了/"},{"title":"前端幸福感是如何炼成的（上）","text":"前言 做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？ 近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成外在因素和内在因素（技巧、技术提升）两方面，这里分享外在因素。 重要的几个点在说外在因素之前，先看以下一些点： 熟知业务，熟悉产品原型 积极参加项目评审 技术评估，了解技术实现的细节，确定技术边界 全局视野，业务、技术拓展性 不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？ 于产品而言 熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。 很多时候技术跟产品的撕x，都是因为沟通不顺畅。 我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。 前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。 于后端而言前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？ 发现潜在的坑与隐藏的业务，及时让后端同学补充接口 制定接口文档规范，提高对接效率 接口提供时间节点（很重要！防止接口拖延！） 数据模拟，提前对接 这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过yApi、mock、easy-mock等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。 于测试而言当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？主动提供复杂的交互测试指引。 很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。 结语最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。","link":"/2019/10/04/前端幸福感是如何炼成的/"},{"title":"回归初心，重新出发","text":"很长时间没有写博客，之前有基于hexo+NextT搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。 现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。 现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。 现在重新基于hexo+icarus来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。","link":"/2019/09/24/回归初心，重新出发/"},{"title":"风一吹不回来","text":"前几天和一个大学朋友聊起近况，他也是潮汕人，也喜欢喝茶，也喜欢看动漫，我们有很多共同的话题可以聊，当然最后话题还是回到了工作当中，我们感叹工作的压力，感慨毕业后经历的酸甜苦辣，然后不约而同地怀念起那段大学时光：一起上下课，在宿舍一起喝茶，周末还能早起在宿舍楼下打羽毛球。。。 是的，人总会怀念从前的时光，而被我们怀念的那段时光里的我们，却在忙于感慨其它事情，就像未来的某个时间里，我会怀念和感慨现在。人就是一个矛盾体，经常不懂得珍惜眼前的风景，然后又揣着患得患失的怀念继续走下去。 “听过许多大道理，依旧过不好这一生”，懂得很多道理，但是依旧处于矛盾、迷茫之中，这或许是人的本质，人非圣贤孰能无过，人就是人，人非神，非仙，自然没有完美一说。如果世上存在一个完美的人，那么他应该很孤独，很悲凉吧，处于世而离于世， 眼光所到之处，皆为荒凉，身处世界之巅，而不胜寒。 还讨论，如果可以回到过去，回到我们怀念的时光， 把每一刻都过到理想中的样子 ，那么我们还会像现在一样去怀念从前吗？显然不会。错过的就是错过，失去的就是失去，因为遗憾，我们才会铭记，当我们每段经历都过得很自然很平淡的时候，我们还会铭刻于心，去怀念吗？ 感想了那么多，最后，我还是愿揣着怀念，珍惜当下，一步一脚印地赏完春夏秋冬。","link":"/2019/11/07/风一吹不回来/"},{"title":"前端幸福感是如何炼成的（下）","text":"前言 上一篇总结了前端对外沟通输出以及外在幸福感的炼成，这一篇主要是对内在幸福感的总结 内在的幸福感影响因素有很多，总结最主要有以下几类： 重复业务多，键盘只用ctrl+cv，空有搬砖感，毫无成就感 搬砖搬得多，稍微来加点挑战性的，逻辑绕不过，就说顶不住 面对技术的高速迭代，无从下手，茫然失措，最后迷失方向脱离前端坑路 总结出问题，那就可以很容易找到解决方法了 减少重复工作，提高编码质量大家在工作中肯定会经常遇到重复的、或者功能类似的业务，一般的操作估计就是一顿cv，疯狂复制粘贴，完事。但是这种就是单纯的体力活，久而久之，就会觉得枯燥乏味，没新鲜感、成就感，慢慢就会对工作失去热情。 这种情况，简而言之，在多处地方出现的代码，能被copy来使用的，就要想一下是否可以抽离逻辑，封装复用。而封装一般分为两种情况，配置和组件 配置CSS我们开发某一个端的应用时，经常会有一两种主题色，页面结构会有常用的布局样式，按钮等等也会有常用的样式，对于这些常用的样式，我们可以通过写成统一的css变量和类，放在一个tools文件来实现样式复用，这里采用less预处理器 12345678910111213141516171819202122// tools.less// 主题类@happy-theme: orange;@sad-theme: gray;@danger-theme: red;// 布局类.flex-align { display: flex; align-items: center;}.flex-between { display: flex; justify-content: between; align-items: center;}.flex-center { display: flex; justify-content: center; align-items: center;} 12345678910111213// test.vue&lt;template&gt; &lt;!-- 将div设置成flex居中布局 --&gt; &lt;div class=&quot;test-div flex-center&quot;&gt;&lt;/div&gt;&lt;/template&gt; &lt;style lang=&quot;less&quot;&gt; @import &apos;tools.less&apos;; // 将div背景颜色设置成happy主题 .test-div { background: @happy-theme; }&lt;/style&gt; 可以看到，引入了该工具文件实现样式复用，后续如果需求有更改，需要更换样式主题的，也只需在一个地方更改即可 JS通常我们调用后端接口的时候，后端会根据不同情况来返回不同的响应res code，比如0001表示请求成功，正常返回数据，0002表示请求成功，无数据，1000表示请求失败等，显然这里也可以做成配置 123456789101112131415const CODELIST = [ '0001': 'suc', '0002': 'no data', '1000': 'error']axios.get('/getData', {params: {}}).then(res =&gt; { if (CODELIST[res.code] === 'suc') { ... } else if (CODELIST[res.code] === 'no data') { ... } else { ... }}) 将返回码映射成文件，与不同项目不同团队对接的时候，也只是修改映射表就搞定了~ 组件说到组件大家应该也都不陌生了，组件化思想现在更是用得多姿多彩，那么重合的功能业务，我们就可以封装成组件，供不同的页面使用 比如后台管理端页面，常见的结构就是表单查询+工具栏菜单+表格列表+分页，如果有10个页面（真实情况往往不止），我们是不是要创建10遍重合度90%以上的代码？这个时候要考虑能不能抽离逻辑，做成一个组件，然后往这个组件传参数，来让它实现不同的功能。esay-page组件源码 1234567891011121314151617181920212223// parent.vue&lt;template&gt; &lt;easy-page ref=&quot;easyPage&quot; :formData=&quot;form&quot; :columns=&quot;column&quot; :layout=&quot;[&apos;form&apos;, &apos;toolbar&apos;, &apos;table&apos;, &apos;pagination&apos;]&quot; :getApi=&quot;getApi&quot;&gt; &lt;/easy-page&gt; &lt;/template&gt;&lt;script&gt; export default { const columns = [ {label: &apos;序号&apos;, prop: &apos;index&apos;}, {label: &apos;姓名&apos;, prop: &apos;name&apos;} ] data () { return { form: {}, columns, getApi: &apos;/getData&apos; } } }&lt;/script&gt; 通过这样一个组件，就可以实现简单的表单查询+工具栏+表格+分页，通过参数也可以控制页面结构。 还有类似上传功能，element-ui等UI库已经帮我们实现了很多，但是业务往往没有那么简单，我们需要基于已经实现的功能去进行二次封装 123456789101112131415// easy-upload.vue&lt;template&gt; &lt;el-upload&gt;&lt;/el-upload&gt;&lt;/template&gt;&lt;script&gt; export default { props: { // 二次封装需要的参数 }, data () { return {} } }&lt;/script&gt; 123456789101112131415// parent.vue&lt;template&gt; &lt;easy-upload :setting=&quot;setting&quot;&gt;&lt;/easy-upload&gt;&lt;/template&gt;&lt;script&gt;import EasyUpload from &apos;easy-upload.vue&apos;export default { data () { return { setting: {} // 自定义配置 } }}&lt;/script&gt; 一次封装，就能在多处进行灵活性更强的使用，而在二次封装的过程中一些逻辑处理，可比搬砖有趣多了 学习数据结构，拓展思维很多前端同事都会在google、百度、知乎等提问，“前端是否应该学习数据结构”，“前端学算法有用吗”等等问题，我觉得问这种问题，是还没从根本上理解代码存在的意义，每一个开发工程师都是通过代码跟机器打交道的，而数据结构就是数据、代码的一种结构化，是数据组织方法，不学数据结构，不学算法，怎么跟机器进行更深层次的交流？跟机器交流好比跟人沟通，好的语言组织能让我们事半功半，适合的数据结构也能让性能更加优越。 说到底，我们的业务都是基于各种不同的数据结构来完成的，只不过有一些平时写的逻辑较简单，会忽略了其实也是用到数据结构来实现的，不学数据结构，不学算法，不会知道可以用双端队列来做回文字符串检查，不会知道可以用循环链表来实现小时候爱玩的“击鼓传花”游戏，不会知道撤销、回滚是怎么实现。 回到总结，数据结构不是学不学的问题，是要往多深学，起码最基本的栈、队列、链表、树、图等都要了解，至于深度，就取决你对自己的要求以及工作中的需求 阅读源码，提高逻辑提高幸福感的另一件事，就是阅读源码了。可能有人会问，啥，阅读源码幸福？不是很痛苦？是的，源码一开始看确实很痛苦，尤其是优秀的项目一般架构比较复杂，想看也不知从何下手，但是我们可以见招拆招，从部分模块看起，比如vue中，可以看双向绑定，可以看响应式设计等等，从某个模块看起，能有效降低源码阅读难度。 而且一个优秀的框架、库是经过了时间和用户的考验，阅读源码也是我们近距离接触大神的途径，我们可以从源码中看出大神他们的设计思想，思考方法，开发逻辑等等，我们自己创造不了牛逼框架，还学习不了？ 关注行情，了解趋势 当今这个时代，努力奔跑只能保持原地不动，而停滞不前就会逐步落后 前端的发展大家有目共睹，可谓是日新月异，这个时候的我们，只能多多关注技术发展，来扩充自己的眼界，不然别人问起什么是大前端，什么时候是前端微服务，我们都是一脸懵逼，眼界将会决定我们在这条路上能走多远，走多久，如果没有幸福感，没有兴趣支撑我们前进，心越空，越容易被焦虑感填满，我们很容易就会被洪流冲走，心中有方向，前进才不会迷失。 定时review，做一个“铲屎官”最后要讲的一点，不管开发的时候对自己写的代码有多熟悉，都要写上注释，这是为后面自己或者同事review的时候做好前置工作。还有就是要定时对自己的代码做review，或者让朋友、同事帮我们review，因为不管啥时候，我们回过头来看自己的代码，都有一种在看shi的感觉，对吧？而review的过程，就是一个铲屎的过程，手握review铲，哪里有shi铲哪里，老板再也不用担心我巨坑了！一边review一边骂自己当时为啥那么sb，写出这么shi的代码，一边优化提高自己的能力，所以，review可以帮我们更好地认识自己，也能更好地提高自己~ 结语本篇从几个方面做了提升内在幸福感的总结，也是这一年多来的心得体会，可能总结不是很到位，会有很多遗漏，但就像上面说的，当我以后回过头来看这篇文章的时候，我是在review，是在优化，我还是在继续提升。","link":"/2019/11/17/前端幸福感是如何炼成的（下）/"},{"title":"响应式原理-2.x版本（下）","text":"上一篇分析了data的初始化过程以及做的一些操作，这一篇分析依赖收集和派发更新。 依赖收集先看下getter的代码 123456789101112131415161718192021222324252627282930313233343536373839404142export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, // 重点看get这部分 get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, // ... })} 在getter的逻辑里面，关键的两步是const dep = new Dep()和dep.depend()，第一步是实例化一个Dep实例，第二步就是实现依赖收集。 先看第一步，Dep的实现，代码路径/src/core/observer/dep.js Dep12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import type Watcher from './watcher'import { remove } from '../util/index'let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. */export default class Dep { static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () { this.id = uid++ this.subs = [] } // 添加观察者 addSub (sub: Watcher) { this.subs.push(sub) } // 移除观察者 removeSub (sub: Watcher) { remove(this.subs, sub) } // 依赖收集 存在target时添加观察者对象 depend () { if (Dep.target) { Dep.target.addDep(this) } } // 派发更新 省略 下面有用到 notify () { // ... }}// the current target watcher being evaluated.// this is globally unique because there could be only one// watcher being evaluated at any time.Dep.target = nullconst targetStack = []export function pushTarget (_target: ?Watcher) { if (Dep.target) targetStack.push(Dep.target) Dep.target = _target}export function popTarget () { Dep.target = targetStack.pop()} 可以看到，Dep是对subs数组的操作，而subs是watcher数组，所以Dep其实是对watchers的管理。 接着看watcher的逻辑，代码路径/src/core/observer/watcher.js Watcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137let uid = 0/** * A watcher parses an expression, collects dependencies, * and fires callback when the expression value changes. * This is used for both the $watch() api and directives. */export default class Watcher { deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; // 此处省略一堆类型声明, 具体在源码查看 // ... constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm if (isRenderWatcher) { vm._watcher = this } vm._watchers.push(this) // options if (options) { this.deep = !!options.deep this.user = !!options.user this.computed = !!options.computed this.sync = !!options.sync this.before = options.before } else { this.deep = this.user = this.computed = this.sync = false } this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.computed // for computed watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter if (typeof expOrFn === 'function') { this.getter = expOrFn } else { this.getter = parsePath(expOrFn) if (!this.getter) { this.getter = function () {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"${expOrFn}\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) } } if (this.computed) { this.value = undefined this.dep = new Dep() } else { this.value = this.get() } } /** * Evaluate the getter, and re-collect dependencies. */ get () { // 入栈 缓存Watcher pushTarget(this) let value const vm = this.vm try { // 触发依赖收集 value = this.getter.call(vm, vm) } catch (e) { if (this.user) { handleError(e, vm, `getter for watcher \"${this.expression}\"`) } else { throw e } } finally { // \"touch\" every property so they are all tracked as // dependencies for deep watching if (this.deep) { // 递归对象或数组 触发getter traverse(value) } // 出栈 恢复Watcher popTarget() // 清除不需要的依赖 逻辑实现在下面 this.cleanupDeps() } return value } /** * Add a dependency to this directive. */ addDep (dep: Dep) { const id = dep.id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { dep.addSub(this) } } } /** * Clean up for dependency collection. */ cleanupDeps () { let i = this.deps.length while (i--) { const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) { dep.removeSub(this) } } let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } // 后面省略 // ...} 从代码可以看到，实例化一个Watcher时，会执行get函数，通过pushTarget(this)将当前Watcher入栈，然后又执行this.getter.call(vm, vm)，这里的getter对应了updateComponent 函数，这里会执行一句关键代码vm._update(vm._render(), hydrating)，vm._render()会访问vm上面的数据，这里就会触发所有数据的getter，完成依赖收集。 触发依赖收集之后，根据上面代码里的注释，vue还做了三步操作 如果存在deep属性，说明存在深度依赖关系，采用递归进行依赖收集 执行popTarget()出栈，恢复watcher成上一状态 完成新订阅，执行cleanupDeps()，清除旧订阅，也就是清除旧依赖 派发更新看下setter代码 12345678910111213141516171819202122set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } // shallow为false时 将新值设置成响应式对象 childOb = !shallow &amp;&amp; observe(newVal) // 通知订阅者 dep.notify()} 值发生变化时，会调用dep的notify方法，看下Dep对notify的定义 12345678// 派发更新notify () { // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() }} 这里调用了每个watcher的update方法 123456789101112update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true // 同步时执行 } else if (this.sync) { this.run() // 推送到观察者队列 } else { queueWatcher(this) }} 这里关注run和queueWatcher run12345678910111213141516171819202122232425262728293031// run 定义在watcher里面/** * Scheduler job interface. * Will be called by the scheduler. */ run () { if (this.active) { const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) { // set new value const oldValue = this.value this.value = value if (this.user) { try { this.cb.call(this.vm, value, oldValue) } catch (e) { handleError(e, this.vm, `callback for watcher \"${this.expression}\"`) } } else { this.cb.call(this.vm, value, oldValue) } } } } run的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有deep等判断，满足其中之一就进行回调，而在通过this.get()拿值的时候，就会触发执行getter，这也是响应式数据修改时触发渲染的原因。 queueWatcher代码路径 src/core/observer/scheduler.js 123456789101112131415161718192021222324252627282930313233343536373839404142const queue: Array&lt;Watcher&gt; = []const activatedChildren: Array&lt;Component&gt; = []let has: { [key: number]: ?true } = {}let circular: { [key: number]: number } = {}let waiting = falselet flushing = falselet index = 0/** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */export function queueWatcher (watcher: Watcher) { const id = watcher.id // 保证每个watcher只会被添加一次 if (has[id] == null) { has[id] = true if (!flushing) { queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true // 同步 if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) { flushSchedulerQueue() return } // 在下一个tick 异步执行flushSchedulerQueue nextTick(flushSchedulerQueue) } }} vue在派发更新的时候使用了队列，这样做的好处就是每次数据改变时不会马上触发watcher的回调，会先将watcher添加到队列里，然后在nextTick后执行flushSchedulerQueue flushSchedulerQueue代码路径 src/core/observer/scheduler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Flush both queues and run the watchers. */function flushSchedulerQueue () { currentFlushTimestamp = getNow() flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. // 队列排序 原因如上注释 queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers // 队列遍历 for (index = 0; index &lt; queue.length; index++) { watcher = queue[index] if (watcher.before) { watcher.before() } id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) { circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) { warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.` ), watcher.vm ) break } } } // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) { devtools.emit('flush') }} flushSchedulerQueue在这里做了两件事，队列排序和队列遍历。 队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。 然后对排序后的队列进行遍历，拿到watcher执行run方法，run已在上面分析。 结语通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了proxy来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~","link":"/2019/10/14/响应式原理-2.x版本（下）/"},{"title":"响应式原理-vue2.x版（上）","text":"10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用ES5的Object.defineProperty，而新版本3.0则是使用ES6的proxy 2.x实现原理在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理： 将一个对象作为data选项（组件是data函数返回对象） 遍历data里面所有的属性，通过Object.defineProperty将属性转为getter/setter 每个组件都有一个watcher，它用来记录接触过的属性，并将其收集为依赖，当依赖的setter变更时，通知watcher，使与其有关联的组件更新 异步更新 初始化data首先对data进行初始化initData，代码路径/src/core/instance/state.js 1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm: Component) { let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { const key = keys[i] if (process.env.NODE_ENV !== 'production') { if (methods &amp;&amp; hasOwn(methods, key)) { warn( `Method \"${key}\" has already been defined as a data property.`, vm ) } } if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { proxy(vm, `_data`, key) } } // observe data observe(data, true /* asRootData */)} data的初始化主要做两件事： 对data的所有属性遍历，先检查属性是否已定义为method或prop，否则通过一个proxy函数（不是ES6的proxy），把vm._data.xxx代理到vm.xxx 调用observe实现对data的监测，把data变成响应式 下面先看自定义的代理函数proxy 代理函数proxy12345678910111213141516const sharedPropertyDefinition = { enumerable: true, configurable: true, get: noop, set: noop}export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition)} proxy函数的作用是通过Object.defineProperty，将target[sourceKey][key]的读写变成target[key]的读写。而vm._prop.xxx、vm._data.xxx可以访问到props、data里面的属性，因此通过proxy函数之后，vm._prop.xxx、vm._data.xxx就变成vm.xxx的读写了，这也是为什么props的属性和data的属性一样，可以通过vm.xxx来访问。 observeobserve的作用是监测数据的变化，代码路径/src/core/observer/index.js 1234567891011121314151617181920212223242526/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */export function observe (value: any, asRootData: ?boolean): Observer | void { if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { ob = new Observer(value) } if (asRootData &amp;&amp; ob) { ob.vmCount++ } return ob} Observer代码路径/src/core/observer/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) { this.value = value // 实例化Dep对象 this.dep = new Dep() this.vmCount = 0 // 将自身属性添加到value对象的__ob__属性 def(value, '__ob__', this) if (Array.isArray(value)) { if (hasProto) { protoAugment(value, arrayMethods) } else { copyAugment(value, arrayMethods, arrayKeys) } this.observeArray(value) } else { this.walk(value) } } /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 在Observer的构造函数里，先实例化一个Dep对象，用def函数（defineProperty的迷你版），将自身实例添加到value对象的__ob__属性，接下来判断value是数组还是对象，如果是数组，则调用observeArray，如果是对象，则调用walk函数。 接下来看一下defineReactive这个函数，代码路径/src/core/observer/index.js defineReactive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Define a reactive property on an Object. */export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { // 实例化Dep对象 const dep = new Dep() // 获取对象属性描述符 const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } })} 从代码可以看到，defineReactive先实例化一个Dep对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用observe方法，确保每个属性都能被监测到，最后通过defineProperty给属性加上用于收集依赖的getter和派发更新的setter。 到了这里，data的初始化已经完成，后面接着对收集依赖和派发更新做分析。","link":"/2019/10/11/响应式原理-2.x版本（上）/"}],"tags":[{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"感想","slug":"感想","link":"/tags/感想/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"生活","slug":"生活","link":"/categories/生活/"}]}