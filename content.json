{"pages":[{"title":"关于我","text":"95的骚年一枚，有周游世界、踏遍千山万水的梦想，也能各种姿势宅在家里，足不出门。 喜欢交流，能侃侃而谈，也不喜欢说话，陌生人面前贼安静，用Eason的歌词来讲，大概是外向的孤独患者？ 超爱超爱超爱喝茶，一天能喝三四泡那种，特喜欢家乡的凤凰茶~独属家乡的味道，一杯就能融进生活，趟进心里。","link":"/about/index.html"}],"posts":[{"title":"Vue3.0，它来了","text":"10月5号凌晨，尤雨溪大大发布了vue3.0源码 现在抓住国庆的小尾巴，来看一看vue3.0到底有啥东西 整体状态 目前发布的vue3.0是Pre-Alpha版本，后续还有Alpha、Beta版本 打包后的代码是ES2015+，不支持IE11 拥抱TypeScript，98%代码使用了TypeScript编写 代码目录 由上图看到（安装了Octotree插件，浏览github时可以在浏览器左侧清晰展示项目结构），vue3.0仓库有一个packages目录，里面包含了vue3.0主要实现的功能： compiler-core：平台无关的编译器. 它既包含可扩展的基础功能，也包含所有平台无关的插件 compiler-dom：针对浏览器而写的编译器 reactivity：数据响应式系统。一个单独的系统，可以与任何框架配合使用 runtime-core：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API runtime-dom： 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等 runtime-test：一个专门为了测试而写的轻量级 runtime server-renderer：用于 SSR（还未实现） shared：没有暴露任何 API，主要包含了一些平台无关的内部帮助方法 template-explorer：用于模板编译输出 vue： 用于构建「完整构建」版本 由上可知，vue3.0 代码仓库结构比较清晰，代码也是模块化的。简单过一遍目录，了解vue3.0主要的内容，后面再对部分源码进行通读。","link":"/2019/10/07/Vue3.0它来了，带着Pre-Alpha来了/"},{"title":"前端幸福感是如何炼成的（上）","text":"前言 做前端开发已经有一年多了，前端这个职业，在很多人看来就是一个切图仔、页面仔，包括产品、UI或后端等同事，很多时候在他们看来，前端只需按照设计图做页面，做做交互，对接接口，工作比较简单没有难度。但是前端真的是这样简单吗？ 近年来前端需要学习的知识越来越多，从以前前端三剑客，到现在的各种框架、混合开发、各类小程序开发、打包工具、服务端知识等等，很多前端小伙伴直言学不动了，前端焦虑感也越来越强。那我们要如何在这种别人误解的目光下与焦虑感日渐强大的情况下，练就、保持前端幸福感呢？我总结了一年多以来的经历和经验，分成外在因素和内在因素（技巧、技术提升）两方面，这里分享外在因素。 重要的几个点在说外在因素之前，先看以下一些点： 熟知业务，熟悉产品原型 积极参加项目评审 技术评估，了解技术实现的细节，确定技术边界 全局视野，业务、技术拓展性 不知道大家在日常开发中，有没有做到或关注到以上这些点。其实能够影响到我们对一种职业的幸福感的外在因素，基本就是对外合作沟通，而合作比较多的，从产品到UI，后端到测试，那这跟我们上面讲到的几个点有什么联系呢？ 于产品而言 熟知业务需求，明白业务的目标、方向以及核心KPI，这是跟产品沟通最好的方法。 很多时候技术跟产品的撕x，都是因为沟通不顺畅。 我身边的同事经常跟产品撕x，但仔细听来，你会发现，撕x的原因不是因为产品设计不合理，而是业务比较难实现，但是开发的表达又不到位，没有基于业务逻辑与产品沟通，只是一味地说不行不行，导致过分撕x，影响工作进度。 前端作为最接近用户的开发者，有着天然的优势，是第一个能对项目有整体的体验和感知。而在熟知业务的情况下，我们能够对产品设计不合理之处提出建设性意见，甚至对产品设计遗漏的地方做出补充，防止后期方案不断变更。在我们对产品说“不行，做不到”的时候，要说出自己的依据、观点，最好是能基于数据依据这样的沟通，产品经理也会乐于听取我们的意见，促进产品的完善，也就不会轻易出现“根据手机壳颜色实现不同的手机主题”这样的情况。 于后端而言前端跟后端的合作，主要就是接口的对接。熟知业务的情况下，前端如何做得更好？ 发现潜在的坑与隐藏的业务，及时让后端同学补充接口 制定接口文档规范，提高对接效率 接口提供时间节点（很重要！防止接口拖延！） 数据模拟，提前对接 这里讲一个感触比较深的点，前端作为最接近用户的第一层，但其实也是项目开发的最后一层，后端提供接口给前端的时候，前端还需要对接，才能完成最后的展示，之前因为后端同学接口各种拖延，导致进度卡在我这边，不仅要加班，还可能背锅。所以开发前最好跟后端对一遍接口字段，或者让后端先写好接口文档，通过yApi、mock、easy-mock等工具模拟数据返回，提前对接接口，这样就算后端有任何逻辑改动，也不会影响到我们对接的进度，有效防止卡进度和背锅。 于测试而言当前端与后端对接完成之后，项目基本就要交给测试童鞋来测试了，这时候也是最痛苦的时候，因为我们需要对自己生产的bug负责。有一些是逻辑错误，但也有一些是比较无厘头的，包括测试童鞋对操作不熟悉而提出来的bug，这种情况无疑是既费时又降低双方的工作幸福感，那我们可以怎么做呢？主动提供复杂的交互测试指引。 很多交互复杂的操作，只有我们前端才知道具体是怎么操作的，一种常见的交互可能有几十种实现方式，操作起来也会有细微的不同，这时候主动提供操作指引，既可以提高测试童鞋的测试效率，也能减少我们处理无厘头问题的时间，节省双方的时间。 结语最好的证明就是行动，最直观的幸福感要靠自己去调节。前端不仅只是会切页面，写页面而已，前端也能在项目中担任重要的角色，解决技术和非技术性的问题。","link":"/2019/10/04/前端幸福感是如何炼成的/"},{"title":"响应式原理-vue2.x版（上）","text":"10.5尤大大发布了vue3.0 pre-alpha版本的源码，vue3.0之前，大家基本都知道响应式核心是用ES5的Object.defineProperty，而新版本3.0则是使用ES6的proxy 2.x实现原理在理解3.0的proxy实现之前，先回顾一下2.x版本基本实现原理： 将一个对象作为data选项（组件是data函数返回对象） 遍历data里面所有的属性，通过Object.defineProperty将属性转为getter/setter 每个组件都有一个watcher，它用来记录接触过的属性，并将其收集为依赖，当依赖的setter变更时，通知watcher，使与其有关联的组件更新 异步更新 初始化data首先对data进行初始化initData，代码路径/src/core/instance/state.js 1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm: Component) { let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { const key = keys[i] if (process.env.NODE_ENV !== 'production') { if (methods &amp;&amp; hasOwn(methods, key)) { warn( `Method \"${key}\" has already been defined as a data property.`, vm ) } } if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { proxy(vm, `_data`, key) } } // observe data observe(data, true /* asRootData */)} data的初始化主要做两件事： 对data的所有属性遍历，先检查属性是否已定义为method或prop，否则通过一个proxy函数（不是ES6的proxy），把vm._data.xxx代理到vm.xxx 调用observe实现对data的监测，把data变成响应式 下面先看自定义的代理函数proxy 代理函数proxy12345678910111213141516const sharedPropertyDefinition = { enumerable: true, configurable: true, get: noop, set: noop}export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition)} proxy函数的作用是通过Object.defineProperty，将target[sourceKey][key]的读写变成target[key]的读写。而vm._prop.xxx、vm._data.xxx可以访问到props、data里面的属性，因此通过proxy函数之后，vm._prop.xxx、vm._data.xxx就变成vm.xxx的读写了，这也是为什么props的属性和data的属性一样，可以通过vm.xxx来访问。 observeobserve的作用是监测数据的变化，代码路径/src/core/observer/index.js 1234567891011121314151617181920212223242526/** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */export function observe (value: any, asRootData: ?boolean): Observer | void { if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { ob = new Observer(value) } if (asRootData &amp;&amp; ob) { ob.vmCount++ } return ob} Observer代码路径/src/core/observer/index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) { this.value = value // 实例化Dep对象 this.dep = new Dep() this.vmCount = 0 // 将自身属性添加到value对象的__ob__属性 def(value, '__ob__', this) if (Array.isArray(value)) { if (hasProto) { protoAugment(value, arrayMethods) } else { copyAugment(value, arrayMethods, arrayKeys) } this.observeArray(value) } else { this.walk(value) } } /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } }} 在Observer的构造函数里，先实例化一个Dep对象，用def函数（defineProperty的迷你版），将自身实例添加到value对象的__ob__属性，接下来判断value是数组还是对象，如果是数组，则调用observeArray，如果是对象，则调用walk函数。 接下来看一下defineReactive这个函数，代码路径/src/core/observer/index.js defineReactive12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Define a reactive property on an Object. */export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { // 实例化Dep对象 const dep = new Dep() // 获取对象属性描述符 const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } })} 从代码可以看到，defineReactive先实例化一个Dep对象，之后拿到对象属性的描述符，如果对象存在子对象，将会递归调用observe方法，确保每个属性都能被监测到，最后通过defineProperty给属性加上用于收集依赖的getter和派发更新的setter。 到了这里，data的初始化已经完成，后面接着对收集依赖和派发更新做分析。","link":"/2019/10/11/响应式原理-2.x版本（上）/"},{"title":"回归初心，重新出发","text":"很长时间没有写博客，之前有基于hexo+NextT搭建了个人博客，由于没有细心维护，加上换新电脑没有备份迁移，导致之前的博客内容都没了。 现在想想，好记性真的不如烂键盘，时间会冲淡很多东西，包括你所认为的熟知的知识，唯有记录，才能加深、唤醒深度记忆。 现在有很多技术社区，像掘金、思否之类，但是并不适合发表一些偏于个人想法、生活情感之类的文章，毕竟那里是用于技术分享和解答疑惑的，所以，重新搭建个人博客，还是必要的。 现在重新基于hexo+icarus来搭建个人博客，不单用来写技术博文，也会用来记录生活的点滴，对生活的理解。生活有很多很美好的东西，我们却缺少用心去感受，生活不止眼前的代码，还有远方的期待。","link":"/2019/09/24/回归初心，重新出发/"},{"title":"响应式原理-2.x版本（下）","text":"上一篇分析了data的初始化过程以及做的一些操作，这一篇分析依赖收集和派发更新。 依赖收集先看下getter的代码 123456789101112131415161718192021222324252627282930313233343536373839404142export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, // 重点看get这部分 get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, // ... })} 在getter的逻辑里面，关键的两步是const dep = new Dep()和dep.depend()，第一步是实例化一个Dep实例，第二步就是实现依赖收集。 先看第一步，Dep的实现，代码路径/src/core/observer/dep.js Dep12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import type Watcher from './watcher'import { remove } from '../util/index'let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. */export default class Dep { static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () { this.id = uid++ this.subs = [] } // 添加观察者 addSub (sub: Watcher) { this.subs.push(sub) } // 移除观察者 removeSub (sub: Watcher) { remove(this.subs, sub) } // 依赖收集 存在target时添加观察者对象 depend () { if (Dep.target) { Dep.target.addDep(this) } } // 派发更新 省略 下面有用到 notify () { // ... }}// the current target watcher being evaluated.// this is globally unique because there could be only one// watcher being evaluated at any time.Dep.target = nullconst targetStack = []export function pushTarget (_target: ?Watcher) { if (Dep.target) targetStack.push(Dep.target) Dep.target = _target}export function popTarget () { Dep.target = targetStack.pop()} 可以看到，Dep是对subs数组的操作，而subs是watcher数组，所以Dep其实是对watchers的管理。 接着看watcher的逻辑，代码路径/src/core/observer/watcher.js Watcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137let uid = 0/** * A watcher parses an expression, collects dependencies, * and fires callback when the expression value changes. * This is used for both the $watch() api and directives. */export default class Watcher { deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; // 此处省略一堆类型声明, 具体在源码查看 // ... constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm if (isRenderWatcher) { vm._watcher = this } vm._watchers.push(this) // options if (options) { this.deep = !!options.deep this.user = !!options.user this.computed = !!options.computed this.sync = !!options.sync this.before = options.before } else { this.deep = this.user = this.computed = this.sync = false } this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.computed // for computed watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter if (typeof expOrFn === 'function') { this.getter = expOrFn } else { this.getter = parsePath(expOrFn) if (!this.getter) { this.getter = function () {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"${expOrFn}\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) } } if (this.computed) { this.value = undefined this.dep = new Dep() } else { this.value = this.get() } } /** * Evaluate the getter, and re-collect dependencies. */ get () { // 入栈 缓存Watcher pushTarget(this) let value const vm = this.vm try { // 触发依赖收集 value = this.getter.call(vm, vm) } catch (e) { if (this.user) { handleError(e, vm, `getter for watcher \"${this.expression}\"`) } else { throw e } } finally { // \"touch\" every property so they are all tracked as // dependencies for deep watching if (this.deep) { // 递归对象或数组 触发getter traverse(value) } // 出栈 恢复Watcher popTarget() // 清除不需要的依赖 逻辑实现在下面 this.cleanupDeps() } return value } /** * Add a dependency to this directive. */ addDep (dep: Dep) { const id = dep.id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { dep.addSub(this) } } } /** * Clean up for dependency collection. */ cleanupDeps () { let i = this.deps.length while (i--) { const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) { dep.removeSub(this) } } let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } // 后面省略 // ...} 从代码可以看到，实例化一个Watcher时，会执行get函数，通过pushTarget(this)将当前Watcher入栈，然后又执行this.getter.call(vm, vm)，这里的getter对应了updateComponent 函数，这里会执行一句关键代码vm._update(vm._render(), hydrating)，vm._render()会访问vm上面的数据，这里就会触发所有数据的getter，完成依赖收集。 触发依赖收集之后，根据上面代码里的注释，vue还做了三步操作 如果存在deep属性，说明存在深度依赖关系，采用递归进行依赖收集 执行popTarget()出栈，恢复watcher成上一状态 完成新订阅，执行cleanupDeps()，清除旧订阅，也就是清除旧依赖 派发更新看下setter代码 12345678910111213141516171819202122set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) { setter.call(obj, newVal) } else { val = newVal } // shallow为false时 将新值设置成响应式对象 childOb = !shallow &amp;&amp; observe(newVal) // 通知订阅者 dep.notify()} 值发生变化时，会调用dep的notify方法，看下Dep对notify的定义 12345678// 派发更新notify () { // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() }} 这里调用了每个watcher的update方法 123456789101112update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true // 同步时执行 } else if (this.sync) { this.run() // 推送到观察者队列 } else { queueWatcher(this) }} 这里关注run和queueWatcher run12345678910111213141516171819202122232425262728293031// run 定义在watcher里面/** * Scheduler job interface. * Will be called by the scheduler. */ run () { if (this.active) { const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) { // set new value const oldValue = this.value this.value = value if (this.user) { try { this.cb.call(this.vm, value, oldValue) } catch (e) { handleError(e, this.vm, `callback for watcher \"${this.expression}\"`) } } else { this.cb.call(this.vm, value, oldValue) } } } } run的作用就是拿到当前的值，进行新旧值相等、是否对象、是否有deep等判断，满足其中之一就进行回调，而在通过this.get()拿值的时候，就会触发执行getter，这也是响应式数据修改时触发渲染的原因。 queueWatcher代码路径 src/core/observer/scheduler.js 123456789101112131415161718192021222324252627282930313233343536373839404142const queue: Array&lt;Watcher&gt; = []const activatedChildren: Array&lt;Component&gt; = []let has: { [key: number]: ?true } = {}let circular: { [key: number]: number } = {}let waiting = falselet flushing = falselet index = 0/** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */export function queueWatcher (watcher: Watcher) { const id = watcher.id // 保证每个watcher只会被添加一次 if (has[id] == null) { has[id] = true if (!flushing) { queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true // 同步 if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) { flushSchedulerQueue() return } // 在下一个tick 异步执行flushSchedulerQueue nextTick(flushSchedulerQueue) } }} vue在派发更新的时候使用了队列，这样做的好处就是每次数据改变时不会马上触发watcher的回调，会先将watcher添加到队列里，然后在nextTick后执行flushSchedulerQueue flushSchedulerQueue代码路径 src/core/observer/scheduler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Flush both queues and run the watchers. */function flushSchedulerQueue () { currentFlushTimestamp = getNow() flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. // 队列排序 原因如上注释 queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers // 队列遍历 for (index = 0; index &lt; queue.length; index++) { watcher = queue[index] if (watcher.before) { watcher.before() } id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) { circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) { warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.` ), watcher.vm ) break } } } // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) { devtools.emit('flush') }} flushSchedulerQueue在这里做了两件事，队列排序和队列遍历。 队列排序的原因，源码上面也已经有了详细的注释，这里不再赘述。 然后对排序后的队列进行遍历，拿到watcher执行run方法，run已在上面分析。 结语通过上一篇和这一篇的分析，再加上vue源码本身的注释，基本是理清了响应式2.x版本的过程和原理，那vue3.0使用了proxy来替代，原理理解得差不多，理解新的实现也不会太麻烦，后面就期待3.0的到来吧~","link":"/2019/10/14/响应式原理-2.x版本（下）/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/源码/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"感想","slug":"感想","link":"/tags/感想/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"生活","slug":"生活","link":"/categories/生活/"}]}